I"8<h1 id="mysql-中的索引">MySQL 中的索引</h1>

<p>索引用来加速查询。正常来说，当查询数据时，MySQL 需要从表的第一条记录开始，读取整个表的内容，进行查询。</p>

<p>但如果有索引，MySQL 可根据索引快速定位需要查询条目的具体位置，加快了查询速度。</p>

<h2 id="原理">原理</h2>

<p>索引的原理是将被索引列的值，单独取出来存到另一种结构中以获取快速查询的效果。</p>

<p>当列有这些属性中任意一个时，会被索引， <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code>, <code class="language-plaintext highlighter-rouge">UNIQUE</code>, <code class="language-plaintext highlighter-rouge">INDEX</code>, 以及 <code class="language-plaintext highlighter-rouge">FULLTEXT</code>。</p>

<p>大部分索引以 <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree">B-trees</a> 结构存储。但有些例外：</p>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/spatial-types.html">Spatial Data 数据类型</a>，一种基于地理坐标使用数字来标识现实中对象的数据类型，使用  <a href="https://en.wikipedia.org/wiki/R-tree">R-trees</a>。</li>
  <li>MEMORY 内存表同时支持使用 <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_hash_index">hash 索引</a> 。</li>
  <li>InnoDB 引擎中对于全文本索引（FULLTEXT）直接使用列表（lists）结构。</li>
</ul>

<h2 id="mysql-使用索引的场景">MySQL 使用索引的场景</h2>

<p>以下场景将借助或依赖于索引：</p>

<ul>
  <li>使用 <code class="language-plaintext highlighter-rouge">WHERE</code> 进行条件查询时</li>
  <li>用于排除一些记录。存在多个索引可选时，MySQL 选择会获取最小记录的那个索引（the most <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_selectivity">selective</a> index）。</li>
  <li>存在多列索引的情况下，从左排开始的列的组合都可用于查询时的优化。比如三个索引列 （col1, col2, col3），查询时可以有这些组合的优化查询 (col1), (col1, col2), and (col1, col2, col3)，详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html">Section 8.3.6, “Multiple-Column Indexes”</a>。</li>
  <li>联表查询时。特别地，如果列的类型及大小相同的话，查询时会更加高效。比如 VARCHAR 和 CHAR 会当成同一类型，VARCHAR(10) and CHAR(15) 则不是同一类型，因为长度不同。</li>
  <li>使用 <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min">MIN()</a>，<a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max">MAX()</a> 函数时。</li>
  <li>进行排序或分组时。</li>
  <li>某些情况下，仅仅通过索引就能完成查询操作，无须操作真实的表记录。这种提供了查询中足够信息的索引被称为 <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_covering_index">covering index</a>。</li>
</ul>

<p>索引并不是万能的，对于数据量小的表以及对于那些查询全部数据的操作，索引的效果并不明显。相反，对于那些查询时涉及到表中大部分数据的情况下，逐条查询比使用索引要快。</p>

<h2 id="索引的类型">索引的类型</h2>

<p>主要有以下四种索引类型，关于创建索引的其他详情可参见 <a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html">MySQL Manual - 13.1.15 CREATE INDEX Syntax</a>。</p>

<ul>
  <li>Index Prefixes</li>
  <li>FULLTEXT 索引</li>
  <li>Spatial 索引</li>
  <li>MEMORY Storage Engine 中的索引</li>
</ul>

<h3 id="index-prefixes">Index Prefixes</h3>

<p>对于字符串类型的列，在索引创建语法中指定 <code class="language-plaintext highlighter-rouge">col_name(N)</code>，可将该列中前 N 个字符进行索引。通过只索引列中前 N 个字符 而非整列，可有效减小索引大小。比如索引  BLOB or TEXT 类型的列：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">test</span> <span class="p">(</span><span class="n">blob_col</span> <span class="nb">BLOB</span><span class="p">,</span> <span class="k">INDEX</span><span class="p">(</span><span class="n">blob_col</span><span class="p">(</span><span class="mi">10</span><span class="p">)));</span>
</code></pre></div></div>
<p>查询时，如果查询项超过了索引长度，索引将用来排除掉那些在索引长度范围内匹配失败的记录，剩下的记录则正常查询。</p>

<h3 id="fulltext-索引">FULLTEXT 索引</h3>

<p>全文本索引用于全文本（full-text）的搜索。只 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">InnoDB</a> 和 <a href="https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html">MyISAM</a> 两种引擎下的 CHAR，VARCHAR，TEXT 数据类型支持全文本索引。不像 Index Prefixes，该类型的索引是会对整列的。</p>

<h3 id="spatial-索引">Spatial 索引</h3>

<p><a href="https://dev.mysql.com/doc/refman/8.0/en/spatial-types.html">Spatial Data 数据类型</a> 上创建的索引。</p>

<h3 id="memory-storage-engine-中的索引">MEMORY Storage Engine 中的索引</h3>

<p> MEMORY 存储引擎默认使用 HASH 索引，但也支持 BTREE 索引。</p>

<h2 id="索引的创建">索引的创建</h2>

<p>索引可在创建表时创建，参考 <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html#create-table-indexes-keys">13.1.20 CREATE TABLE Syntax</a>，也可针对已有的表进行创建，使用 <a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html">CREATE INDEX</a> 语句。</p>

<details>
<summary>
创建索引的语法
</summary>

```sql
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
    [index_type]
    ON tbl_name (key_part,...)
    [index_option]
    [algorithm_option | lock_option] ...

key_part: {col_name [(length)] | (expr)} [ASC | DESC]

index_option:
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'
  | {VISIBLE | INVISIBLE}

index_type:
    USING {BTREE | HASH}

algorithm_option:
    ALGORITHM [=] {DEFAULT | INPLACE | COPY}

lock_option:
    LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}
```

</details>

<p>有如下类型的索引指定方式，</p>

<ul>
  <li>以列前缀的方/Column Prefix Key Parts</li>
  <li>函数形式/Functional Key Parts</li>
  <li>Unique 索引</li>
  <li>Full-Text 索引</li>
  <li>Spatial 索引</li>
</ul>

<h3 id="以列前缀的方">以列前缀的方</h3>

<p>可用于创建列中指定前缀部分 <code class="language-plaintext highlighter-rouge">col_name(length)</code> 的索引。</p>

<p>示例：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">part_of_name</span> <span class="k">ON</span> <span class="n">customer</span> <span class="p">(</span><span class="n">name</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
</code></pre></div></div>

<p>以上语句对名为 <code class="language-plaintext highlighter-rouge">name</code> 的例索引其前 10 个字符。</p>

<h3 id="函数形式">函数形式</h3>

<p>普通形式的索引只能索引列中的值，比如：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="p">(</span>
  <span class="n">col1</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
  <span class="n">col2</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
  <span class="k">INDEX</span> <span class="p">(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="p">);</span>
</code></pre></div></div>

<p>以上语句对 <code class="language-plaintext highlighter-rouge">col1</code> 整列 及 <code class="language-plaintext highlighter-rouge">col2</code> 前 10 个字符进行索引。</p>

<p>但使用函数形式，可创建针对表达式的索引，而不是表中的列。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="p">(</span><span class="n">col1</span> <span class="nb">INT</span><span class="p">,</span> <span class="n">col2</span> <span class="nb">INT</span><span class="p">,</span> <span class="k">INDEX</span> <span class="n">func_index</span> <span class="p">((</span><span class="k">ABS</span><span class="p">(</span><span class="n">col1</span><span class="p">))));</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx1</span> <span class="k">ON</span> <span class="n">t1</span> <span class="p">((</span><span class="n">col1</span> <span class="o">+</span> <span class="n">col2</span><span class="p">));</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx2</span> <span class="k">ON</span> <span class="n">t1</span> <span class="p">((</span><span class="n">col1</span> <span class="o">+</span> <span class="n">col2</span><span class="p">),</span> <span class="p">(</span><span class="n">col1</span> <span class="o">-</span> <span class="n">col2</span><span class="p">),</span> <span class="n">col1</span><span class="p">);</span>
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="k">ADD</span> <span class="k">INDEX</span> <span class="p">((</span><span class="n">col1</span> <span class="o">*</span> <span class="mi">40</span><span class="p">)</span> <span class="k">DESC</span><span class="p">);</span>
</code></pre></div></div>

<p>函数形式的索引在定义时需要满足以下的条件，否则抛错：</p>

<ul>
  <li>表达式使用括号包裹，以和列名或列的其他前缀属性区别开来。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 🚨 */</span>
<span class="k">INDEX</span> <span class="p">(</span><span class="n">col1</span> <span class="o">+</span> <span class="n">col2</span><span class="p">,</span> <span class="n">col3</span> <span class="o">-</span> <span class="n">col4</span><span class="p">)</span>

<span class="cm">/* ✅ */</span>
<span class="k">INDEX</span> <span class="p">((</span><span class="n">col1</span> <span class="o">+</span> <span class="n">col2</span><span class="p">),</span> <span class="p">(</span><span class="n">col3</span> <span class="o">-</span> <span class="n">col4</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>函数形式的表达式不能形成一个单独的列名，譬如：</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 🚨 */</span>
<span class="k">INDEX</span> <span class="p">((</span><span class="n">col1</span><span class="p">),</span> <span class="p">(</span><span class="n">col2</span><span class="p">))</span>

<span class="cm">/* ✅ */</span>
<span class="k">INDEX</span> <span class="p">(</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>函数中不能引用列前缀（column prefixes）。</li>
  <li>外键（foreign key）中不使用使用函数形式。</li>
</ul>

<h3 id="unique-索引">Unique 索引</h3>

<p>指定为 <code class="language-plaintext highlighter-rouge">UNIQUE</code> 的列约束了列中的值在记录中是唯一的，尝试插入重复值时会抛错。但允许存在多个 NULL 值，如果该列允许为空的话。</p>

<p>如果一个表拥有 <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code> 或 <code class="language-plaintext highlighter-rouge">UNIQUE NOT NULL</code> 类型的单列整型形成的索引，在 <code class="language-plaintext highlighter-rouge">SELECT</code> 语句中可使用 <code class="language-plaintext highlighter-rouge">_rowid</code> 关键词来获取索引的列：</p>

<ul>
  <li>如果存在一个整型的 <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code> 列，<code class="language-plaintext highlighter-rouge">_rowid</code> 则指代该列。</li>
  <li>否则 <code class="language-plaintext highlighter-rouge">_rowid</code> 指代第一个 <code class="language-plaintext highlighter-rouge">UNIQUE NOT NULL</code> 列。如果不存在一个 <code class="language-plaintext highlighter-rouge">UNIQUE NOT NULL</code> 类型的整型列，则不能使用 <code class="language-plaintext highlighter-rouge">_rowid</code>。</li>
</ul>

<h3 id="full-text-索引">Full-Text 索引</h3>

<p>详细的操作参见 <a href="https://dev.mysql.com/doc/refman/8.0/en/full-text-adding-collation.html">12.9.7 Adding a Collation for Full-Text Indexing</a>。</p>

<h3 id="spatial-索引-1">Spatial 索引</h3>

<p>不同存储引擎对其支持情况不一，详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html#create-index-spatial">Spatial Indexes</a>。</p>

<h2 id="相关资源">相关资源</h2>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html">MySQL Manual - 8.3.1 How MySQL Uses Indexes</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/spatial-types.html">MySQL Manual - 11.5 Spatial Data Types</a></li>
  <li><a href="https://searchsqlserver.techtarget.com/definition/spatial-data">spatial data</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/column-indexes.html">MySQL Manual  - 8.3.5 Column Indexes</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html">MySQL Manual - 13.1.15 CREATE INDEX Syntax</a></li>
</ul>

:ET