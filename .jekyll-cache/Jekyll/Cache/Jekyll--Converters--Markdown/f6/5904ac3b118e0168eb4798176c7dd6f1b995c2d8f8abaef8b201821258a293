I"+<h2 id="js-中创建给定长度的数组">JS 中创建给定长度的数组</h2>

<p>最佳直观的方式莫非使用字面量。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
</code></pre></div></div>

<p>缺点很明显，元素多的时候就捉襟见肘了。我们需要更加便捷地创建给定长度的数组。</p>

<p>首先了解下，数组以数组的形式存在时，其存储和读取是非常高效的，也就是说，数组还有以非数组的形式存在的情况。</p>

<p>与其他语言中数组是连续元素组成的数据类型不同，JS 中数组序列中是允许存在间隔，即数组中可以有「洞」。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr_with_hole</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,,</span><span class="mi">2</span><span class="p">];</span>
<span class="c1">// arr_with_hole[1] =&gt; undefined</span>
</code></pre></div></div>

<p>注意这里之所以说数组存在洞，而不是说空的地方是 <code class="language-plaintext highlighter-rouge">undefined</code>，是因为 <code class="language-plaintext highlighter-rouge">undefined</code> 是实实在在的数据类型，而数组中存在洞的地方，其并不是被初始化了一个实实在在的 <code class="language-plaintext highlighter-rouge">undefined</code>，而是只有我们在访问的时候，才得到了一个确切的 <code class="language-plaintext highlighter-rouge">undefined</code> 值。联想薛定谔的猫。</p>

<p>此时 V8 引擎中其不是以数组形式存在，而是一个以数字为键的键值对。对该数据的操作是没有正规数组那样高效的。且一旦有洞，后续将数组补全也无法恢复到真实的数组。也就是说，这个性能的损失是不可挽回的。</p>

<p>所以，JS 中尽量避免创建不连续数组。</p>

<p>另外，如果元素全为数字的数组操作起来性能会好些。</p>

<h3 id="数组构造器">数组构造器</h3>

<p>通过数组构造器可以很方便地创建指定长度的数组。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="c1">// arr =&gt; [empty × 3]</span>
<span class="c1">// arr[1] =&gt; undefined</span>
</code></pre></div></div>

<p>如你所见，这个数组全是洞。尝试访问其元素将会得到 <code class="language-plaintext highlighter-rouge">undefined</code>。所以，</p>

<ul>
  <li>其性能差</li>
  <li><code class="language-plaintext highlighter-rouge">undefined</code> 不是一个友好的初始值</li>
</ul>

<p>如果为了解决初始值的问题，数组身上的 <code class="language-plaintext highlighter-rouge">fill()</code> 方法能派上用场。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// arr =&gt; [0,0,0]</span>
<span class="c1">// arr.fill('hello') =&gt; ['hello','hello','hello']</span>
</code></pre></div></div>

<p><em>注意</em>：如果使用对象填充数组，数组所有元素指向的是同一对象。这点不难理解，但是很坑爹。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">fill</span><span class="p">({});</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">张三</span><span class="dl">"</span><span class="p">;</span>
<span class="c1">// a[1] =&gt; {name:'张三'}</span>
</code></pre></div></div>

<h3 id="使用循环">使用循环</h3>

<p>既然字面量方式无法满足任意长度的情况，那明直接的办法就是 <code class="language-plaintext highlighter-rouge">for</code> 循环了。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">NUM</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">NUM</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// arr =&gt; [0,0,0]</span>
</code></pre></div></div>

<p>此种方式创建的数组没有洞，原生高效，但创建过程并不高效，因为在内部实现上，每次元素的添加都需要重新分配空间。</p>

<h3 id="arrayfrom"><code class="language-plaintext highlighter-rouge">Array.from</code></h3>

<p><code class="language-plaintext highlighter-rouge">Array.from</code> 可以从数组创建数组。特别地，它可以将类数组（array-like）转成真·数组。</p>

<p>类数组最著名代表人物有:</p>

<ul>
  <li>函数内部获取到的参数对象 <code class="language-plaintext highlighter-rouge">arguments</code>，</li>
  <li><code class="language-plaintext highlighter-rouge">document.querSelector('p')</code> 返回的 DOM 节点列表</li>
</ul>

<p>类数组只是呈现上像数组，因为是假的，其身上并没有数组该有的原型方法比如 <code class="language-plaintext highlighter-rouge">sort()</code>，<code class="language-plaintext highlighter-rouge">filter()</code>。</p>

<p><code class="language-plaintext highlighter-rouge">Array.from</code> 也会将数组中薛定谔的洞塌缩成具体的值，于是我们可以通过它轻松得到一个全是 <code class="language-plaintext highlighter-rouge">undefined</code> 的数组。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span> <span class="c1">// [undefined,undefined,undefined]</span>
</code></pre></div></div>

<p>此外，<code class="language-plaintext highlighter-rouge">.from()</code> 可以传递一个 <code class="language-plaintext highlighter-rouge">map</code> 方法作为第二个参数，这样在创建新数组时会运用上这个映射函数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">i</span><span class="p">);</span> <span class="c1">// [0,1,2]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">矢泽妮可</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// ['矢泽妮可','矢泽妮可','矢泽妮可']</span>
</code></pre></div></div>

<p><em>Bonus</em></p>

<p>若不真的看见，我大概不会相信还可以这样操作：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">({</span> <span class="na">length</span><span class="p">:</span> <span class="mi">3</span> <span class="p">},</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">矢泽妮可</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// ['矢泽妮可','矢泽妮可','矢泽妮可']</span>
</code></pre></div></div>

<p>缘何上面的代码也能给我们三个可爱的「矢泽妮可」。魔法在于 <code class="language-plaintext highlighter-rouge">{length: 3}</code> 被当作类数组处理了，天秀！</p>

<h3 id="keys"><code class="language-plaintext highlighter-rouge">keys()</code></h3>

<p><code class="language-plaintext highlighter-rouge">keys()</code> 返回 iterable，通过将其解构可以得到数组：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[...</span><span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nx">keys</span><span class="p">()];</span> <span class="c1">// [ 0, 1, 2 ]</span>
</code></pre></div></div>

<h3 id="tips">Tips</h3>

<ul>
  <li>关注代码的可读性而不是微小的性能差异，因为现今的 JS 引擎可以很好地处理性能了</li>
  <li>如果处理的是大量数字类型的数组，使用 <a href="http://exploringjs.com/es6/ch_typed-arrays.html"><code class="language-plaintext highlighter-rouge">Typed Arrays</code></a></li>
</ul>

<h3 id="参考">参考</h3>

<ul>
  <li><a href="http://2ality.com/2018/12/creating-arrays.html#cheat-sheet-creating-arrays">Creating and filling Arrays of arbitrary lengths in JavaScript</a></li>
</ul>

:ET