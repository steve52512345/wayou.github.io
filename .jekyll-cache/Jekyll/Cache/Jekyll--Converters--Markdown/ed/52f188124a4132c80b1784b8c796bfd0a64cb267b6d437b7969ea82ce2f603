I"7b<h2 id="排列组合问题">排列组合问题</h2>

<p>排列和组合是两个问题，因为有相似性，所以通常放一起。</p>

<p>所谓排列，是跟顺序有关的，比如从 <code class="language-plaintext highlighter-rouge">1,2,3</code> 中取三个数出来，序列 <code class="language-plaintext highlighter-rouge">1,2,3</code> 与 <code class="language-plaintext highlighter-rouge">1,3,2</code> 是两个不同的序列。这便是排列。</p>

<p>而组合则与顺序无关，比如从 <code class="language-plaintext highlighter-rouge">1,2,3</code> 这一序列中取两个数出来， <code class="language-plaintext highlighter-rouge">1,2</code> 与 <code class="language-plaintext highlighter-rouge">2,1</code> 只能算一种取法，只关心元素不关心顺序。</p>

<p>先来看排列。</p>

<h3 id="排列permutation">排列/Permutation</h3>

<p>考察 LeetCode 上面这个排列题目：</p>

<blockquote>
  <p>Given a collection of distinct numbers, return all possible permutations.</p>

  <p>For example,
<code class="language-plaintext highlighter-rouge">[1,2,3]</code> have the following permutations:</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>
</code></pre></div></div>

<p>转述一下：对于给定非重复序列<code class="language-plaintext highlighter-rouge">[1,2,3]</code>，找出其所有可能的排列。相当于从 n 个元素中取出 n 个，看有多少种排列。</p>

<p>这样说来，就和中学数学的公式可以联系起来了。</p>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-permutation-and-combination/assets/formula.png" alt="排列组合公式" /></p>

<p><strong>排列组合公式</strong></p>

<p>通过上面的公式，我们可以算出 <code class="language-plaintext highlighter-rouge">A3,3 = 3!/(3-3)! = 3!/1 = 3x2x1 = 6</code>。
即一共有 6 种可能的排列，以此来验证我们后面实现的算法得到的结果是否准确。</p>

<p>接下来的任务是实现一个方法，找出所有排列。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @param {number[]} nums
 * @return {number[][]}
 */</span>
<span class="kd">var</span> <span class="nx">permute</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 实现</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="问题分析">问题分析</h4>

<p>假设让人脑来解决这个问题，我们屡一下思路：</p>

<ul>
  <li>取出第一个元素 <code class="language-plaintext highlighter-rouge">1</code>, 剩下的 <code class="language-plaintext highlighter-rouge">[2,3]</code> 中有两种取法</li>
  <li>先取 <code class="language-plaintext highlighter-rouge">2</code> 再取 <code class="language-plaintext highlighter-rouge">3</code>， 得到 <code class="language-plaintext highlighter-rouge">[1,2,3]</code></li>
  <li>先取 <code class="language-plaintext highlighter-rouge">3</code> 再取 <code class="language-plaintext highlighter-rouge">2</code>， 得到 <code class="language-plaintext highlighter-rouge">[1,3,2]</code></li>
  <li><code class="language-plaintext highlighter-rouge">1</code> 打头的取完了，考虑先取 <code class="language-plaintext highlighter-rouge">2</code>，从剩下的 <code class="language-plaintext highlighter-rouge">[1,3]</code> 中，也有两种取法</li>
  <li>于是分别得到 <code class="language-plaintext highlighter-rouge">[2,1,3]</code>，<code class="language-plaintext highlighter-rouge">[2,3,1]</code></li>
  <li>最后先取 <code class="language-plaintext highlighter-rouge">3</code>，也能得到两种排列 <code class="language-plaintext highlighter-rouge">[3,1,2]</code>，<code class="language-plaintext highlighter-rouge">[3,2,1]</code></li>
  <li>最后得到完整的结果为 <code class="language-plaintext highlighter-rouge">[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></li>
</ul>

<p>将上面的步骤抽象到类似伪代码的表示方式，可以方便我们将问题细化，最后得到一个递归的实现思路。</p>

<p>假设我们已经写好这么一个方法 <code class="language-plaintext highlighter-rouge">permute</code> 了，它的功能是对于输入数组，输出其所有排列。</p>

<p>于是上面的思路可以描述成：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">permute</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">permute</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> 
                 <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="nx">permute</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
                 <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="nx">permute</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>

<span class="nx">permute</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="nx">permute</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
               <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="nx">permute</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>

<span class="nx">permute</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div></div>

<p>从整体数组中取出一个，剩下的数组中进行看成新的输入。如此重复，直到最后的输入变成一个元素，一个元素的排列就是其本身。第一步得到的结果都往下传递，到达到后一个元素时，我们便会得到一条完整的结果，最后所有的结果汇总便是总的结果。</p>

<p>所以，我们应该有一个变量来存放最后的总结果，然后对于每次递归的终点我们有对应的变量存放单个结果。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">var</span> <span class="nx">permute</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">input</span><span class="cm">/*上一次处理后剩下的元素*/</span><span class="p">,</span> <span class="nx">prevResult</span><span class="cm">/*上一次处理后的结果*/</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">input</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//遍历输入，将其中的每个元素都取出压入一次结果中，对于剩下的元素递归调用进行同样的操作</span>
                <span class="c1">//...</span>
                <span class="nx">process</span><span class="p">(</span><span class="nx">nextInput</span><span class="p">,</span> <span class="nx">currentResult</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 输入为1个元素了，表示我们寻找到了终点</span>
            <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="cm">/*这里我们会得到一条结果，压入总结果中*/</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">process</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>每次操作，当输入长度不为 1 时，说明没有递归到最终，于是我们将输入中每个元素取出来放入一个临时结果中，将这个临时结果传递给下一次操作。每次操作都会往这个结果里增加一个元素。直到进行到输入还剩下一个元素的时候，我们便会得到一个完整的结果。将所有的结果合并，便得到了全部结果。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @param {number[]} nums
 * @return {number[][]}
 */</span>
<span class="kd">var</span> <span class="nx">permute</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>

	<span class="cm">/**
	 * @param {number[]} input 输入数组
	 * @param {number[]} prevResult 上一次得到的结果
	 * @return {number[]}
	 */</span>
    <span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">prevResult</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">input</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">currentResult</span> <span class="o">=</span> <span class="nx">prevResult</span> <span class="o">||</span> <span class="p">[];</span>
                <span class="nx">currentResult</span> <span class="o">=</span> <span class="nx">currentResult</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">input</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
                <span class="kd">var</span> <span class="nx">nextInput</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
                <span class="nx">nextInput</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                <span class="nx">process</span><span class="p">(</span><span class="nx">nextInput</span><span class="p">,</span> <span class="nx">currentResult</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">currentResult</span> <span class="o">=</span> <span class="nx">prevResult</span> <span class="o">||</span> <span class="p">[];</span>
            <span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="nx">currentResult</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
            <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">row</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">process</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">permute</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
</code></pre></div></div>

<h3 id="组合combination">组合/Combination</h3>

<p>同样地，来看这个来自 LeetCode 关于组合的题目：</p>

<blockquote>
  <p>Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.</p>

  <p>For example,
If n = 4 and k = 2, a solution is:</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
<span class="p">]</span>
</code></pre></div></div>

<p>即，对于给定正整数 n，从序列 1~n 中取出 k 个数，找出所有取法。</p>

<p>比如从 <code class="language-plaintext highlighter-rouge">[1,2,3,4]</code> 中取 2 个数，通过组合公式我们可以得出可能的取法一共有</p>

<p><code class="language-plaintext highlighter-rouge">C4,2 = 4!/2!(4-2)! = 4!/2!2! = (4x3x2x1)/(2x1)(2x1) = 6</code></p>

<p>6种取法。</p>

<p>下面我们来实现 <code class="language-plaintext highlighter-rouge">combine</code> 函数，找出所有的组合。</p>

<p>思路和排列的类似，也是先将问题进行拆分，直到不能再拆。</p>

<p>假设从 <code class="language-plaintext highlighter-rouge">[1,2,3,4]</code> 中取 2 个表示为 <code class="language-plaintext highlighter-rouge">combine([1,2,3,4],2)</code>。那么取出 <code class="language-plaintext highlighter-rouge">1</code> 后，我们接下来需要在剩下的 <code class="language-plaintext highlighter-rouge">[2,3,4]</code> 中 1 个元素，最后达到要求的 2 个元素。而从剩下的 <code class="language-plaintext highlighter-rouge">[2,3,4]</code> 取 1 个元素可类似地表示为 <code class="language-plaintext highlighter-rouge">combine([2,3,4],1)</code>。到这里又看到了递归的影子。当问题拆分到从数组中取一个元素时，就拆不动了，因为从 n 个元素中取 1 个元素，有 n 种取法，无需再拆分。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">combine</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">combine</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
                 <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="nx">combine</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
                 <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="nx">combine</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>

<span class="nx">combine</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span>
</code></pre></div></div>

<p>稍加调试将上面的思路转成代码我们得到：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */</span>
<span class="kd">var</span> <span class="nx">combine</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="cm">/**
     * @param {*} i 序号
     * @param {*} n 总数
     * @param {*} k 要取的个数
     * @param {*} a 上一次的结果
     */</span>
    <span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">||</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">||</span> <span class="p">[];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="p">[];</span>
                <span class="nx">row</span> <span class="o">=</span> <span class="nx">row</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
                <span class="nx">row</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
                <span class="nx">process</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">row</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
                <span class="nx">row</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
                <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">process</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">k</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">combine</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="相关资源">相关资源</h3>

<ul>
  <li><a href="https://leetcode.com/problems/permutations/description/">LeetCode Permutations</a></li>
  <li><a href="https://leetcode.com/problems/combinations/description/">LeetCode Combinations</a></li>
  <li><a href="http://jsfiddle.net/jinwolf/Ek4N5/29/">Permutation &amp; Combination - JSFiddle</a></li>
  <li><a href="https://initjs.org/all-permutations-of-a-set-f1be174c79f8">Implement All Permutations of a Set in JavaScript</a></li>
</ul>

:ET