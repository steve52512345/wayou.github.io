<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>MySQL 联表查询 | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="MySQL 联表查询" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="MySQL 联表查询 关系型数据库，免不了表之间存在各种引用与关联。这些关联是通过主键与外键搭配来形成的。所以，取数据时，很大情况下单张表无法满足需求，额外的数据则需要将其他表加入到查询中来，这便是 JOIN 关键字完成的操作。 MySQL 中 JOIN, CROSS JOIN 和 INNER JOIN 三者语法功能上相同，可互换，而 SQL 标准中，INNER JOIN 需要搭配 ON 语句。 多表联合查询时，可省略 JOIN 关键字，以逗号分隔多张表，此时默认会当作 INNER JOIN 来处理。比如, SELECT table1.*, table2.* FROM table1, table2; 等效于： SELECT table1.*, table2.* FROM table1 INNER JOIN table2; 但这种通过逗号隐式指定的联表形式其优先级要低于直接通过关键字（INNER JOIN, CROSS JOIN, LEFT JOIN）指定的形式。所以 t1, t2 JOIN t3 会被解析成 (t1, (t2 JOIN t3)) 而不是 ((t1, t2) JOIN t3) 需要注意的是，当逗号形式与其他联表关键词结合时，在指定了联表条件，比如通过 ON 条件时，会报错。 ON 指定的联表条件其语法同 WHERE，所有后者可接受的表达式都可用于 ON。两者看起来功能上雷同，ON 一般用于指定联表条件，即表之间怎么被联合，而 WHERE 则用于过滤结果。 LEFT JOIN 时，右边表中不满足 ON 或 USING 指定的条件时，会在结果中以 NULL 呈现。 SELECT left_tbl.* FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id = right_tbl.id WHERE right_tbl.id IS NULL; 通过此方法可方便地过滤出右边表中不符合条件的记录。 联表查询时可为每张参与进来的表指定别名，方便在其他表达式中引用。两种方式，一个是通过 AS 关键字 tbl_name AS alias_name，另一种是直接在表名后面跟上别名，tbl_name alias_name。 SELECT t1.name, t2.salary FROM employee AS t1 INNER JOIN info AS t2 ON t1.name = t2.name; SELECT t1.name, t2.salary FROM employee t1 INNER JOIN info t2 ON t1.name = t2.name; 一条查询语句中的子查询必需取一个别名，这样才能在其他表达式中引用。 SELECT * FROM (SELECT 1, 2, 3) AS t1; USING(join_column_list) 语句指定两个表中均包含的列，查询时只针对这里指定的列进行比较。 a LEFT JOIN b USING (c1, c2, c3) NATURAL [LEFT] JOIN 与 INNER JOIN 和 LEFT JOIN 配合使用了 USING 指定表中所有列的情况等效。 RIGHT JOIN 与 LEFT JOIN 类似，只是最终结果是依据右边表，将左边表中不符合的在结果中以 NULL 呈现。为了方便在不同数据库间迁移，推荐始终使用 LEFT JOIN。 一些 JOIN 示例： SELECT * FROM table1, table2; SELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id; SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id; SELECT * FROM table1 LEFT JOIN table2 USING (id); SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id LEFT JOIN table3 ON table2.id = table3.id; NATURAL JOIN 的结果中不会有重复的列。因为其与 USING 雷同，所以 USING 时也没有复杂的列。 考察下面的示例： CREATE TABLE t1 (i INT, j INT); CREATE TABLE t2 (k INT, j INT); INSERT INTO t1 VALUES(1, 1); INSERT INTO t2 VALUES(1, 1); SELECT * FROM t1 NATURAL JOIN t2; SELECT * FROM t1 JOIN t2 USING (j); 查询结果： +------+------+------+ | j | i | k | +------+------+------+ | 1 | 1 | 1 | +------+------+------+ +------+------+------+ | j | i | k | +------+------+------+ | 1 | 1 | 1 | +------+------+------+ 结果中同名的列只出现一次，且都是值相同的那些记录。 通过向两表中插入一条新记录，令它们的 j 不相同，再进行测试。 mysql&gt; INSERT INTO t1 VALUES(2, 2); Query OK, 1 row affected (0.00 sec) mysql&gt; INSERT INTO t2 VALUES(2, 3); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from t1 natural join t2; +------+------+------+ | j | i | k | +------+------+------+ | 2 | 2 | 1 | +------+------+------+ 1 row in set (0.00 sec) USING 和 ON 作为条件时其他限制的联合条件是一样的，可互相转换。但在 SELECT * 返回结果时，还是有差异的。前者只在 USING 中指定的列中返回合并后的结果，后者则针对的是表中所有列。 a LEFT JOIN b USING (c1, c2, c3) a LEFT JOIN b ON a.c1 = b.c1 AND a.c2 = b.c2 AND a.c3 = b.c3 USING 情况下的返回： COALESCE(a.c1, b.c1), COALESCE(a.c2, b.c2), COALESCE(a.c3, b.c3) ON 的返回： a.c1, a.c2, a.c3, b.c1, b.c2, b.c3 ON 语句中只能引用其操作表（operands）中的表。 CREATE TABLE t1 (i1 INT); CREATE TABLE t2 (i2 INT); CREATE TABLE t3 (i3 INT); 针对上面的表，以下查询会报错： mysql&gt; SELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3; ERROR 1054 (42S22): Unknown column &#39;i3&#39; in &#39;on clause&#39; 而以下查询则可以： mysql&gt; SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3); Empty set (0.00 sec) 因为此时 t3 在 ON 语句的操作范围内了。 相关资源 MySQL 8.0 Reference Manual - 13.2.10.2 JOIN Syntax MySQL 8.0 Reference Manual - 13.2.10.3 UNION Syntax" />
<meta property="og:description" content="MySQL 联表查询 关系型数据库，免不了表之间存在各种引用与关联。这些关联是通过主键与外键搭配来形成的。所以，取数据时，很大情况下单张表无法满足需求，额外的数据则需要将其他表加入到查询中来，这便是 JOIN 关键字完成的操作。 MySQL 中 JOIN, CROSS JOIN 和 INNER JOIN 三者语法功能上相同，可互换，而 SQL 标准中，INNER JOIN 需要搭配 ON 语句。 多表联合查询时，可省略 JOIN 关键字，以逗号分隔多张表，此时默认会当作 INNER JOIN 来处理。比如, SELECT table1.*, table2.* FROM table1, table2; 等效于： SELECT table1.*, table2.* FROM table1 INNER JOIN table2; 但这种通过逗号隐式指定的联表形式其优先级要低于直接通过关键字（INNER JOIN, CROSS JOIN, LEFT JOIN）指定的形式。所以 t1, t2 JOIN t3 会被解析成 (t1, (t2 JOIN t3)) 而不是 ((t1, t2) JOIN t3) 需要注意的是，当逗号形式与其他联表关键词结合时，在指定了联表条件，比如通过 ON 条件时，会报错。 ON 指定的联表条件其语法同 WHERE，所有后者可接受的表达式都可用于 ON。两者看起来功能上雷同，ON 一般用于指定联表条件，即表之间怎么被联合，而 WHERE 则用于过滤结果。 LEFT JOIN 时，右边表中不满足 ON 或 USING 指定的条件时，会在结果中以 NULL 呈现。 SELECT left_tbl.* FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id = right_tbl.id WHERE right_tbl.id IS NULL; 通过此方法可方便地过滤出右边表中不符合条件的记录。 联表查询时可为每张参与进来的表指定别名，方便在其他表达式中引用。两种方式，一个是通过 AS 关键字 tbl_name AS alias_name，另一种是直接在表名后面跟上别名，tbl_name alias_name。 SELECT t1.name, t2.salary FROM employee AS t1 INNER JOIN info AS t2 ON t1.name = t2.name; SELECT t1.name, t2.salary FROM employee t1 INNER JOIN info t2 ON t1.name = t2.name; 一条查询语句中的子查询必需取一个别名，这样才能在其他表达式中引用。 SELECT * FROM (SELECT 1, 2, 3) AS t1; USING(join_column_list) 语句指定两个表中均包含的列，查询时只针对这里指定的列进行比较。 a LEFT JOIN b USING (c1, c2, c3) NATURAL [LEFT] JOIN 与 INNER JOIN 和 LEFT JOIN 配合使用了 USING 指定表中所有列的情况等效。 RIGHT JOIN 与 LEFT JOIN 类似，只是最终结果是依据右边表，将左边表中不符合的在结果中以 NULL 呈现。为了方便在不同数据库间迁移，推荐始终使用 LEFT JOIN。 一些 JOIN 示例： SELECT * FROM table1, table2; SELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id; SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id; SELECT * FROM table1 LEFT JOIN table2 USING (id); SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id LEFT JOIN table3 ON table2.id = table3.id; NATURAL JOIN 的结果中不会有重复的列。因为其与 USING 雷同，所以 USING 时也没有复杂的列。 考察下面的示例： CREATE TABLE t1 (i INT, j INT); CREATE TABLE t2 (k INT, j INT); INSERT INTO t1 VALUES(1, 1); INSERT INTO t2 VALUES(1, 1); SELECT * FROM t1 NATURAL JOIN t2; SELECT * FROM t1 JOIN t2 USING (j); 查询结果： +------+------+------+ | j | i | k | +------+------+------+ | 1 | 1 | 1 | +------+------+------+ +------+------+------+ | j | i | k | +------+------+------+ | 1 | 1 | 1 | +------+------+------+ 结果中同名的列只出现一次，且都是值相同的那些记录。 通过向两表中插入一条新记录，令它们的 j 不相同，再进行测试。 mysql&gt; INSERT INTO t1 VALUES(2, 2); Query OK, 1 row affected (0.00 sec) mysql&gt; INSERT INTO t2 VALUES(2, 3); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from t1 natural join t2; +------+------+------+ | j | i | k | +------+------+------+ | 2 | 2 | 1 | +------+------+------+ 1 row in set (0.00 sec) USING 和 ON 作为条件时其他限制的联合条件是一样的，可互相转换。但在 SELECT * 返回结果时，还是有差异的。前者只在 USING 中指定的列中返回合并后的结果，后者则针对的是表中所有列。 a LEFT JOIN b USING (c1, c2, c3) a LEFT JOIN b ON a.c1 = b.c1 AND a.c2 = b.c2 AND a.c3 = b.c3 USING 情况下的返回： COALESCE(a.c1, b.c1), COALESCE(a.c2, b.c2), COALESCE(a.c3, b.c3) ON 的返回： a.c1, a.c2, a.c3, b.c1, b.c2, b.c3 ON 语句中只能引用其操作表（operands）中的表。 CREATE TABLE t1 (i1 INT); CREATE TABLE t2 (i2 INT); CREATE TABLE t3 (i3 INT); 针对上面的表，以下查询会报错： mysql&gt; SELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3; ERROR 1054 (42S22): Unknown column &#39;i3&#39; in &#39;on clause&#39; 而以下查询则可以： mysql&gt; SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3); Empty set (0.00 sec) 因为此时 t3 在 ON 语句的操作范围内了。 相关资源 MySQL 8.0 Reference Manual - 13.2.10.2 JOIN Syntax MySQL 8.0 Reference Manual - 13.2.10.3 UNION Syntax" />
<link rel="canonical" href="http://localhost:4000/2019/05/14/MySQL-%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2.html" />
<meta property="og:url" content="http://localhost:4000/2019/05/14/MySQL-%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-14T00:05:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/05/14/MySQL-%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/05/14/MySQL-%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2.html"},"description":"MySQL 联表查询 关系型数据库，免不了表之间存在各种引用与关联。这些关联是通过主键与外键搭配来形成的。所以，取数据时，很大情况下单张表无法满足需求，额外的数据则需要将其他表加入到查询中来，这便是 JOIN 关键字完成的操作。 MySQL 中 JOIN, CROSS JOIN 和 INNER JOIN 三者语法功能上相同，可互换，而 SQL 标准中，INNER JOIN 需要搭配 ON 语句。 多表联合查询时，可省略 JOIN 关键字，以逗号分隔多张表，此时默认会当作 INNER JOIN 来处理。比如, SELECT table1.*, table2.* FROM table1, table2; 等效于： SELECT table1.*, table2.* FROM table1 INNER JOIN table2; 但这种通过逗号隐式指定的联表形式其优先级要低于直接通过关键字（INNER JOIN, CROSS JOIN, LEFT JOIN）指定的形式。所以 t1, t2 JOIN t3 会被解析成 (t1, (t2 JOIN t3)) 而不是 ((t1, t2) JOIN t3) 需要注意的是，当逗号形式与其他联表关键词结合时，在指定了联表条件，比如通过 ON 条件时，会报错。 ON 指定的联表条件其语法同 WHERE，所有后者可接受的表达式都可用于 ON。两者看起来功能上雷同，ON 一般用于指定联表条件，即表之间怎么被联合，而 WHERE 则用于过滤结果。 LEFT JOIN 时，右边表中不满足 ON 或 USING 指定的条件时，会在结果中以 NULL 呈现。 SELECT left_tbl.* FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id = right_tbl.id WHERE right_tbl.id IS NULL; 通过此方法可方便地过滤出右边表中不符合条件的记录。 联表查询时可为每张参与进来的表指定别名，方便在其他表达式中引用。两种方式，一个是通过 AS 关键字 tbl_name AS alias_name，另一种是直接在表名后面跟上别名，tbl_name alias_name。 SELECT t1.name, t2.salary FROM employee AS t1 INNER JOIN info AS t2 ON t1.name = t2.name; SELECT t1.name, t2.salary FROM employee t1 INNER JOIN info t2 ON t1.name = t2.name; 一条查询语句中的子查询必需取一个别名，这样才能在其他表达式中引用。 SELECT * FROM (SELECT 1, 2, 3) AS t1; USING(join_column_list) 语句指定两个表中均包含的列，查询时只针对这里指定的列进行比较。 a LEFT JOIN b USING (c1, c2, c3) NATURAL [LEFT] JOIN 与 INNER JOIN 和 LEFT JOIN 配合使用了 USING 指定表中所有列的情况等效。 RIGHT JOIN 与 LEFT JOIN 类似，只是最终结果是依据右边表，将左边表中不符合的在结果中以 NULL 呈现。为了方便在不同数据库间迁移，推荐始终使用 LEFT JOIN。 一些 JOIN 示例： SELECT * FROM table1, table2; SELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id; SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id; SELECT * FROM table1 LEFT JOIN table2 USING (id); SELECT * FROM table1 LEFT JOIN table2 ON table1.id = table2.id LEFT JOIN table3 ON table2.id = table3.id; NATURAL JOIN 的结果中不会有重复的列。因为其与 USING 雷同，所以 USING 时也没有复杂的列。 考察下面的示例： CREATE TABLE t1 (i INT, j INT); CREATE TABLE t2 (k INT, j INT); INSERT INTO t1 VALUES(1, 1); INSERT INTO t2 VALUES(1, 1); SELECT * FROM t1 NATURAL JOIN t2; SELECT * FROM t1 JOIN t2 USING (j); 查询结果： +------+------+------+ | j | i | k | +------+------+------+ | 1 | 1 | 1 | +------+------+------+ +------+------+------+ | j | i | k | +------+------+------+ | 1 | 1 | 1 | +------+------+------+ 结果中同名的列只出现一次，且都是值相同的那些记录。 通过向两表中插入一条新记录，令它们的 j 不相同，再进行测试。 mysql&gt; INSERT INTO t1 VALUES(2, 2); Query OK, 1 row affected (0.00 sec) mysql&gt; INSERT INTO t2 VALUES(2, 3); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from t1 natural join t2; +------+------+------+ | j | i | k | +------+------+------+ | 2 | 2 | 1 | +------+------+------+ 1 row in set (0.00 sec) USING 和 ON 作为条件时其他限制的联合条件是一样的，可互相转换。但在 SELECT * 返回结果时，还是有差异的。前者只在 USING 中指定的列中返回合并后的结果，后者则针对的是表中所有列。 a LEFT JOIN b USING (c1, c2, c3) a LEFT JOIN b ON a.c1 = b.c1 AND a.c2 = b.c2 AND a.c3 = b.c3 USING 情况下的返回： COALESCE(a.c1, b.c1), COALESCE(a.c2, b.c2), COALESCE(a.c3, b.c3) ON 的返回： a.c1, a.c2, a.c3, b.c1, b.c2, b.c3 ON 语句中只能引用其操作表（operands）中的表。 CREATE TABLE t1 (i1 INT); CREATE TABLE t2 (i2 INT); CREATE TABLE t3 (i3 INT); 针对上面的表，以下查询会报错： mysql&gt; SELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3; ERROR 1054 (42S22): Unknown column &#39;i3&#39; in &#39;on clause&#39; 而以下查询则可以： mysql&gt; SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3); Empty set (0.00 sec) 因为此时 t3 在 ON 语句的操作范围内了。 相关资源 MySQL 8.0 Reference Manual - 13.2.10.2 JOIN Syntax MySQL 8.0 Reference Manual - 13.2.10.3 UNION Syntax","@type":"BlogPosting","headline":"MySQL 联表查询","dateModified":"2019-05-14T00:05:00+08:00","datePublished":"2019-05-14T00:05:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">MySQL 联表查询</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-05-14T00:05:00+08:00" itemprop="datePublished">May 14, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="mysql-联表查询">MySQL 联表查询</h1>

<p>关系型数据库，免不了表之间存在各种引用与关联。这些关联是通过主键与外键搭配来形成的。所以，取数据时，很大情况下单张表无法满足需求，额外的数据则需要将其他表加入到查询中来，这便是 <code class="language-plaintext highlighter-rouge">JOIN</code> 关键字完成的操作。</p>

<ul>
  <li>MySQL 中 <code class="language-plaintext highlighter-rouge">JOIN</code>, <code class="language-plaintext highlighter-rouge">CROSS JOIN</code> 和 <code class="language-plaintext highlighter-rouge">INNER JOIN</code> 三者语法功能上相同，可互换，而 SQL 标准中，<code class="language-plaintext highlighter-rouge">INNER JOIN</code> 需要搭配 <code class="language-plaintext highlighter-rouge">ON</code> 语句。</li>
</ul>

<p>多表联合查询时，可省略 JOIN 关键字，以逗号分隔多张表，此时默认会当作 INNER JOIN 来处理。比如,</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">table1</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> 
       <span class="n">table2</span><span class="p">.</span><span class="o">*</span> 
<span class="k">FROM</span>   <span class="n">table1</span><span class="p">,</span> 
       <span class="n">table2</span><span class="p">;</span> 
</code></pre></div></div>

<p>等效于：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">table1</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> 
       <span class="n">table2</span><span class="p">.</span><span class="o">*</span> 
<span class="k">FROM</span>   <span class="n">table1</span> 
       <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">table2</span><span class="p">;</span> 
</code></pre></div></div>

<ul>
  <li>但这种通过逗号隐式指定的联表形式其优先级要低于直接通过关键字（<code class="language-plaintext highlighter-rouge">INNER JOIN</code>, <code class="language-plaintext highlighter-rouge">CROSS JOIN</code>, <code class="language-plaintext highlighter-rouge">LEFT JOIN</code>）指定的形式。所以 <code class="language-plaintext highlighter-rouge">t1, t2 JOIN t3</code> 会被解析成 <code class="language-plaintext highlighter-rouge">(t1, (t2 JOIN t3))</code> 而不是 <code class="language-plaintext highlighter-rouge">((t1, t2) JOIN t3)</code></li>
</ul>

<p>需要注意的是，当逗号形式与其他联表关键词结合时，在指定了联表条件，比如通过 <code class="language-plaintext highlighter-rouge">ON</code> 条件时，会报错。</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ON</code> 指定的联表条件其语法同 <code class="language-plaintext highlighter-rouge">WHERE</code>，所有后者可接受的表达式都可用于 <code class="language-plaintext highlighter-rouge">ON</code>。两者看起来功能上雷同，<code class="language-plaintext highlighter-rouge">ON</code> 一般用于指定联表条件，即表之间怎么被联合，而 <code class="language-plaintext highlighter-rouge">WHERE</code> 则用于过滤结果。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">LEFT JOIN</code> 时，右边表中不满足 <code class="language-plaintext highlighter-rouge">ON</code> 或 <code class="language-plaintext highlighter-rouge">USING</code> 指定的条件时，会在结果中以 <code class="language-plaintext highlighter-rouge">NULL</code> 呈现。</p>
  </li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">left_tbl</span><span class="p">.</span><span class="o">*</span>
  <span class="k">FROM</span> <span class="n">left_tbl</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">right_tbl</span> <span class="k">ON</span> <span class="n">left_tbl</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">right_tbl</span><span class="p">.</span><span class="n">id</span>
  <span class="k">WHERE</span> <span class="n">right_tbl</span><span class="p">.</span><span class="n">id</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</code></pre></div></div>

<p>通过此方法可方便地过滤出右边表中不符合条件的记录。</p>

<ul>
  <li>联表查询时可为每张参与进来的表指定别名，方便在其他表达式中引用。两种方式，一个是通过 <code class="language-plaintext highlighter-rouge">AS</code> 关键字 <code class="language-plaintext highlighter-rouge">tbl_name AS alias_name</code>，另一种是直接在表名后面跟上别名，<code class="language-plaintext highlighter-rouge">tbl_name alias_name</code>。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">t1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">salary</span>
  <span class="k">FROM</span> <span class="n">employee</span> <span class="k">AS</span> <span class="n">t1</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">info</span> <span class="k">AS</span> <span class="n">t2</span> <span class="k">ON</span> <span class="n">t1</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="n">t1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">salary</span>
  <span class="k">FROM</span> <span class="n">employee</span> <span class="n">t1</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">info</span> <span class="n">t2</span> <span class="k">ON</span> <span class="n">t1</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</code></pre></div></div>

<p>一条查询语句中的子查询必需取一个别名，这样才能在其他表达式中引用。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">AS</span> <span class="n">t1</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">USING(join_column_list)</code> 语句指定两个表中均包含的列，查询时只针对这里指定的列进行比较。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">b</span> <span class="k">USING</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge"> NATURAL [LEFT] JOIN</code> 与 <code class="language-plaintext highlighter-rouge">INNER JOIN</code> 和 <code class="language-plaintext highlighter-rouge">LEFT JOIN</code> 配合使用了 <code class="language-plaintext highlighter-rouge">USING</code> 指定表中所有列的情况等效。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">RIGHT JOIN</code> 与 <code class="language-plaintext highlighter-rouge">LEFT JOIN</code> 类似，只是最终结果是依据右边表，将左边表中不符合的在结果中以 NULL 呈现。为了方便在不同数据库间迁移，推荐始终使用 <code class="language-plaintext highlighter-rouge">LEFT JOIN</code>。</p>
  </li>
</ul>

<p>一些 <code class="language-plaintext highlighter-rouge">JOIN</code> 示例：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">table1</span><span class="p">,</span> <span class="n">table2</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">table1</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">table2</span> <span class="k">ON</span> <span class="n">table1</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">table2</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">table1</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">table2</span> <span class="k">ON</span> <span class="n">table1</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">table2</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">table1</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">table2</span> <span class="k">USING</span> <span class="p">(</span><span class="n">id</span><span class="p">);</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">table1</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">table2</span> <span class="k">ON</span> <span class="n">table1</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">table2</span><span class="p">.</span><span class="n">id</span>
  <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">table3</span> <span class="k">ON</span> <span class="n">table2</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">table3</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">NATURAL JOIN</code> 的结果中不会有重复的列。因为其与 <code class="language-plaintext highlighter-rouge">USING</code> 雷同，所以 <code class="language-plaintext highlighter-rouge">USING</code> 时也没有复杂的列。</li>
</ul>

<p>考察下面的示例：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="p">(</span><span class="n">i</span> <span class="nb">INT</span><span class="p">,</span> <span class="n">j</span> <span class="nb">INT</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t2</span> <span class="p">(</span><span class="n">k</span> <span class="nb">INT</span><span class="p">,</span> <span class="n">j</span> <span class="nb">INT</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t1</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t2</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">NATURAL</span> <span class="k">JOIN</span> <span class="n">t2</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">JOIN</span> <span class="n">t2</span> <span class="k">USING</span> <span class="p">(</span><span class="n">j</span><span class="p">);</span>
</code></pre></div></div>

<p>查询结果：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+------+------+------+
| j    | i    | k    |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
+------+------+------+
| j    | i    | k    |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
</code></pre></div></div>

<p>结果中同名的列只出现一次，且都是值相同的那些记录。</p>

<p>通过向两表中插入一条新记录，令它们的 <code class="language-plaintext highlighter-rouge">j</code> 不相同，再进行测试。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t1</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">t2</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">1</span> <span class="k">row</span> <span class="n">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t1</span> <span class="k">natural</span> <span class="k">join</span> <span class="n">t2</span><span class="p">;</span>
<span class="o">+</span><span class="c1">------+------+------+</span>
<span class="o">|</span> <span class="n">j</span>    <span class="o">|</span> <span class="n">i</span>    <span class="o">|</span> <span class="n">k</span>    <span class="o">|</span>
<span class="o">+</span><span class="c1">------+------+------+</span>
<span class="o">|</span>    <span class="mi">2</span> <span class="o">|</span>    <span class="mi">2</span> <span class="o">|</span>    <span class="mi">1</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">------+------+------+</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">USING</code> 和 <code class="language-plaintext highlighter-rouge">ON</code> 作为条件时其他限制的联合条件是一样的，可互相转换。但在 <code class="language-plaintext highlighter-rouge">SELECT *</code> 返回结果时，还是有差异的。前者只在 <code class="language-plaintext highlighter-rouge">USING</code> 中指定的列中返回合并后的结果，后者则针对的是表中所有列。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">b</span> <span class="k">USING</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">)</span>
<span class="n">a</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">b</span> <span class="k">ON</span> <span class="n">a</span><span class="p">.</span><span class="n">c1</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">c1</span> <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">c2</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">c2</span> <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">c3</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">c3</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">USING</code> 情况下的返回：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">COALESCE</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">c1</span><span class="p">),</span> <span class="n">COALESCE</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">c2</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">c2</span><span class="p">),</span> <span class="n">COALESCE</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">c3</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">c3</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ON</code> 的返回：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">c2</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">c3</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">c2</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">c3</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ON</code> 语句中只能引用其操作表（operands）中的表。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="p">(</span><span class="n">i1</span> <span class="nb">INT</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t2</span> <span class="p">(</span><span class="n">i2</span> <span class="nb">INT</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t3</span> <span class="p">(</span><span class="n">i3</span> <span class="nb">INT</span><span class="p">);</span>
</code></pre></div></div>

<p>针对上面的表，以下查询会报错：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; SELECT <span class="k">*</span> FROM t1 JOIN t2 ON <span class="o">(</span>i1 <span class="o">=</span> i3<span class="o">)</span> JOIN t3<span class="p">;</span>
ERROR 1054 <span class="o">(</span>42S22<span class="o">)</span>: Unknown column <span class="s1">'i3'</span> <span class="k">in</span> <span class="s1">'on clause'</span>
</code></pre></div></div>

<p>而以下查询则可以：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql&gt; SELECT <span class="k">*</span> FROM t1 JOIN t2 JOIN t3 ON <span class="o">(</span>i1 <span class="o">=</span> i3<span class="o">)</span><span class="p">;</span>
Empty <span class="nb">set</span> <span class="o">(</span>0.00 sec<span class="o">)</span>
</code></pre></div></div>

<p>因为此时 <code class="language-plaintext highlighter-rouge">t3</code> 在 <code class="language-plaintext highlighter-rouge">ON</code> 语句的操作范围内了。</p>

<h2 id="相关资源">相关资源</h2>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/join.html">MySQL 8.0 Reference Manual - 13.2.10.2 JOIN Syntax</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/union.html">MySQL 8.0 Reference Manual - 13.2.10.3 UNION Syntax</a></li>
</ul>


  </div><a class="u-url" href="/2019/05/14/MySQL-%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
