<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>WebAssembly 上手 | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="WebAssembly 上手" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="WebAssembly 上手 安装 Mac 上最便捷的安装方式当然是通过 Homebrew: $ brew install emscripten 安装好之后讲道理就已经自动配置好一切，然后 emcc 命令便可用了。 下面看非 Homebrew 安装的方式。 通过官方 WebAssembly - Developer’s Guide 提供的安装配置步骤进行环境相关设置。这里以 macOS 为例。 下载工具链 通过 clone emscripten 仓库到本地进行工具链（toolchain）的下载安装。 $ git clone https://github.com/emscripten-core/emsdk.git $ cd emsdk 安装及配置 执行安装： $ ./emsdk install latest 激活工具链，生成相应环境配置： $ ./emsdk activate latest `./emsdk activate latest` 命令的输出 ``` $ ./emsdk activate latest Writing .emscripten configuration file to user home directory /Users/wayou/ The Emscripten configuration file /Users/wayou/.emscripten has been rewritten with the following contents: import os LLVM_ROOT = &#39;/Users/wayou/dev/emsdk/fastcomp/fastcomp/bin&#39; BINARYEN_ROOT = &#39;/Users/wayou/dev/emsdk/fastcomp&#39; NODE_JS = &#39;/Users/wayou/dev/emsdk/node/8.9.1_64bit/bin/node&#39; SPIDERMONKEY_ENGINE = &#39;&#39; V8_ENGINE = &#39;&#39; TEMP_DIR = &#39;/var/folders/qr/dlqjq3zj10xgf2xfx3mybn500000gn/T&#39; COMPILER_ENGINE = NODE_JS JS_ENGINES = [NODE_JS] To conveniently access the selected set of tools from the command line, consider adding the following directories to PATH, or call &#39;source ./emsdk_env.sh&#39; to do this for you. /Users/wayou/dev/emsdk:/Users/wayou/dev/emsdk/fastcomp/emscripten:/Users/wayou/dev/emsdk/node/8.9.1_64bit/bin Set the following tools as active: releases-fastcomp-3b8cff670e9233a6623563add831647e8689a86b-64bit node-8.9.1-64bit ``` 小贴士：其中 install 过程会从 https://chromium.googlesource.com，https://storage.googleapis.com 及 https://s3.amazonaws.com 域下载东西，所以最好在命令行配置科学上网，否则安装会失败。 环境变量 通过执行以下命令添加相应命令及目录到环境变量以方便调用： $ source ./emsdk_env.sh --build=Release 如果进行到这一步发生如下错误： $ source ./emsdk_env.sh --build=Release ./emsdk_env.sh (line 19): Missing end to balance this if statement if [ &quot;$SRC&quot; = &quot;&quot; ]; then ^ from sourcing file ./emsdk_env.sh called on standard input source: Error while reading file &#39;./emsdk_env.sh&#39; 这多半是因为你用的 shell 是 fish 语法不兼容的原因。 两个解决办法： 可通过来自emscripten-core/emsdk issue#111 中提供的方法，执行下面的命令来绕开： $ bash ./emsdk_env.sh 因为其也提供了对应的 .fish 脚本，所以，也可以直接选择运行该 fish 脚本来解决上面语法报错的问题： $ source ./emsdk_env.fish 执行成功的输出： $ source ./emsdk_env.fish Adding directories to PATH: PATH += /Users/wayou/dev/emsdk Setting environment variables: EMSDK = /Users/wayou/dev/emsdk EM_CONFIG = /Users/wayou/.emscripten 检查安装 完成上面步骤后，可通过运行 emcc --version 命令查看是否安装成功： $ emcc --version `emcc --version` 命令的输出 ```sh $ emcc --version cache:INFO: generating system asset: is_vanilla.txt... (this will be cached in &quot;/Users/wayou/.emscripten_cache/is_vanilla.txt&quot; for subsequent builds) cache:INFO: - ok emcc (Emscripten gcc/clang-like replacement) 1.38.33 (commit 0490c5f7aaf0e61aafd3b4cfe22cc56b803026b1) Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt) This is free and open source software under the MIT license. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ``` 如果执行 emcc 时报如下错误： $ emcc --version emscripten requires python 2.7.12 or above 大概率是 macOS 自带的是老版本的 Python2，而 emcc 需要 Python3。解决办法有很多，这里说一个。 尝试过在命令的配置文件中添加 alias 配置 aliast python=python3，是不生效的，但可以将 emcc 命令配置 alias 显式指定使用 python3 来启动。将如下配置添加到相应 shell 的配置文件中，以 fish 为例其配置文件为 ~/.config/fish/config.fish: alias emcc=&quot;python3 /Users/wayou/Documents/dev/github/emsdk/fastcomp/emscripten/emcc&quot; alias em++=&quot;python3 /Users/wayou/Documents/dev/github/emsdk/fastcomp/emscripten/em++&quot; alias emrun=&quot;python3 /Users/wayou/Documents/dev/github/emsdk/fastcomp/emscripten/emrun&quot; 根据官方文档的描述： use em++ to force compilation as C++ --Emscripten Tutorial em++ 用于编译 c++ 代码，所以这里将 em++ 也添加上了。 这里同时也将 emrun 添加上了别名，方便后面使用它来启动本地服务以调试。 小贴士：新开命令行窗口或重启命令行后，需要重新执行 source 命令，可将其添加到你所使用的命令行的配置文件中，.bash_profile，.zshrc，或 . 以 fish 为例： ~/.config/fish/config.fish.fish source &quot;/Users/wayou/dev/emsdk/emsdk_env.fish&quot;; 这样每次启动命令行后 emcc 都是可用状态。 编译及运行 安装配置完成后，便可以尝试编译并运行一个简单的 demo 程序了。 一些注意点： 运行 emcc 时需要指定 -s WASM=1 参数，否则默认情况下其输出为 asm.js。 除了生成 Wasm 二进制文件及对应的 JavaScript 封装，如果还想要生成一个可直接查看的 HTML 页面，可在输出时指定一个后缀为 .html 的文件。 实际运行时不能直接打开这个生成的 HTML 文件，因为 file:/// 协议不支持跨域，所以需要本地启一个服务器来查看。 编写 Hello World 创建 hello.c 文件并输出以下内容： hello.c #include &lt;stdio.h&gt; int main(int argc, char ** argv) { printf(&quot;Hello, world!\n&quot;); } 编译 执行以下命令进行编译： $ emcc hello.c -s WASM=1 -o hello.html 运行 通过工具链中提供的 smrun 来开启一个本地服务器以查看刚刚生成的程序： $ emrun --no_browser --port 8080 . 当然，使用其他任意 server 也是可以的，比如 Python 的： $ python -m http.server 8080 启动成功后浏览器访问 http://localhost:8080/hello.html。不出意外你会看到页面中 Emscripten 的控制台展示了 Hello, world!。 WebAssembly Hello Wrold 运行效果 但用 emrun 的好处在于它已经处理好了 .wasm 文件的返回类型为 Content-type: application/wasm，而其他 server 可能需要额外的配置，否则默认情况下 .wasm 文件返回到浏览器时其 Content-Type 不对会报错。 调用 C++ 中的方法 下面来看如何在 JavaScript 中调用 C++ 定义的方法。 默认情况下，Emscripten 编译后的代码只包含 main 方法相关的调用，其他无关的代码将会在编译时去掉。可通过在方法名前加 EMSCRIPTEN_KEEPALIVE 来防止需要导出的方法被去掉。 将以下代码放入 hello.c 并保存。 #include &lt;stdio.h&gt; #include &lt;emscripten/emscripten.h&gt; int main(int argc, char ** argv) { printf(&quot;Hello World\n&quot;); } #ifdef __cplusplus extern &quot;C&quot; { #endif void EMSCRIPTEN_KEEPALIVE myFunction(int argc, char ** argv) { printf(&quot;MyFunction Called\n&quot;); } #ifdef __cplusplus } #endif 此时编译需要加上 NO_EXIT_RUNTIME 参数，否则默认情况下 C++ 模块中 main 方法返回后程序就结束了。 执行以下命令编译代码： $ emcc -o hello3.html hello3.c -O3 -s WASM=1 -s NO_EXIT_RUNTIME=1 -s &quot;EXTRA_EXPORTED_RUNTIME_METHODS=[&#39;ccall&#39;]&quot; 打开在发生的 hello.html，在第一个 &lt;script&gt; 标签开始前加上一个按钮： &lt;button class=&quot;mybutton&quot;&gt;Run myFunction&lt;/button&gt; 添加以下点击调用逻辑到第一个 &lt;script&gt; 代码块的末尾： document.querySelector(&quot;.mybutton&quot;).addEventListener(&quot;click&quot;, function() { alert(&quot;check console&quot;); var result = Module.ccall( &quot;myFunction&quot;, // name of C function null, // return type null, // argument types null // arguments ); }); 再次启动服务器运行后，点击页面中按钮在控制台观察输出。 JavaScript 中调用 C++ 方法的示例 相关资源 WebAssembly - Developer’s Guide Compiling a New C/C++ Module to WebAssembly" />
<meta property="og:description" content="WebAssembly 上手 安装 Mac 上最便捷的安装方式当然是通过 Homebrew: $ brew install emscripten 安装好之后讲道理就已经自动配置好一切，然后 emcc 命令便可用了。 下面看非 Homebrew 安装的方式。 通过官方 WebAssembly - Developer’s Guide 提供的安装配置步骤进行环境相关设置。这里以 macOS 为例。 下载工具链 通过 clone emscripten 仓库到本地进行工具链（toolchain）的下载安装。 $ git clone https://github.com/emscripten-core/emsdk.git $ cd emsdk 安装及配置 执行安装： $ ./emsdk install latest 激活工具链，生成相应环境配置： $ ./emsdk activate latest `./emsdk activate latest` 命令的输出 ``` $ ./emsdk activate latest Writing .emscripten configuration file to user home directory /Users/wayou/ The Emscripten configuration file /Users/wayou/.emscripten has been rewritten with the following contents: import os LLVM_ROOT = &#39;/Users/wayou/dev/emsdk/fastcomp/fastcomp/bin&#39; BINARYEN_ROOT = &#39;/Users/wayou/dev/emsdk/fastcomp&#39; NODE_JS = &#39;/Users/wayou/dev/emsdk/node/8.9.1_64bit/bin/node&#39; SPIDERMONKEY_ENGINE = &#39;&#39; V8_ENGINE = &#39;&#39; TEMP_DIR = &#39;/var/folders/qr/dlqjq3zj10xgf2xfx3mybn500000gn/T&#39; COMPILER_ENGINE = NODE_JS JS_ENGINES = [NODE_JS] To conveniently access the selected set of tools from the command line, consider adding the following directories to PATH, or call &#39;source ./emsdk_env.sh&#39; to do this for you. /Users/wayou/dev/emsdk:/Users/wayou/dev/emsdk/fastcomp/emscripten:/Users/wayou/dev/emsdk/node/8.9.1_64bit/bin Set the following tools as active: releases-fastcomp-3b8cff670e9233a6623563add831647e8689a86b-64bit node-8.9.1-64bit ``` 小贴士：其中 install 过程会从 https://chromium.googlesource.com，https://storage.googleapis.com 及 https://s3.amazonaws.com 域下载东西，所以最好在命令行配置科学上网，否则安装会失败。 环境变量 通过执行以下命令添加相应命令及目录到环境变量以方便调用： $ source ./emsdk_env.sh --build=Release 如果进行到这一步发生如下错误： $ source ./emsdk_env.sh --build=Release ./emsdk_env.sh (line 19): Missing end to balance this if statement if [ &quot;$SRC&quot; = &quot;&quot; ]; then ^ from sourcing file ./emsdk_env.sh called on standard input source: Error while reading file &#39;./emsdk_env.sh&#39; 这多半是因为你用的 shell 是 fish 语法不兼容的原因。 两个解决办法： 可通过来自emscripten-core/emsdk issue#111 中提供的方法，执行下面的命令来绕开： $ bash ./emsdk_env.sh 因为其也提供了对应的 .fish 脚本，所以，也可以直接选择运行该 fish 脚本来解决上面语法报错的问题： $ source ./emsdk_env.fish 执行成功的输出： $ source ./emsdk_env.fish Adding directories to PATH: PATH += /Users/wayou/dev/emsdk Setting environment variables: EMSDK = /Users/wayou/dev/emsdk EM_CONFIG = /Users/wayou/.emscripten 检查安装 完成上面步骤后，可通过运行 emcc --version 命令查看是否安装成功： $ emcc --version `emcc --version` 命令的输出 ```sh $ emcc --version cache:INFO: generating system asset: is_vanilla.txt... (this will be cached in &quot;/Users/wayou/.emscripten_cache/is_vanilla.txt&quot; for subsequent builds) cache:INFO: - ok emcc (Emscripten gcc/clang-like replacement) 1.38.33 (commit 0490c5f7aaf0e61aafd3b4cfe22cc56b803026b1) Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt) This is free and open source software under the MIT license. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ``` 如果执行 emcc 时报如下错误： $ emcc --version emscripten requires python 2.7.12 or above 大概率是 macOS 自带的是老版本的 Python2，而 emcc 需要 Python3。解决办法有很多，这里说一个。 尝试过在命令的配置文件中添加 alias 配置 aliast python=python3，是不生效的，但可以将 emcc 命令配置 alias 显式指定使用 python3 来启动。将如下配置添加到相应 shell 的配置文件中，以 fish 为例其配置文件为 ~/.config/fish/config.fish: alias emcc=&quot;python3 /Users/wayou/Documents/dev/github/emsdk/fastcomp/emscripten/emcc&quot; alias em++=&quot;python3 /Users/wayou/Documents/dev/github/emsdk/fastcomp/emscripten/em++&quot; alias emrun=&quot;python3 /Users/wayou/Documents/dev/github/emsdk/fastcomp/emscripten/emrun&quot; 根据官方文档的描述： use em++ to force compilation as C++ --Emscripten Tutorial em++ 用于编译 c++ 代码，所以这里将 em++ 也添加上了。 这里同时也将 emrun 添加上了别名，方便后面使用它来启动本地服务以调试。 小贴士：新开命令行窗口或重启命令行后，需要重新执行 source 命令，可将其添加到你所使用的命令行的配置文件中，.bash_profile，.zshrc，或 . 以 fish 为例： ~/.config/fish/config.fish.fish source &quot;/Users/wayou/dev/emsdk/emsdk_env.fish&quot;; 这样每次启动命令行后 emcc 都是可用状态。 编译及运行 安装配置完成后，便可以尝试编译并运行一个简单的 demo 程序了。 一些注意点： 运行 emcc 时需要指定 -s WASM=1 参数，否则默认情况下其输出为 asm.js。 除了生成 Wasm 二进制文件及对应的 JavaScript 封装，如果还想要生成一个可直接查看的 HTML 页面，可在输出时指定一个后缀为 .html 的文件。 实际运行时不能直接打开这个生成的 HTML 文件，因为 file:/// 协议不支持跨域，所以需要本地启一个服务器来查看。 编写 Hello World 创建 hello.c 文件并输出以下内容： hello.c #include &lt;stdio.h&gt; int main(int argc, char ** argv) { printf(&quot;Hello, world!\n&quot;); } 编译 执行以下命令进行编译： $ emcc hello.c -s WASM=1 -o hello.html 运行 通过工具链中提供的 smrun 来开启一个本地服务器以查看刚刚生成的程序： $ emrun --no_browser --port 8080 . 当然，使用其他任意 server 也是可以的，比如 Python 的： $ python -m http.server 8080 启动成功后浏览器访问 http://localhost:8080/hello.html。不出意外你会看到页面中 Emscripten 的控制台展示了 Hello, world!。 WebAssembly Hello Wrold 运行效果 但用 emrun 的好处在于它已经处理好了 .wasm 文件的返回类型为 Content-type: application/wasm，而其他 server 可能需要额外的配置，否则默认情况下 .wasm 文件返回到浏览器时其 Content-Type 不对会报错。 调用 C++ 中的方法 下面来看如何在 JavaScript 中调用 C++ 定义的方法。 默认情况下，Emscripten 编译后的代码只包含 main 方法相关的调用，其他无关的代码将会在编译时去掉。可通过在方法名前加 EMSCRIPTEN_KEEPALIVE 来防止需要导出的方法被去掉。 将以下代码放入 hello.c 并保存。 #include &lt;stdio.h&gt; #include &lt;emscripten/emscripten.h&gt; int main(int argc, char ** argv) { printf(&quot;Hello World\n&quot;); } #ifdef __cplusplus extern &quot;C&quot; { #endif void EMSCRIPTEN_KEEPALIVE myFunction(int argc, char ** argv) { printf(&quot;MyFunction Called\n&quot;); } #ifdef __cplusplus } #endif 此时编译需要加上 NO_EXIT_RUNTIME 参数，否则默认情况下 C++ 模块中 main 方法返回后程序就结束了。 执行以下命令编译代码： $ emcc -o hello3.html hello3.c -O3 -s WASM=1 -s NO_EXIT_RUNTIME=1 -s &quot;EXTRA_EXPORTED_RUNTIME_METHODS=[&#39;ccall&#39;]&quot; 打开在发生的 hello.html，在第一个 &lt;script&gt; 标签开始前加上一个按钮： &lt;button class=&quot;mybutton&quot;&gt;Run myFunction&lt;/button&gt; 添加以下点击调用逻辑到第一个 &lt;script&gt; 代码块的末尾： document.querySelector(&quot;.mybutton&quot;).addEventListener(&quot;click&quot;, function() { alert(&quot;check console&quot;); var result = Module.ccall( &quot;myFunction&quot;, // name of C function null, // return type null, // argument types null // arguments ); }); 再次启动服务器运行后，点击页面中按钮在控制台观察输出。 JavaScript 中调用 C++ 方法的示例 相关资源 WebAssembly - Developer’s Guide Compiling a New C/C++ Module to WebAssembly" />
<link rel="canonical" href="http://localhost:4000/2019/05/31/WebAssembly-%E4%B8%8A%E6%89%8B.html" />
<meta property="og:url" content="http://localhost:4000/2019/05/31/WebAssembly-%E4%B8%8A%E6%89%8B.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-31T23:05:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/05/31/WebAssembly-%E4%B8%8A%E6%89%8B.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/05/31/WebAssembly-%E4%B8%8A%E6%89%8B.html"},"description":"WebAssembly 上手 安装 Mac 上最便捷的安装方式当然是通过 Homebrew: $ brew install emscripten 安装好之后讲道理就已经自动配置好一切，然后 emcc 命令便可用了。 下面看非 Homebrew 安装的方式。 通过官方 WebAssembly - Developer’s Guide 提供的安装配置步骤进行环境相关设置。这里以 macOS 为例。 下载工具链 通过 clone emscripten 仓库到本地进行工具链（toolchain）的下载安装。 $ git clone https://github.com/emscripten-core/emsdk.git $ cd emsdk 安装及配置 执行安装： $ ./emsdk install latest 激活工具链，生成相应环境配置： $ ./emsdk activate latest `./emsdk activate latest` 命令的输出 ``` $ ./emsdk activate latest Writing .emscripten configuration file to user home directory /Users/wayou/ The Emscripten configuration file /Users/wayou/.emscripten has been rewritten with the following contents: import os LLVM_ROOT = &#39;/Users/wayou/dev/emsdk/fastcomp/fastcomp/bin&#39; BINARYEN_ROOT = &#39;/Users/wayou/dev/emsdk/fastcomp&#39; NODE_JS = &#39;/Users/wayou/dev/emsdk/node/8.9.1_64bit/bin/node&#39; SPIDERMONKEY_ENGINE = &#39;&#39; V8_ENGINE = &#39;&#39; TEMP_DIR = &#39;/var/folders/qr/dlqjq3zj10xgf2xfx3mybn500000gn/T&#39; COMPILER_ENGINE = NODE_JS JS_ENGINES = [NODE_JS] To conveniently access the selected set of tools from the command line, consider adding the following directories to PATH, or call &#39;source ./emsdk_env.sh&#39; to do this for you. /Users/wayou/dev/emsdk:/Users/wayou/dev/emsdk/fastcomp/emscripten:/Users/wayou/dev/emsdk/node/8.9.1_64bit/bin Set the following tools as active: releases-fastcomp-3b8cff670e9233a6623563add831647e8689a86b-64bit node-8.9.1-64bit ``` 小贴士：其中 install 过程会从 https://chromium.googlesource.com，https://storage.googleapis.com 及 https://s3.amazonaws.com 域下载东西，所以最好在命令行配置科学上网，否则安装会失败。 环境变量 通过执行以下命令添加相应命令及目录到环境变量以方便调用： $ source ./emsdk_env.sh --build=Release 如果进行到这一步发生如下错误： $ source ./emsdk_env.sh --build=Release ./emsdk_env.sh (line 19): Missing end to balance this if statement if [ &quot;$SRC&quot; = &quot;&quot; ]; then ^ from sourcing file ./emsdk_env.sh called on standard input source: Error while reading file &#39;./emsdk_env.sh&#39; 这多半是因为你用的 shell 是 fish 语法不兼容的原因。 两个解决办法： 可通过来自emscripten-core/emsdk issue#111 中提供的方法，执行下面的命令来绕开： $ bash ./emsdk_env.sh 因为其也提供了对应的 .fish 脚本，所以，也可以直接选择运行该 fish 脚本来解决上面语法报错的问题： $ source ./emsdk_env.fish 执行成功的输出： $ source ./emsdk_env.fish Adding directories to PATH: PATH += /Users/wayou/dev/emsdk Setting environment variables: EMSDK = /Users/wayou/dev/emsdk EM_CONFIG = /Users/wayou/.emscripten 检查安装 完成上面步骤后，可通过运行 emcc --version 命令查看是否安装成功： $ emcc --version `emcc --version` 命令的输出 ```sh $ emcc --version cache:INFO: generating system asset: is_vanilla.txt... (this will be cached in &quot;/Users/wayou/.emscripten_cache/is_vanilla.txt&quot; for subsequent builds) cache:INFO: - ok emcc (Emscripten gcc/clang-like replacement) 1.38.33 (commit 0490c5f7aaf0e61aafd3b4cfe22cc56b803026b1) Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt) This is free and open source software under the MIT license. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ``` 如果执行 emcc 时报如下错误： $ emcc --version emscripten requires python 2.7.12 or above 大概率是 macOS 自带的是老版本的 Python2，而 emcc 需要 Python3。解决办法有很多，这里说一个。 尝试过在命令的配置文件中添加 alias 配置 aliast python=python3，是不生效的，但可以将 emcc 命令配置 alias 显式指定使用 python3 来启动。将如下配置添加到相应 shell 的配置文件中，以 fish 为例其配置文件为 ~/.config/fish/config.fish: alias emcc=&quot;python3 /Users/wayou/Documents/dev/github/emsdk/fastcomp/emscripten/emcc&quot; alias em++=&quot;python3 /Users/wayou/Documents/dev/github/emsdk/fastcomp/emscripten/em++&quot; alias emrun=&quot;python3 /Users/wayou/Documents/dev/github/emsdk/fastcomp/emscripten/emrun&quot; 根据官方文档的描述： use em++ to force compilation as C++ --Emscripten Tutorial em++ 用于编译 c++ 代码，所以这里将 em++ 也添加上了。 这里同时也将 emrun 添加上了别名，方便后面使用它来启动本地服务以调试。 小贴士：新开命令行窗口或重启命令行后，需要重新执行 source 命令，可将其添加到你所使用的命令行的配置文件中，.bash_profile，.zshrc，或 . 以 fish 为例： ~/.config/fish/config.fish.fish source &quot;/Users/wayou/dev/emsdk/emsdk_env.fish&quot;; 这样每次启动命令行后 emcc 都是可用状态。 编译及运行 安装配置完成后，便可以尝试编译并运行一个简单的 demo 程序了。 一些注意点： 运行 emcc 时需要指定 -s WASM=1 参数，否则默认情况下其输出为 asm.js。 除了生成 Wasm 二进制文件及对应的 JavaScript 封装，如果还想要生成一个可直接查看的 HTML 页面，可在输出时指定一个后缀为 .html 的文件。 实际运行时不能直接打开这个生成的 HTML 文件，因为 file:/// 协议不支持跨域，所以需要本地启一个服务器来查看。 编写 Hello World 创建 hello.c 文件并输出以下内容： hello.c #include &lt;stdio.h&gt; int main(int argc, char ** argv) { printf(&quot;Hello, world!\\n&quot;); } 编译 执行以下命令进行编译： $ emcc hello.c -s WASM=1 -o hello.html 运行 通过工具链中提供的 smrun 来开启一个本地服务器以查看刚刚生成的程序： $ emrun --no_browser --port 8080 . 当然，使用其他任意 server 也是可以的，比如 Python 的： $ python -m http.server 8080 启动成功后浏览器访问 http://localhost:8080/hello.html。不出意外你会看到页面中 Emscripten 的控制台展示了 Hello, world!。 WebAssembly Hello Wrold 运行效果 但用 emrun 的好处在于它已经处理好了 .wasm 文件的返回类型为 Content-type: application/wasm，而其他 server 可能需要额外的配置，否则默认情况下 .wasm 文件返回到浏览器时其 Content-Type 不对会报错。 调用 C++ 中的方法 下面来看如何在 JavaScript 中调用 C++ 定义的方法。 默认情况下，Emscripten 编译后的代码只包含 main 方法相关的调用，其他无关的代码将会在编译时去掉。可通过在方法名前加 EMSCRIPTEN_KEEPALIVE 来防止需要导出的方法被去掉。 将以下代码放入 hello.c 并保存。 #include &lt;stdio.h&gt; #include &lt;emscripten/emscripten.h&gt; int main(int argc, char ** argv) { printf(&quot;Hello World\\n&quot;); } #ifdef __cplusplus extern &quot;C&quot; { #endif void EMSCRIPTEN_KEEPALIVE myFunction(int argc, char ** argv) { printf(&quot;MyFunction Called\\n&quot;); } #ifdef __cplusplus } #endif 此时编译需要加上 NO_EXIT_RUNTIME 参数，否则默认情况下 C++ 模块中 main 方法返回后程序就结束了。 执行以下命令编译代码： $ emcc -o hello3.html hello3.c -O3 -s WASM=1 -s NO_EXIT_RUNTIME=1 -s &quot;EXTRA_EXPORTED_RUNTIME_METHODS=[&#39;ccall&#39;]&quot; 打开在发生的 hello.html，在第一个 &lt;script&gt; 标签开始前加上一个按钮： &lt;button class=&quot;mybutton&quot;&gt;Run myFunction&lt;/button&gt; 添加以下点击调用逻辑到第一个 &lt;script&gt; 代码块的末尾： document.querySelector(&quot;.mybutton&quot;).addEventListener(&quot;click&quot;, function() { alert(&quot;check console&quot;); var result = Module.ccall( &quot;myFunction&quot;, // name of C function null, // return type null, // argument types null // arguments ); }); 再次启动服务器运行后，点击页面中按钮在控制台观察输出。 JavaScript 中调用 C++ 方法的示例 相关资源 WebAssembly - Developer’s Guide Compiling a New C/C++ Module to WebAssembly","@type":"BlogPosting","headline":"WebAssembly 上手","dateModified":"2019-05-31T23:05:00+08:00","datePublished":"2019-05-31T23:05:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">WebAssembly 上手</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-05-31T23:05:00+08:00" itemprop="datePublished">May 31, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="webassembly-上手">WebAssembly 上手</h1>

<h2 id="安装">安装</h2>

<p>Mac 上最便捷的安装方式当然是通过 Homebrew:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>brew <span class="nb">install </span>emscripten
</code></pre></div></div>

<p>安装好之后讲道理就已经自动配置好一切，然后 <code class="language-plaintext highlighter-rouge">emcc</code> 命令便可用了。</p>

<p>下面看非 Homebrew 安装的方式。</p>

<p>通过官方 <a href="https://webassembly.org/getting-started/developers-guide/">WebAssembly - Developer’s Guide</a> 提供的安装配置步骤进行环境相关设置。这里以 macOS 为例。</p>

<h3 id="下载工具链">下载工具链</h3>

<p>通过 clone emscripten 仓库到本地进行工具链（toolchain）的下载安装。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/emscripten-core/emsdk.git
<span class="nv">$ </span><span class="nb">cd </span>emsdk
</code></pre></div></div>

<h3 id="安装及配置">安装及配置</h3>

<p>执行安装：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./emsdk install latest
</code></pre></div></div>

<p>激活工具链，生成相应环境配置：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./emsdk activate latest
</code></pre></div></div>

<details>
<summary>
`./emsdk activate latest` 命令的输出
</summary>

```
$ ./emsdk activate latest
Writing .emscripten configuration file to user home directory /Users/wayou/
The Emscripten configuration file /Users/wayou/.emscripten has been rewritten with the following contents:

import os
LLVM_ROOT = '/Users/wayou/dev/emsdk/fastcomp/fastcomp/bin'
BINARYEN_ROOT = '/Users/wayou/dev/emsdk/fastcomp'
NODE_JS = '/Users/wayou/dev/emsdk/node/8.9.1_64bit/bin/node'
SPIDERMONKEY_ENGINE = ''
V8_ENGINE = ''
TEMP_DIR = '/var/folders/qr/dlqjq3zj10xgf2xfx3mybn500000gn/T'
COMPILER_ENGINE = NODE_JS
JS_ENGINES = [NODE_JS]

To conveniently access the selected set of tools from the command line, consider adding the following directories to PATH, or call 'source ./emsdk_env.sh' to do this for you.

   /Users/wayou/dev/emsdk:/Users/wayou/dev/emsdk/fastcomp/emscripten:/Users/wayou/dev/emsdk/node/8.9.1_64bit/bin
Set the following tools as active:
   releases-fastcomp-3b8cff670e9233a6623563add831647e8689a86b-64bit
   node-8.9.1-64bit
```

</details>

<p><strong>小贴士</strong>：其中 install 过程会从 <code class="language-plaintext highlighter-rouge">https://chromium.googlesource.com</code>，<code class="language-plaintext highlighter-rouge">https://storage.googleapis.com</code> 及 <code class="language-plaintext highlighter-rouge">https://s3.amazonaws.com</code> 域下载东西，所以最好在命令行配置科学上网，否则安装会失败。</p>

<h3 id="环境变量">环境变量</h3>

<p>通过执行以下命令添加相应命令及目录到环境变量以方便调用：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">source</span> ./emsdk_env.sh <span class="nt">--build</span><span class="o">=</span>Release
</code></pre></div></div>

<p>如果进行到这一步发生如下错误：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">source</span> ./emsdk_env.sh <span class="nt">--build</span><span class="o">=</span>Release
./emsdk_env.sh <span class="o">(</span>line 19<span class="o">)</span>: Missing end to balance this <span class="k">if </span>statement
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$SRC</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">""</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
^
from sourcing file ./emsdk_env.sh
	called on standard input

<span class="nb">source</span>: Error <span class="k">while </span>reading file <span class="s1">'./emsdk_env.sh'</span>
</code></pre></div></div>

<p>这多半是因为你用的 shell 是 <a href="https://fishshell.com">fish</a> 语法不兼容的原因。</p>

<p>两个解决办法：</p>

<ul>
  <li>可通过来自<a href="https://github.com/emscripten-core/emsdk/issues/111">emscripten-core/emsdk issue#111</a> 中提供的方法，执行下面的命令来绕开：</li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>bash ./emsdk_env.sh
</code></pre></div></div>

<ul>
  <li>因为其也提供了对应的 <code class="language-plaintext highlighter-rouge">.fish</code> 脚本，所以，也可以直接选择运行该 fish 脚本来解决上面语法报错的问题：</li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">source</span> ./emsdk_env.fish
</code></pre></div></div>

<p>执行成功的输出：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">source</span> ./emsdk_env.fish
Adding directories to PATH:
PATH +<span class="o">=</span> /Users/wayou/dev/emsdk

Setting environment variables:
EMSDK <span class="o">=</span> /Users/wayou/dev/emsdk
EM_CONFIG <span class="o">=</span> /Users/wayou/.emscripten
</code></pre></div></div>

<h3 id="检查安装">检查安装</h3>

<p>完成上面步骤后，可通过运行 <code class="language-plaintext highlighter-rouge">emcc --version</code> 命令查看是否安装成功：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>emcc <span class="nt">--version</span>
</code></pre></div></div>

<details>
<summary>
`emcc --version` 命令的输出
</summary>

```sh
$ emcc --version
cache:INFO: generating system asset: is_vanilla.txt... (this will be cached in "/Users/wayou/.emscripten_cache/is_vanilla.txt" for subsequent builds)
cache:INFO:  - ok
emcc (Emscripten gcc/clang-like replacement) 1.38.33 (commit 0490c5f7aaf0e61aafd3b4cfe22cc56b803026b1)
Copyright (C) 2014 the Emscripten authors (see AUTHORS.txt)
This is free and open source software under the MIT license.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

</details>

<p>如果执行 <code class="language-plaintext highlighter-rouge">emcc</code> 时报如下错误：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>emcc <span class="nt">--version</span>
emscripten requires python 2.7.12 or above
</code></pre></div></div>

<p>大概率是 macOS 自带的是老版本的 Python2，而 <code class="language-plaintext highlighter-rouge">emcc</code> 需要 Python3。解决办法有很多，这里说一个。</p>

<p>尝试过在命令的配置文件中添加 <code class="language-plaintext highlighter-rouge">alias</code> 配置 <code class="language-plaintext highlighter-rouge">aliast python=python3</code>，是不生效的，但可以将 <code class="language-plaintext highlighter-rouge">emcc</code> 命令配置 <code class="language-plaintext highlighter-rouge">alias</code> 显式指定使用 <code class="language-plaintext highlighter-rouge">python3</code> 来启动。将如下配置添加到相应 shell 的配置文件中，以 fish 为例其配置文件为 <code class="language-plaintext highlighter-rouge">~/.config/fish/config.fish</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">alias </span><span class="nv">emcc</span><span class="o">=</span><span class="s2">"python3 /Users/wayou/Documents/dev/github/emsdk/fastcomp/emscripten/emcc"</span>
<span class="nb">alias </span>em++<span class="o">=</span><span class="s2">"python3 /Users/wayou/Documents/dev/github/emsdk/fastcomp/emscripten/em++"</span>
<span class="nb">alias </span><span class="nv">emrun</span><span class="o">=</span><span class="s2">"python3 /Users/wayou/Documents/dev/github/emsdk/fastcomp/emscripten/emrun"</span>
</code></pre></div></div>

<p>根据官方文档的描述：</p>

<blockquote>
  <p>use em++ to force compilation as C++
<em>--<a href="https://emscripten.org/docs/getting_started/Tutorial.html">Emscripten Tutorial</a></em></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">em++</code> 用于编译 c++ 代码，所以这里将 <code class="language-plaintext highlighter-rouge">em++</code> 也添加上了。</p>

<p>这里同时也将 <code class="language-plaintext highlighter-rouge">emrun</code> 添加上了别名，方便后面使用它来启动本地服务以调试。</p>

<p><strong>小贴士</strong>：新开命令行窗口或重启命令行后，需要重新执行 <code class="language-plaintext highlighter-rouge">source</code> 命令，可将其添加到你所使用的命令行的配置文件中，<code class="language-plaintext highlighter-rouge">.bash_profile</code>，<code class="language-plaintext highlighter-rouge">.zshrc</code>，或 <code class="language-plaintext highlighter-rouge">.</code></p>

<p>以 fish 为例：</p>

<p><strong>~/.config/fish/config.fish.fish</strong></p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source</span> <span class="s2">"/Users/wayou/dev/emsdk/emsdk_env.fish"</span><span class="p">;</span>
</code></pre></div></div>

<p>这样每次启动命令行后 <code class="language-plaintext highlighter-rouge">emcc</code> 都是可用状态。</p>

<h2 id="编译及运行">编译及运行</h2>

<p>安装配置完成后，便可以尝试编译并运行一个简单的 demo 程序了。</p>

<p>一些注意点：</p>

<ul>
  <li>运行 <code class="language-plaintext highlighter-rouge">emcc</code> 时需要指定 <code class="language-plaintext highlighter-rouge">-s WASM=1</code> 参数，否则默认情况下其输出为 <code class="language-plaintext highlighter-rouge">asm.js</code>。</li>
  <li>除了生成 Wasm 二进制文件及对应的 JavaScript 封装，如果还想要生成一个可直接查看的 HTML 页面，可在输出时指定一个后缀为 <code class="language-plaintext highlighter-rouge">.html</code> 的文件。</li>
  <li>实际运行时不能直接打开这个生成的 HTML 文件，因为 <code class="language-plaintext highlighter-rouge">file:///</code> 协议不支持跨域，所以需要本地启一个服务器来查看。</li>
</ul>

<h3 id="编写-hello-world">编写 Hello World</h3>

<p>创建 <code class="language-plaintext highlighter-rouge">hello.c</code> 文件并输出以下内容：</p>

<p><em>hello.c</em></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Hello, world!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="编译">编译</h3>

<p>执行以下命令进行编译：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>emcc hello.c <span class="nt">-s</span> <span class="nv">WASM</span><span class="o">=</span>1 <span class="nt">-o</span> hello.html
</code></pre></div></div>

<h3 id="运行">运行</h3>

<p>通过工具链中提供的 <code class="language-plaintext highlighter-rouge">smrun</code> 来开启一个本地服务器以查看刚刚生成的程序：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>emrun <span class="nt">--no_browser</span> <span class="nt">--port</span> 8080 <span class="nb">.</span>
</code></pre></div></div>

<p>当然，使用其他任意 server 也是可以的，比如 Python 的：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python <span class="nt">-m</span> http.server 8080
</code></pre></div></div>

<p>启动成功后浏览器访问 <a href="http://localhost:8080/hello.html">http://localhost:8080/hello.html</a>。不出意外你会看到页面中 Emscripten 的控制台展示了 <code class="language-plaintext highlighter-rouge">Hello, world!</code>。</p>

<p><img src="https://user-images.githubusercontent.com/3783096/58644777-8e45fc00-8334-11e9-81cb-b4d27945df56.png" alt="WebAssembly Hello Wrold 运行效果" /></p>

<p align="center">WebAssembly Hello Wrold 运行效果</p>

<p>但用 <code class="language-plaintext highlighter-rouge">emrun</code> 的好处在于它已经处理好了 <code class="language-plaintext highlighter-rouge">.wasm</code> 文件的返回类型为 <code class="language-plaintext highlighter-rouge">Content-type: application/wasm</code>，而其他 server 可能需要额外的配置，否则默认情况下 <code class="language-plaintext highlighter-rouge">.wasm</code> 文件返回到浏览器时其 <code class="language-plaintext highlighter-rouge">Content-Type</code> 不对会报错。</p>

<h2 id="调用-c-中的方法">调用 C++ 中的方法</h2>

<p>下面来看如何在 JavaScript 中调用 C++ 定义的方法。</p>

<p>默认情况下，Emscripten 编译后的代码只包含 <code class="language-plaintext highlighter-rouge">main</code> 方法相关的调用，其他无关的代码将会在编译时去掉。可通过在方法名前加 <code class="language-plaintext highlighter-rouge">EMSCRIPTEN_KEEPALIVE</code> 来防止需要导出的方法被去掉。</p>

<p>将以下代码放入 <code class="language-plaintext highlighter-rouge">hello.c</code> 并保存。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;emscripten/emscripten.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello World</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef __cplusplus
</span><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
<span class="cp">#endif
</span>
<span class="kt">void</span> <span class="n">EMSCRIPTEN_KEEPALIVE</span> <span class="n">myFunction</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"MyFunction Called</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef __cplusplus
</span><span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>

<p>此时编译需要加上 <code class="language-plaintext highlighter-rouge">NO_EXIT_RUNTIME</code> 参数，否则默认情况下 C++ 模块中 <code class="language-plaintext highlighter-rouge">main</code> 方法返回后程序就结束了。</p>

<p>执行以下命令编译代码：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>emcc <span class="nt">-o</span> hello3.html hello3.c <span class="nt">-O3</span> <span class="nt">-s</span> <span class="nv">WASM</span><span class="o">=</span>1 <span class="nt">-s</span> <span class="nv">NO_EXIT_RUNTIME</span><span class="o">=</span>1  <span class="nt">-s</span> <span class="s2">"EXTRA_EXPORTED_RUNTIME_METHODS=['ccall']"</span>
</code></pre></div></div>

<p>打开在发生的 <code class="language-plaintext highlighter-rouge">hello.html</code>，在第一个 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 标签开始前加上一个按钮：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"mybutton"</span><span class="nt">&gt;</span>Run myFunction<span class="nt">&lt;/button&gt;</span>
</code></pre></div></div>

<p>添加以下点击调用逻辑到第一个 <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> 代码块的末尾：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">"</span><span class="s2">.mybutton</span><span class="dl">"</span><span class="p">).</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">check console</span><span class="dl">"</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">Module</span><span class="p">.</span><span class="nx">ccall</span><span class="p">(</span>
    <span class="dl">"</span><span class="s2">myFunction</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// name of C function</span>
    <span class="kc">null</span><span class="p">,</span> <span class="c1">// return type</span>
    <span class="kc">null</span><span class="p">,</span> <span class="c1">// argument types</span>
    <span class="kc">null</span> <span class="c1">// arguments</span>
  <span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>再次启动服务器运行后，点击页面中按钮在控制台观察输出。</p>

<p><img src="https://user-images.githubusercontent.com/3783096/58781578-e28bfd00-860e-11e9-9cf2-3e26b7030a03.gif" alt="JavaScript 中调用 C++ 方法的示例" /></p>
<p align="center">JavaScript 中调用 C++ 方法的示例</p>

<h2 id="相关资源">相关资源</h2>

<ul>
  <li><a href="https://webassembly.org/getting-started/developers-guide/">WebAssembly - Developer’s Guide</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm">Compiling a New C/C++ Module to WebAssembly</a></li>
</ul>


  </div><a class="u-url" href="/2019/05/31/WebAssembly-%E4%B8%8A%E6%89%8B.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
