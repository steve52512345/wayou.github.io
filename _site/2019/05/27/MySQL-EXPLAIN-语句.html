<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>MySQL EXPLAIN 语句 | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="MySQL EXPLAIN 语句" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="MySQL EXPLAIN 语句 对于 MySQL 在执行时来说，EXPLAIN 功能上与 DESCRIBE 一样。实际运用中，后者多用来获取表的信息，而前者多用于展示 MySQL 会如何执行 SQL 语句（Obtaining Execution Plan Information）。 DESCRIBE 实质上是 SHOW COLUMNS 语句的缩略形式。 EXPLAIN 可作用于这些 SQL 关键词：SELECT, DELETE, INSERT, REPLACE 以及 UPDATE。 当作用于可解释性的语句（explainable statement）时，其展示相应 SQL 语句被优化后的执行计划（execution plan），也就是 MySQL 会如何处理该 SQL 查询语句，比如有 JOIN 语句时多表是怎样结合，以怎样的顺序结合。 当作用于 FOR CONNECTION connection_id 而不是可解释性语句时，其展示的是该连接的执行计划。 涉及到对分区表的查询时，EXPLAIN 就十分有用了。 通过 EXPLAIN 你能看出在哪里添加索引以优化加速查询语句，也可以查看联表时是否以最佳顺序进行的。 EXPLAIN 的输出中，为每张参与查询的表生成一行结果，顺序则是按 MySQL 读取这些且的顺序。MySQL 进行 JOIN 操作时，实际是是通过嵌套循环完成的，即先读取第一张表的一条记录，再去第二张表中寻找匹配的记录，再去第三张表中匹配，以此类推。 Wrokbench 中查看执行计划 MySQL 的 GUI 工具 Workbench 提供了可视化的途径查看执行计划，这对于性能分析很有用。 MySQL Workbench 中执行计划的可视化展示 EXPLAIN 输出表格中的含义 列名 JSON 中的列名 含义 id select_id SELECT 标识 select_type N/A SELECT 类型 table table_name 构造该行输出的表名 partitions partitions 匹配到的分区表 type access_type JOIN 类型 possible_keys possible_keys 可选的索引 key key 真实选中的索引 key_len key_length 被选中的键的长度 ref ref 用于和索引进行对比的列 rows rows 预估用于查询的记录数 filtered filtered 被查询条件过滤掉的记录数百分比 Extra N/A 额外的其他信息 来自 MySQL Reference Manual 中关于 EXPLAIN 输出的表格 其中 JSON 列表是将该输出导出为 JSON 格式时使用的列名。 其中 select_type SELECT 类型，所有可能的值见下表： select_type Value JSON Name Meaning SIMPLE None 普通类型的 SELECT，没有 UNION 及子查询 PRIMARY None 最外层的 SELECT UNION None 配合 UNION 使用时第二个及后面的 SELECT DEPENDENT UNION dependent (true) 配合 UNION 使用时第二个及后面的 SELECT，因外层的查询而有差异 UNION RESULT union_result UNION 返回的结果 SUBQUERY None 子查询中第一个 SELECT DEPENDENT SUBQUERY dependent (true) 子查询中第一个 SELECT，因外层查询而异 DERIVED None 衍生表 DEPENDENT DERIVED dependent (true) 依赖于其他表的衍生表 MATERIALIZED materialized_from_subquery 物化的子查询 UNCACHEABLE SUBQUERY cacheable (false) 无法缓存的子查询，对于第一行必需重新执行 UNCACHEABLE UNION cacheable (false) 不可缓存的子查询里 UNION 中第二个及往后的 SELECT type JOIN 类型描述表是如何被联接的，其可能的值有以下这些，排序由最优到最次： system：表中只有一条记录，属于 const JOIN 类型的一个特例。 const：表中至多只有一条匹配的记录。因为只有一条，所以取出的列值可当作常量被优化，查询速度最快。当主键（ PRIMARY KEY）或唯一性索引（UNIQUE index）与常量进行比较时，会使用此类型。 SELECT * FROM tbl_name WHERE primary_key=1; SELECT * FROM tbl_name WHERE primary_key_part1=1 AND primary_key_part2=2; eq_ref：对于前面每个表中记录的组合，都从这个表里读取一条记录。该类型可用于对索引列使用 = 操作符进行比较时。 SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column; SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column AND ref_table.key_column_part2=1; ref：对于前面每个表中记录的组合，从该表读取所有所有匹配到的索引记录。ref 用于 JOIN 使用使用非主键或唯一索引列时，或只使用键的前缀的场景。 SELECT * FROM ref_table WHERE key_column=expr; SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column; SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column AND ref_table.key_column_part2=1; fulltext：JOIN 使用的是 FULLTEXT 类型的索引 ref_or_null：类似 ref，但会对 NULL 值做额外的查询。这种类型的 JOIN 优化常用于子查询，以下的示例 MySQL 全会使用 ref_or_null 联表来处理 ref_table ： SELECT * FROM ref_table WHERE key_column=expr OR key_column IS NULL; index_merge：表示将会运用索引合并这一优化方式，详见 Section 8.2.1.3, “Index Merge Optimization”。 unique_subquery：替换某些场景下 IN 语句中子查询的 eq_ref 类型的联表。 index_subquery：类似 unique_subquery，替换 IN 子查询，但作用于非唯一性索引（nonunique indexes）。 value IN (SELECT key_column FROM single_table WHERE some_expr) range：只返回范围内的记录。 index：同 ALL 类型，但只使用索引来搜索。 ALL：查询时进行全表扫描。 相关资源 13.8.2 EXPLAIN Syntax Explain Vs Desc anomalies in mysql 8.8.2 EXPLAIN Output Format" />
<meta property="og:description" content="MySQL EXPLAIN 语句 对于 MySQL 在执行时来说，EXPLAIN 功能上与 DESCRIBE 一样。实际运用中，后者多用来获取表的信息，而前者多用于展示 MySQL 会如何执行 SQL 语句（Obtaining Execution Plan Information）。 DESCRIBE 实质上是 SHOW COLUMNS 语句的缩略形式。 EXPLAIN 可作用于这些 SQL 关键词：SELECT, DELETE, INSERT, REPLACE 以及 UPDATE。 当作用于可解释性的语句（explainable statement）时，其展示相应 SQL 语句被优化后的执行计划（execution plan），也就是 MySQL 会如何处理该 SQL 查询语句，比如有 JOIN 语句时多表是怎样结合，以怎样的顺序结合。 当作用于 FOR CONNECTION connection_id 而不是可解释性语句时，其展示的是该连接的执行计划。 涉及到对分区表的查询时，EXPLAIN 就十分有用了。 通过 EXPLAIN 你能看出在哪里添加索引以优化加速查询语句，也可以查看联表时是否以最佳顺序进行的。 EXPLAIN 的输出中，为每张参与查询的表生成一行结果，顺序则是按 MySQL 读取这些且的顺序。MySQL 进行 JOIN 操作时，实际是是通过嵌套循环完成的，即先读取第一张表的一条记录，再去第二张表中寻找匹配的记录，再去第三张表中匹配，以此类推。 Wrokbench 中查看执行计划 MySQL 的 GUI 工具 Workbench 提供了可视化的途径查看执行计划，这对于性能分析很有用。 MySQL Workbench 中执行计划的可视化展示 EXPLAIN 输出表格中的含义 列名 JSON 中的列名 含义 id select_id SELECT 标识 select_type N/A SELECT 类型 table table_name 构造该行输出的表名 partitions partitions 匹配到的分区表 type access_type JOIN 类型 possible_keys possible_keys 可选的索引 key key 真实选中的索引 key_len key_length 被选中的键的长度 ref ref 用于和索引进行对比的列 rows rows 预估用于查询的记录数 filtered filtered 被查询条件过滤掉的记录数百分比 Extra N/A 额外的其他信息 来自 MySQL Reference Manual 中关于 EXPLAIN 输出的表格 其中 JSON 列表是将该输出导出为 JSON 格式时使用的列名。 其中 select_type SELECT 类型，所有可能的值见下表： select_type Value JSON Name Meaning SIMPLE None 普通类型的 SELECT，没有 UNION 及子查询 PRIMARY None 最外层的 SELECT UNION None 配合 UNION 使用时第二个及后面的 SELECT DEPENDENT UNION dependent (true) 配合 UNION 使用时第二个及后面的 SELECT，因外层的查询而有差异 UNION RESULT union_result UNION 返回的结果 SUBQUERY None 子查询中第一个 SELECT DEPENDENT SUBQUERY dependent (true) 子查询中第一个 SELECT，因外层查询而异 DERIVED None 衍生表 DEPENDENT DERIVED dependent (true) 依赖于其他表的衍生表 MATERIALIZED materialized_from_subquery 物化的子查询 UNCACHEABLE SUBQUERY cacheable (false) 无法缓存的子查询，对于第一行必需重新执行 UNCACHEABLE UNION cacheable (false) 不可缓存的子查询里 UNION 中第二个及往后的 SELECT type JOIN 类型描述表是如何被联接的，其可能的值有以下这些，排序由最优到最次： system：表中只有一条记录，属于 const JOIN 类型的一个特例。 const：表中至多只有一条匹配的记录。因为只有一条，所以取出的列值可当作常量被优化，查询速度最快。当主键（ PRIMARY KEY）或唯一性索引（UNIQUE index）与常量进行比较时，会使用此类型。 SELECT * FROM tbl_name WHERE primary_key=1; SELECT * FROM tbl_name WHERE primary_key_part1=1 AND primary_key_part2=2; eq_ref：对于前面每个表中记录的组合，都从这个表里读取一条记录。该类型可用于对索引列使用 = 操作符进行比较时。 SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column; SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column AND ref_table.key_column_part2=1; ref：对于前面每个表中记录的组合，从该表读取所有所有匹配到的索引记录。ref 用于 JOIN 使用使用非主键或唯一索引列时，或只使用键的前缀的场景。 SELECT * FROM ref_table WHERE key_column=expr; SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column; SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column AND ref_table.key_column_part2=1; fulltext：JOIN 使用的是 FULLTEXT 类型的索引 ref_or_null：类似 ref，但会对 NULL 值做额外的查询。这种类型的 JOIN 优化常用于子查询，以下的示例 MySQL 全会使用 ref_or_null 联表来处理 ref_table ： SELECT * FROM ref_table WHERE key_column=expr OR key_column IS NULL; index_merge：表示将会运用索引合并这一优化方式，详见 Section 8.2.1.3, “Index Merge Optimization”。 unique_subquery：替换某些场景下 IN 语句中子查询的 eq_ref 类型的联表。 index_subquery：类似 unique_subquery，替换 IN 子查询，但作用于非唯一性索引（nonunique indexes）。 value IN (SELECT key_column FROM single_table WHERE some_expr) range：只返回范围内的记录。 index：同 ALL 类型，但只使用索引来搜索。 ALL：查询时进行全表扫描。 相关资源 13.8.2 EXPLAIN Syntax Explain Vs Desc anomalies in mysql 8.8.2 EXPLAIN Output Format" />
<link rel="canonical" href="http://localhost:4000/2019/05/27/MySQL-EXPLAIN-%E8%AF%AD%E5%8F%A5.html" />
<meta property="og:url" content="http://localhost:4000/2019/05/27/MySQL-EXPLAIN-%E8%AF%AD%E5%8F%A5.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-27T00:05:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/05/27/MySQL-EXPLAIN-%E8%AF%AD%E5%8F%A5.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/05/27/MySQL-EXPLAIN-%E8%AF%AD%E5%8F%A5.html"},"description":"MySQL EXPLAIN 语句 对于 MySQL 在执行时来说，EXPLAIN 功能上与 DESCRIBE 一样。实际运用中，后者多用来获取表的信息，而前者多用于展示 MySQL 会如何执行 SQL 语句（Obtaining Execution Plan Information）。 DESCRIBE 实质上是 SHOW COLUMNS 语句的缩略形式。 EXPLAIN 可作用于这些 SQL 关键词：SELECT, DELETE, INSERT, REPLACE 以及 UPDATE。 当作用于可解释性的语句（explainable statement）时，其展示相应 SQL 语句被优化后的执行计划（execution plan），也就是 MySQL 会如何处理该 SQL 查询语句，比如有 JOIN 语句时多表是怎样结合，以怎样的顺序结合。 当作用于 FOR CONNECTION connection_id 而不是可解释性语句时，其展示的是该连接的执行计划。 涉及到对分区表的查询时，EXPLAIN 就十分有用了。 通过 EXPLAIN 你能看出在哪里添加索引以优化加速查询语句，也可以查看联表时是否以最佳顺序进行的。 EXPLAIN 的输出中，为每张参与查询的表生成一行结果，顺序则是按 MySQL 读取这些且的顺序。MySQL 进行 JOIN 操作时，实际是是通过嵌套循环完成的，即先读取第一张表的一条记录，再去第二张表中寻找匹配的记录，再去第三张表中匹配，以此类推。 Wrokbench 中查看执行计划 MySQL 的 GUI 工具 Workbench 提供了可视化的途径查看执行计划，这对于性能分析很有用。 MySQL Workbench 中执行计划的可视化展示 EXPLAIN 输出表格中的含义 列名 JSON 中的列名 含义 id select_id SELECT 标识 select_type N/A SELECT 类型 table table_name 构造该行输出的表名 partitions partitions 匹配到的分区表 type access_type JOIN 类型 possible_keys possible_keys 可选的索引 key key 真实选中的索引 key_len key_length 被选中的键的长度 ref ref 用于和索引进行对比的列 rows rows 预估用于查询的记录数 filtered filtered 被查询条件过滤掉的记录数百分比 Extra N/A 额外的其他信息 来自 MySQL Reference Manual 中关于 EXPLAIN 输出的表格 其中 JSON 列表是将该输出导出为 JSON 格式时使用的列名。 其中 select_type SELECT 类型，所有可能的值见下表： select_type Value JSON Name Meaning SIMPLE None 普通类型的 SELECT，没有 UNION 及子查询 PRIMARY None 最外层的 SELECT UNION None 配合 UNION 使用时第二个及后面的 SELECT DEPENDENT UNION dependent (true) 配合 UNION 使用时第二个及后面的 SELECT，因外层的查询而有差异 UNION RESULT union_result UNION 返回的结果 SUBQUERY None 子查询中第一个 SELECT DEPENDENT SUBQUERY dependent (true) 子查询中第一个 SELECT，因外层查询而异 DERIVED None 衍生表 DEPENDENT DERIVED dependent (true) 依赖于其他表的衍生表 MATERIALIZED materialized_from_subquery 物化的子查询 UNCACHEABLE SUBQUERY cacheable (false) 无法缓存的子查询，对于第一行必需重新执行 UNCACHEABLE UNION cacheable (false) 不可缓存的子查询里 UNION 中第二个及往后的 SELECT type JOIN 类型描述表是如何被联接的，其可能的值有以下这些，排序由最优到最次： system：表中只有一条记录，属于 const JOIN 类型的一个特例。 const：表中至多只有一条匹配的记录。因为只有一条，所以取出的列值可当作常量被优化，查询速度最快。当主键（ PRIMARY KEY）或唯一性索引（UNIQUE index）与常量进行比较时，会使用此类型。 SELECT * FROM tbl_name WHERE primary_key=1; SELECT * FROM tbl_name WHERE primary_key_part1=1 AND primary_key_part2=2; eq_ref：对于前面每个表中记录的组合，都从这个表里读取一条记录。该类型可用于对索引列使用 = 操作符进行比较时。 SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column; SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column AND ref_table.key_column_part2=1; ref：对于前面每个表中记录的组合，从该表读取所有所有匹配到的索引记录。ref 用于 JOIN 使用使用非主键或唯一索引列时，或只使用键的前缀的场景。 SELECT * FROM ref_table WHERE key_column=expr; SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column; SELECT * FROM ref_table,other_table WHERE ref_table.key_column_part1=other_table.column AND ref_table.key_column_part2=1; fulltext：JOIN 使用的是 FULLTEXT 类型的索引 ref_or_null：类似 ref，但会对 NULL 值做额外的查询。这种类型的 JOIN 优化常用于子查询，以下的示例 MySQL 全会使用 ref_or_null 联表来处理 ref_table ： SELECT * FROM ref_table WHERE key_column=expr OR key_column IS NULL; index_merge：表示将会运用索引合并这一优化方式，详见 Section 8.2.1.3, “Index Merge Optimization”。 unique_subquery：替换某些场景下 IN 语句中子查询的 eq_ref 类型的联表。 index_subquery：类似 unique_subquery，替换 IN 子查询，但作用于非唯一性索引（nonunique indexes）。 value IN (SELECT key_column FROM single_table WHERE some_expr) range：只返回范围内的记录。 index：同 ALL 类型，但只使用索引来搜索。 ALL：查询时进行全表扫描。 相关资源 13.8.2 EXPLAIN Syntax Explain Vs Desc anomalies in mysql 8.8.2 EXPLAIN Output Format","@type":"BlogPosting","headline":"MySQL EXPLAIN 语句","dateModified":"2019-05-27T00:05:00+08:00","datePublished":"2019-05-27T00:05:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">MySQL EXPLAIN 语句</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-05-27T00:05:00+08:00" itemprop="datePublished">May 27, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="mysql-explain-语句">MySQL EXPLAIN 语句</h1>

<p>对于 MySQL 在执行时来说，<a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">EXPLAIN</a> 功能上与 <a href="https://dev.mysql.com/doc/refman/8.0/en/describe.html">DESCRIBE</a> 一样。实际运用中，后者多用来获取表的信息，而前者多用于展示 MySQL 会如何执行 SQL 语句（<a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html#explain-execution-plan">Obtaining Execution Plan Information</a>）。</p>

<p><a href="https://dev.mysql.com/doc/refman/8.0/en/describe.html">DESCRIBE</a> 实质上是 <a href="https://dev.mysql.com/doc/refman/8.0/en/show-columns.html">SHOW COLUMNS</a> 语句的缩略形式。</p>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">EXPLAIN</a> 可作用于这些 SQL 关键词：SELECT, DELETE, INSERT, REPLACE 以及 UPDATE。</li>
  <li>当作用于可解释性的语句（explainable statement）时，其展示相应 SQL 语句被优化后的执行计划（execution plan），也就是 MySQL 会如何处理该 SQL 查询语句，比如有 <code class="language-plaintext highlighter-rouge">JOIN</code> 语句时多表是怎样结合，以怎样的顺序结合。</li>
  <li>当作用于 <code class="language-plaintext highlighter-rouge">FOR CONNECTION connection_id</code> 而不是可解释性语句时，其展示的是该连接的执行计划。</li>
  <li>涉及到对分区表的查询时，<a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">EXPLAIN</a> 就十分有用了。</li>
</ul>

<p>通过 <a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">EXPLAIN</a> 你能看出在哪里添加索引以优化加速查询语句，也可以查看联表时是否以最佳顺序进行的。</p>

<p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">EXPLAIN</a> 的输出中，为每张参与查询的表生成一行结果，顺序则是按 MySQL 读取这些且的顺序。MySQL 进行 JOIN 操作时，实际是是通过嵌套循环完成的，即先读取第一张表的一条记录，再去第二张表中寻找匹配的记录，再去第三张表中匹配，以此类推。</p>

<h3 id="wrokbench-中查看执行计划">Wrokbench 中查看执行计划</h3>

<p>MySQL 的 GUI 工具 Workbench 提供了可视化的途径查看执行计划，这对于性能分析很有用。</p>

<p><img src="https://user-images.githubusercontent.com/3783096/58379691-a38bf500-7fd9-11e9-9151-216cae041812.png" alt="MySQL Workbench 中执行计划的可视化展示" /></p>
<p align="center">MySQL Workbench 中执行计划的可视化展示</p>

<h2 id="explain-输出表格中的含义">EXPLAIN 输出表格中的含义</h2>

<table>
  <thead>
    <tr>
      <th>列名</th>
      <th>JSON 中的列名</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>select_id</td>
      <td>SELECT 标识</td>
    </tr>
    <tr>
      <td>select_type</td>
      <td>N/A</td>
      <td>SELECT 类型</td>
    </tr>
    <tr>
      <td>table</td>
      <td>table_name</td>
      <td>构造该行输出的表名</td>
    </tr>
    <tr>
      <td>partitions</td>
      <td>partitions</td>
      <td>匹配到的分区表</td>
    </tr>
    <tr>
      <td>type</td>
      <td>access_type</td>
      <td>JOIN 类型</td>
    </tr>
    <tr>
      <td>possible_keys</td>
      <td>possible_keys</td>
      <td>可选的索引</td>
    </tr>
    <tr>
      <td>key</td>
      <td>key</td>
      <td>真实选中的索引</td>
    </tr>
    <tr>
      <td>key_len</td>
      <td>key_length</td>
      <td>被选中的键的长度</td>
    </tr>
    <tr>
      <td>ref</td>
      <td>ref</td>
      <td>用于和索引进行对比的列</td>
    </tr>
    <tr>
      <td>rows</td>
      <td>rows</td>
      <td>预估用于查询的记录数</td>
    </tr>
    <tr>
      <td>filtered</td>
      <td>filtered</td>
      <td>被查询条件过滤掉的记录数百分比</td>
    </tr>
    <tr>
      <td>Extra</td>
      <td>N/A</td>
      <td>额外的其他信息</td>
    </tr>
  </tbody>
</table>

<p><em>来自 MySQL Reference Manual 中关于 EXPLAIN 输出的表格</em></p>

<p>其中 JSON 列表是将该输出导出为 JSON 格式时使用的列名。</p>

<p>其中 <code class="language-plaintext highlighter-rouge">select_type</code> SELECT 类型，所有可能的值见下表：</p>

<table>
  <thead>
    <tr>
      <th>select_type Value</th>
      <th>JSON Name</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SIMPLE</td>
      <td>None</td>
      <td>普通类型的 SELECT，没有 UNION 及子查询</td>
    </tr>
    <tr>
      <td>PRIMARY</td>
      <td>None</td>
      <td>最外层的 SELECT</td>
    </tr>
    <tr>
      <td>UNION</td>
      <td>None</td>
      <td>配合 UNION 使用时第二个及后面的 SELECT</td>
    </tr>
    <tr>
      <td>DEPENDENT UNION</td>
      <td>dependent (true)</td>
      <td>配合 UNION 使用时第二个及后面的 SELECT，因外层的查询而有差异</td>
    </tr>
    <tr>
      <td>UNION RESULT</td>
      <td>union_result</td>
      <td>UNION 返回的结果</td>
    </tr>
    <tr>
      <td>SUBQUERY</td>
      <td>None</td>
      <td>子查询中第一个 SELECT</td>
    </tr>
    <tr>
      <td>DEPENDENT SUBQUERY</td>
      <td>dependent (true)</td>
      <td>子查询中第一个 SELECT，因外层查询而异</td>
    </tr>
    <tr>
      <td>DERIVED</td>
      <td>None</td>
      <td>衍生表</td>
    </tr>
    <tr>
      <td>DEPENDENT DERIVED</td>
      <td>dependent (true)</td>
      <td>依赖于其他表的衍生表</td>
    </tr>
    <tr>
      <td>MATERIALIZED</td>
      <td>materialized_from_subquery</td>
      <td>物化的子查询</td>
    </tr>
    <tr>
      <td>UNCACHEABLE SUBQUERY</td>
      <td>cacheable (false)</td>
      <td>无法缓存的子查询，对于第一行必需重新执行</td>
    </tr>
    <tr>
      <td>UNCACHEABLE UNION</td>
      <td>cacheable (false)</td>
      <td>不可缓存的子查询里 UNION 中第二个及往后的 SELECT</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">type</code> JOIN 类型描述表是如何被联接的，其可能的值有以下这些，排序由最优到最次：</p>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_system">system</a>：表中只有一条记录，属于 <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_const">const</a> JOIN 类型的一个特例。</li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_const">const</a>：表中至多只有一条匹配的记录。因为只有一条，所以取出的列值可当作常量被优化，查询速度最快。当主键（ PRIMARY KEY）或唯一性索引（UNIQUE index）与常量进行比较时，会使用此类型。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tbl_name</span> <span class="k">WHERE</span> <span class="n">primary_key</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tbl_name</span>
  <span class="k">WHERE</span> <span class="n">primary_key_part1</span><span class="o">=</span><span class="mi">1</span> <span class="k">AND</span> <span class="n">primary_key_part2</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_eq_ref">eq_ref</a>：对于前面每个表中记录的组合，都从这个表里读取一条记录。该类型可用于对索引列使用 <code class="language-plaintext highlighter-rouge">=</code> 操作符进行比较时。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ref_table</span><span class="p">,</span><span class="n">other_table</span>
  <span class="k">WHERE</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column</span><span class="o">=</span><span class="n">other_table</span><span class="p">.</span><span class="k">column</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ref_table</span><span class="p">,</span><span class="n">other_table</span>
  <span class="k">WHERE</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column_part1</span><span class="o">=</span><span class="n">other_table</span><span class="p">.</span><span class="k">column</span>
  <span class="k">AND</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column_part2</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_ref">ref</a>：对于前面每个表中记录的组合，从该表读取所有所有匹配到的索引记录。ref 用于 JOIN 使用使用非主键或唯一索引列时，或只使用键的前缀的场景。</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ref_table</span> <span class="k">WHERE</span> <span class="n">key_column</span><span class="o">=</span><span class="n">expr</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ref_table</span><span class="p">,</span><span class="n">other_table</span>
  <span class="k">WHERE</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column</span><span class="o">=</span><span class="n">other_table</span><span class="p">.</span><span class="k">column</span><span class="p">;</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ref_table</span><span class="p">,</span><span class="n">other_table</span>
  <span class="k">WHERE</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column_part1</span><span class="o">=</span><span class="n">other_table</span><span class="p">.</span><span class="k">column</span>
  <span class="k">AND</span> <span class="n">ref_table</span><span class="p">.</span><span class="n">key_column_part2</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_fulltext">fulltext</a>：JOIN 使用的是 FULLTEXT 类型的索引</li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_ref_or_null">ref_or_null</a>：类似 ref，但会对 NULL 值做额外的查询。这种类型的 JOIN 优化常用于子查询，以下的示例 MySQL 全会使用 ref_or_null 联表来处理 ref_table ：</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ref_table</span>
  <span class="k">WHERE</span> <span class="n">key_column</span><span class="o">=</span><span class="n">expr</span> <span class="k">OR</span> <span class="n">key_column</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
    <p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_index_merge">index_merge</a>：表示将会运用索引合并这一优化方式，详见 <a href="https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html">Section 8.2.1.3, “Index Merge Optimization”</a>。</p>
  </li>
  <li>
    <p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_unique_subquery">unique_subquery</a>：替换某些场景下 IN 语句中子查询的 eq_ref 类型的联表。</p>
  </li>
  <li>
    <p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_index_subquery">index_subquery</a>：类似 unique_subquery，替换 IN 子查询，但作用于非唯一性索引（nonunique indexes）。</p>
  </li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">key_column</span> <span class="k">FROM</span> <span class="n">single_table</span> <span class="k">WHERE</span> <span class="n">some_expr</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_range">range</a>：只返回范围内的记录。</li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_index">index</a>：同 ALL 类型，但只使用索引来搜索。</li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_all">ALL</a>：查询时进行全表扫描。</li>
</ul>

<h2 id="相关资源">相关资源</h2>

<ul>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">13.8.2 EXPLAIN Syntax</a></li>
  <li><a href="https://stackoverflow.com/questions/3100247/explain-vs-desc-anomalies-in-mysql">Explain Vs Desc anomalies in mysql</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">8.8.2 EXPLAIN Output Format</a></li>
</ul>


  </div><a class="u-url" href="/2019/05/27/MySQL-EXPLAIN-%E8%AF%AD%E5%8F%A5.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
