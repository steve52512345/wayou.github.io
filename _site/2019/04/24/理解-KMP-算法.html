<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>理解 KMP 算法 | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="理解 KMP 算法" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="理解 KMP 算法 KMP（The Knuth-Morris-Pratt Algorithm）算法用于字符串匹配，从字符串中找出给定的子字符串。但它并不是很好理解和掌握。而理解它概念中的部分匹配表，是理解 KMP 算法的关键。 这里的讨论绕开其背后晦涩难懂的逻辑，着重从其运用上来理解它。 字符串查找 比如从字符串 abcdef 中找出 abcdg 子字符串。 朴素的解法，我们可以这样做， 分别取出第一位进行匹配，如果相同再取出各自的第二位。 如果不同，则将索引后移一位，从总字符串第二位开始，重复步骤一。 这种朴素解法的弊端在于，每次匹配失败，索引只后移一位，有很多冗余操作，效率不高。 在进行第一轮匹配中，即索引为 0 时，我们能够匹配出前四个字符 abcd 是相等的，后面发现想要的 g 与真实的 e 不符，标志着索引为 0 的情况匹配失败，开始查看索引为 1 时，但因为我们在第一轮匹配中，已经知道了总字符串中前四个字符的长相，但还是需要重复地挨个进行匹配。 部分匹配表/Partial Match Table 以长度为 8 的字符串 abababca，为例，其部分匹配表格为： char: | a | b | a | b | a | b | c | a | index: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | value: | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 | 其中 value 行便是部分匹配表的值。 子集 对于上面示例字符串，假如我们观察第 index 为 2 的位置，那么我们得到了字符串的一个子集 aba，如果我们观察 index 为 7 的位置，那得到的是整个字符串，这点是很显然的。当我们观察的位置不同时，表示我们关注的字符串中的子集不同，因为子字符串发生了变化。 前缀 &amp; 后缀 对于给定的字符串，从末尾开始去掉一个或多个字符，剩下的部分都叫作该字符串的真前缀（Proper prefix），后面简称前缀。这里「真」不是「真·前缀」的意思，联想一下数学里面集合的「真子集」。比如 banana，其前缀有： b ba ban bana banan 同理，从首部开始，去掉一个或多个字条，剩下的部分是该字符串的真后缀（Proper suffix）。还是 banana，其后缀有： anana nana ana na a 部分匹配值 可以看到，所有前缀和后缀在数量上是对称的，那么我们可以从前缀中找出一个，与后缀进行匹配，先不关心做这个匹配的意义。以最开始的文本 abababca 为例。 假如我们观察 index 为 2 的位置，此时子字符串为 aba，其前后缀分别为： 前缀：a，ab 后缀：ba，a 将前缀依次在后缀中去匹配，这里前后缀列表中能够匹配上的只有 a 这个子字符串，其长度为 1，所以将这个观测结果填入表中记下来，与开始看到的部分匹配表吻合了。 再比如来观察 index 为 3 的位置，此时得到的子字符串为 abab，此时的前后缀为： 前缀：a，ab，aba 后缀：bab，ab，b 此时可观察出其匹配项为 ab，长度为 2，也与上面部分匹配表中的值吻合。 再比如来观察 index 为 5 的位置，此时子字符串为 ababab，前后缀为： 前缀：a，ab，aba，abab，ababa 后缀：babab，abab，bab，ab，b 然后拿前缀中每个元素与后缀中的元素进行匹配，最后找出有两个匹配项， ab abab 我们取长的这个 abab，其长度为 4。 所以现在再来看上面的部分匹配表，一是能理解其值是怎么来的，二是能理解其表示的意义，即，所有前缀与后缀的匹配项中长度最长的那一个的长度。 当我们继续，进行到 index 为 6 时，子字符串为 abababc，可以预见，前后缀中找不到匹配。因为所有前缀都不包含 c，而所有后缀都包含 c。所以此时部分匹配值为 0。 再继续就到字符串末尾了，即整个字符串 abababca。也可以预见，因为所有前缀都以 a 开始，并且所有后缀都以 a 结尾，所以此时的部分匹配值最少为 1。继续会发现，因为后面的后缀开始有 c 的加入，使得后缀都包含 ca，而前缀中能够包含 c 的只有 abababc，而该长度 7 与同等长度的后缀 bababca 不匹配。至此就可以得出结论，匹配结果就是 1，没有更长的匹配了。 部分匹配表的使用 利用上面的部分匹配值，我们在进行字符串查找时，不必每次失败后只移动一位，而是可以移动多位，去掉一些冗余的匹配。这里有个公式如下： If a partial match of length partial_match_length is found and table[partial_match_length] &gt; 1, we may skip ahead partial_match_length - table[partial_match_length - 1] characters. 如果匹配过程中，匹配到了部分值为 partial_match_length，即目前找出前 partial_match_length 个字符是匹配的，将这个长度减一作为部分匹配表格中的 index 代入，查找其对应的 value 即 table[partial_match_length-1]，那么我们可以向前移动的步长为 partial_match_length - table[partial_match_length - 1]。 下面是本文开始时的那个部分匹配表: char: | a | b | a | b | a | b | c | a | index: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | value: | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 | 假设需要从 bacbababaabcbab 中查找 abababca，根据上面的公式我们来走一遍。 首次匹配发生在总字符串的第二个字符， bacbababaabcbab | abababca 此时匹配的长度为 1，部分匹配表中索引为 1-1=0 的位置对应的部分匹配值为 0，所以我们可以向前移动的距离是 1-0 1。其实也相当于没有跳跃，就是正常的本次匹配失败，索引后移一位的情况。这里没有节省任何成本。 继续直到再次发生匹配，此时匹配到的情况如下： bacbababaabcbab ||||| abababca 现在匹配到的长度是 5，部分匹配表中 5-1=4 对应的部分匹配值为 3，所以我们可以向前移动 5-3=2，此时一下子就可以移动两位了。 上一次的位置 | 最新移动到的位置 | | bacbababaabcbab xx||| abababca 此时匹配到的长度为 3， 查找到 table[partial_match_length-1] 即 index 为 2 对应的值为 1，所以可向前移动的距离为 3-1=2。 bacbababaabcbab xx| abababca 此时我们需要查找的字符串其长度已经超出剩余可用来匹配的字符串了，所以可直接结束匹配，得到结论：没有查找到结果。 JavaScript 中的实现 以下是来自 trekhleb/javascript-algorithms 中 JavaScript 版本的 KMP 算法实现： /** * @see https://www.youtube.com/watch?v=GTJr8OvyEVQ * @param {string} word * @return {number[]} */ function buildPatternTable(word) { const patternTable = [0]; let prefixIndex = 0; let suffixIndex = 1; while (suffixIndex &lt; word.length) { if (word[prefixIndex] === word[suffixIndex]) { patternTable[suffixIndex] = prefixIndex + 1; suffixIndex += 1; prefixIndex += 1; } else if (prefixIndex === 0) { patternTable[suffixIndex] = 0; suffixIndex += 1; } else { prefixIndex = patternTable[prefixIndex - 1]; } } return patternTable; } /** * @param {string} text * @param {string} word * @return {number} */ export default function knuthMorrisPratt(text, word) { if (word.length === 0) { return 0; } let textIndex = 0; let wordIndex = 0; const patternTable = buildPatternTable(word); while (textIndex &lt; text.length) { if (text[textIndex] === word[wordIndex]) { // We&#39;ve found a match. if (wordIndex === word.length - 1) { return (textIndex - word.length) + 1; } wordIndex += 1; textIndex += 1; } else if (wordIndex &gt; 0) { wordIndex = patternTable[wordIndex - 1]; } else { wordIndex = 0; textIndex += 1; } } return -1; } 时间复杂度 因为算法中涉及两部分字符串的线性对比，其时间复杂度为两字符串长度之和，假设需要搜索的关键词长度为 k，总字符串长度为 m，则时间复杂度为 O(k+m)。 相关资源 The Knuth-Morris-Pratt Algorithm in my own words 来自 trekhleb/javascript-algorithms 仓库中的 KMP 实现 Knuth-Morris-Pratt algorithm" />
<meta property="og:description" content="理解 KMP 算法 KMP（The Knuth-Morris-Pratt Algorithm）算法用于字符串匹配，从字符串中找出给定的子字符串。但它并不是很好理解和掌握。而理解它概念中的部分匹配表，是理解 KMP 算法的关键。 这里的讨论绕开其背后晦涩难懂的逻辑，着重从其运用上来理解它。 字符串查找 比如从字符串 abcdef 中找出 abcdg 子字符串。 朴素的解法，我们可以这样做， 分别取出第一位进行匹配，如果相同再取出各自的第二位。 如果不同，则将索引后移一位，从总字符串第二位开始，重复步骤一。 这种朴素解法的弊端在于，每次匹配失败，索引只后移一位，有很多冗余操作，效率不高。 在进行第一轮匹配中，即索引为 0 时，我们能够匹配出前四个字符 abcd 是相等的，后面发现想要的 g 与真实的 e 不符，标志着索引为 0 的情况匹配失败，开始查看索引为 1 时，但因为我们在第一轮匹配中，已经知道了总字符串中前四个字符的长相，但还是需要重复地挨个进行匹配。 部分匹配表/Partial Match Table 以长度为 8 的字符串 abababca，为例，其部分匹配表格为： char: | a | b | a | b | a | b | c | a | index: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | value: | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 | 其中 value 行便是部分匹配表的值。 子集 对于上面示例字符串，假如我们观察第 index 为 2 的位置，那么我们得到了字符串的一个子集 aba，如果我们观察 index 为 7 的位置，那得到的是整个字符串，这点是很显然的。当我们观察的位置不同时，表示我们关注的字符串中的子集不同，因为子字符串发生了变化。 前缀 &amp; 后缀 对于给定的字符串，从末尾开始去掉一个或多个字符，剩下的部分都叫作该字符串的真前缀（Proper prefix），后面简称前缀。这里「真」不是「真·前缀」的意思，联想一下数学里面集合的「真子集」。比如 banana，其前缀有： b ba ban bana banan 同理，从首部开始，去掉一个或多个字条，剩下的部分是该字符串的真后缀（Proper suffix）。还是 banana，其后缀有： anana nana ana na a 部分匹配值 可以看到，所有前缀和后缀在数量上是对称的，那么我们可以从前缀中找出一个，与后缀进行匹配，先不关心做这个匹配的意义。以最开始的文本 abababca 为例。 假如我们观察 index 为 2 的位置，此时子字符串为 aba，其前后缀分别为： 前缀：a，ab 后缀：ba，a 将前缀依次在后缀中去匹配，这里前后缀列表中能够匹配上的只有 a 这个子字符串，其长度为 1，所以将这个观测结果填入表中记下来，与开始看到的部分匹配表吻合了。 再比如来观察 index 为 3 的位置，此时得到的子字符串为 abab，此时的前后缀为： 前缀：a，ab，aba 后缀：bab，ab，b 此时可观察出其匹配项为 ab，长度为 2，也与上面部分匹配表中的值吻合。 再比如来观察 index 为 5 的位置，此时子字符串为 ababab，前后缀为： 前缀：a，ab，aba，abab，ababa 后缀：babab，abab，bab，ab，b 然后拿前缀中每个元素与后缀中的元素进行匹配，最后找出有两个匹配项， ab abab 我们取长的这个 abab，其长度为 4。 所以现在再来看上面的部分匹配表，一是能理解其值是怎么来的，二是能理解其表示的意义，即，所有前缀与后缀的匹配项中长度最长的那一个的长度。 当我们继续，进行到 index 为 6 时，子字符串为 abababc，可以预见，前后缀中找不到匹配。因为所有前缀都不包含 c，而所有后缀都包含 c。所以此时部分匹配值为 0。 再继续就到字符串末尾了，即整个字符串 abababca。也可以预见，因为所有前缀都以 a 开始，并且所有后缀都以 a 结尾，所以此时的部分匹配值最少为 1。继续会发现，因为后面的后缀开始有 c 的加入，使得后缀都包含 ca，而前缀中能够包含 c 的只有 abababc，而该长度 7 与同等长度的后缀 bababca 不匹配。至此就可以得出结论，匹配结果就是 1，没有更长的匹配了。 部分匹配表的使用 利用上面的部分匹配值，我们在进行字符串查找时，不必每次失败后只移动一位，而是可以移动多位，去掉一些冗余的匹配。这里有个公式如下： If a partial match of length partial_match_length is found and table[partial_match_length] &gt; 1, we may skip ahead partial_match_length - table[partial_match_length - 1] characters. 如果匹配过程中，匹配到了部分值为 partial_match_length，即目前找出前 partial_match_length 个字符是匹配的，将这个长度减一作为部分匹配表格中的 index 代入，查找其对应的 value 即 table[partial_match_length-1]，那么我们可以向前移动的步长为 partial_match_length - table[partial_match_length - 1]。 下面是本文开始时的那个部分匹配表: char: | a | b | a | b | a | b | c | a | index: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | value: | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 | 假设需要从 bacbababaabcbab 中查找 abababca，根据上面的公式我们来走一遍。 首次匹配发生在总字符串的第二个字符， bacbababaabcbab | abababca 此时匹配的长度为 1，部分匹配表中索引为 1-1=0 的位置对应的部分匹配值为 0，所以我们可以向前移动的距离是 1-0 1。其实也相当于没有跳跃，就是正常的本次匹配失败，索引后移一位的情况。这里没有节省任何成本。 继续直到再次发生匹配，此时匹配到的情况如下： bacbababaabcbab ||||| abababca 现在匹配到的长度是 5，部分匹配表中 5-1=4 对应的部分匹配值为 3，所以我们可以向前移动 5-3=2，此时一下子就可以移动两位了。 上一次的位置 | 最新移动到的位置 | | bacbababaabcbab xx||| abababca 此时匹配到的长度为 3， 查找到 table[partial_match_length-1] 即 index 为 2 对应的值为 1，所以可向前移动的距离为 3-1=2。 bacbababaabcbab xx| abababca 此时我们需要查找的字符串其长度已经超出剩余可用来匹配的字符串了，所以可直接结束匹配，得到结论：没有查找到结果。 JavaScript 中的实现 以下是来自 trekhleb/javascript-algorithms 中 JavaScript 版本的 KMP 算法实现： /** * @see https://www.youtube.com/watch?v=GTJr8OvyEVQ * @param {string} word * @return {number[]} */ function buildPatternTable(word) { const patternTable = [0]; let prefixIndex = 0; let suffixIndex = 1; while (suffixIndex &lt; word.length) { if (word[prefixIndex] === word[suffixIndex]) { patternTable[suffixIndex] = prefixIndex + 1; suffixIndex += 1; prefixIndex += 1; } else if (prefixIndex === 0) { patternTable[suffixIndex] = 0; suffixIndex += 1; } else { prefixIndex = patternTable[prefixIndex - 1]; } } return patternTable; } /** * @param {string} text * @param {string} word * @return {number} */ export default function knuthMorrisPratt(text, word) { if (word.length === 0) { return 0; } let textIndex = 0; let wordIndex = 0; const patternTable = buildPatternTable(word); while (textIndex &lt; text.length) { if (text[textIndex] === word[wordIndex]) { // We&#39;ve found a match. if (wordIndex === word.length - 1) { return (textIndex - word.length) + 1; } wordIndex += 1; textIndex += 1; } else if (wordIndex &gt; 0) { wordIndex = patternTable[wordIndex - 1]; } else { wordIndex = 0; textIndex += 1; } } return -1; } 时间复杂度 因为算法中涉及两部分字符串的线性对比，其时间复杂度为两字符串长度之和，假设需要搜索的关键词长度为 k，总字符串长度为 m，则时间复杂度为 O(k+m)。 相关资源 The Knuth-Morris-Pratt Algorithm in my own words 来自 trekhleb/javascript-algorithms 仓库中的 KMP 实现 Knuth-Morris-Pratt algorithm" />
<link rel="canonical" href="http://localhost:4000/2019/04/24/%E7%90%86%E8%A7%A3-KMP-%E7%AE%97%E6%B3%95.html" />
<meta property="og:url" content="http://localhost:4000/2019/04/24/%E7%90%86%E8%A7%A3-KMP-%E7%AE%97%E6%B3%95.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-24T23:04:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/04/24/%E7%90%86%E8%A7%A3-KMP-%E7%AE%97%E6%B3%95.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/04/24/%E7%90%86%E8%A7%A3-KMP-%E7%AE%97%E6%B3%95.html"},"description":"理解 KMP 算法 KMP（The Knuth-Morris-Pratt Algorithm）算法用于字符串匹配，从字符串中找出给定的子字符串。但它并不是很好理解和掌握。而理解它概念中的部分匹配表，是理解 KMP 算法的关键。 这里的讨论绕开其背后晦涩难懂的逻辑，着重从其运用上来理解它。 字符串查找 比如从字符串 abcdef 中找出 abcdg 子字符串。 朴素的解法，我们可以这样做， 分别取出第一位进行匹配，如果相同再取出各自的第二位。 如果不同，则将索引后移一位，从总字符串第二位开始，重复步骤一。 这种朴素解法的弊端在于，每次匹配失败，索引只后移一位，有很多冗余操作，效率不高。 在进行第一轮匹配中，即索引为 0 时，我们能够匹配出前四个字符 abcd 是相等的，后面发现想要的 g 与真实的 e 不符，标志着索引为 0 的情况匹配失败，开始查看索引为 1 时，但因为我们在第一轮匹配中，已经知道了总字符串中前四个字符的长相，但还是需要重复地挨个进行匹配。 部分匹配表/Partial Match Table 以长度为 8 的字符串 abababca，为例，其部分匹配表格为： char: | a | b | a | b | a | b | c | a | index: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | value: | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 | 其中 value 行便是部分匹配表的值。 子集 对于上面示例字符串，假如我们观察第 index 为 2 的位置，那么我们得到了字符串的一个子集 aba，如果我们观察 index 为 7 的位置，那得到的是整个字符串，这点是很显然的。当我们观察的位置不同时，表示我们关注的字符串中的子集不同，因为子字符串发生了变化。 前缀 &amp; 后缀 对于给定的字符串，从末尾开始去掉一个或多个字符，剩下的部分都叫作该字符串的真前缀（Proper prefix），后面简称前缀。这里「真」不是「真·前缀」的意思，联想一下数学里面集合的「真子集」。比如 banana，其前缀有： b ba ban bana banan 同理，从首部开始，去掉一个或多个字条，剩下的部分是该字符串的真后缀（Proper suffix）。还是 banana，其后缀有： anana nana ana na a 部分匹配值 可以看到，所有前缀和后缀在数量上是对称的，那么我们可以从前缀中找出一个，与后缀进行匹配，先不关心做这个匹配的意义。以最开始的文本 abababca 为例。 假如我们观察 index 为 2 的位置，此时子字符串为 aba，其前后缀分别为： 前缀：a，ab 后缀：ba，a 将前缀依次在后缀中去匹配，这里前后缀列表中能够匹配上的只有 a 这个子字符串，其长度为 1，所以将这个观测结果填入表中记下来，与开始看到的部分匹配表吻合了。 再比如来观察 index 为 3 的位置，此时得到的子字符串为 abab，此时的前后缀为： 前缀：a，ab，aba 后缀：bab，ab，b 此时可观察出其匹配项为 ab，长度为 2，也与上面部分匹配表中的值吻合。 再比如来观察 index 为 5 的位置，此时子字符串为 ababab，前后缀为： 前缀：a，ab，aba，abab，ababa 后缀：babab，abab，bab，ab，b 然后拿前缀中每个元素与后缀中的元素进行匹配，最后找出有两个匹配项， ab abab 我们取长的这个 abab，其长度为 4。 所以现在再来看上面的部分匹配表，一是能理解其值是怎么来的，二是能理解其表示的意义，即，所有前缀与后缀的匹配项中长度最长的那一个的长度。 当我们继续，进行到 index 为 6 时，子字符串为 abababc，可以预见，前后缀中找不到匹配。因为所有前缀都不包含 c，而所有后缀都包含 c。所以此时部分匹配值为 0。 再继续就到字符串末尾了，即整个字符串 abababca。也可以预见，因为所有前缀都以 a 开始，并且所有后缀都以 a 结尾，所以此时的部分匹配值最少为 1。继续会发现，因为后面的后缀开始有 c 的加入，使得后缀都包含 ca，而前缀中能够包含 c 的只有 abababc，而该长度 7 与同等长度的后缀 bababca 不匹配。至此就可以得出结论，匹配结果就是 1，没有更长的匹配了。 部分匹配表的使用 利用上面的部分匹配值，我们在进行字符串查找时，不必每次失败后只移动一位，而是可以移动多位，去掉一些冗余的匹配。这里有个公式如下： If a partial match of length partial_match_length is found and table[partial_match_length] &gt; 1, we may skip ahead partial_match_length - table[partial_match_length - 1] characters. 如果匹配过程中，匹配到了部分值为 partial_match_length，即目前找出前 partial_match_length 个字符是匹配的，将这个长度减一作为部分匹配表格中的 index 代入，查找其对应的 value 即 table[partial_match_length-1]，那么我们可以向前移动的步长为 partial_match_length - table[partial_match_length - 1]。 下面是本文开始时的那个部分匹配表: char: | a | b | a | b | a | b | c | a | index: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | value: | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 | 假设需要从 bacbababaabcbab 中查找 abababca，根据上面的公式我们来走一遍。 首次匹配发生在总字符串的第二个字符， bacbababaabcbab | abababca 此时匹配的长度为 1，部分匹配表中索引为 1-1=0 的位置对应的部分匹配值为 0，所以我们可以向前移动的距离是 1-0 1。其实也相当于没有跳跃，就是正常的本次匹配失败，索引后移一位的情况。这里没有节省任何成本。 继续直到再次发生匹配，此时匹配到的情况如下： bacbababaabcbab ||||| abababca 现在匹配到的长度是 5，部分匹配表中 5-1=4 对应的部分匹配值为 3，所以我们可以向前移动 5-3=2，此时一下子就可以移动两位了。 上一次的位置 | 最新移动到的位置 | | bacbababaabcbab xx||| abababca 此时匹配到的长度为 3， 查找到 table[partial_match_length-1] 即 index 为 2 对应的值为 1，所以可向前移动的距离为 3-1=2。 bacbababaabcbab xx| abababca 此时我们需要查找的字符串其长度已经超出剩余可用来匹配的字符串了，所以可直接结束匹配，得到结论：没有查找到结果。 JavaScript 中的实现 以下是来自 trekhleb/javascript-algorithms 中 JavaScript 版本的 KMP 算法实现： /** * @see https://www.youtube.com/watch?v=GTJr8OvyEVQ * @param {string} word * @return {number[]} */ function buildPatternTable(word) { const patternTable = [0]; let prefixIndex = 0; let suffixIndex = 1; while (suffixIndex &lt; word.length) { if (word[prefixIndex] === word[suffixIndex]) { patternTable[suffixIndex] = prefixIndex + 1; suffixIndex += 1; prefixIndex += 1; } else if (prefixIndex === 0) { patternTable[suffixIndex] = 0; suffixIndex += 1; } else { prefixIndex = patternTable[prefixIndex - 1]; } } return patternTable; } /** * @param {string} text * @param {string} word * @return {number} */ export default function knuthMorrisPratt(text, word) { if (word.length === 0) { return 0; } let textIndex = 0; let wordIndex = 0; const patternTable = buildPatternTable(word); while (textIndex &lt; text.length) { if (text[textIndex] === word[wordIndex]) { // We&#39;ve found a match. if (wordIndex === word.length - 1) { return (textIndex - word.length) + 1; } wordIndex += 1; textIndex += 1; } else if (wordIndex &gt; 0) { wordIndex = patternTable[wordIndex - 1]; } else { wordIndex = 0; textIndex += 1; } } return -1; } 时间复杂度 因为算法中涉及两部分字符串的线性对比，其时间复杂度为两字符串长度之和，假设需要搜索的关键词长度为 k，总字符串长度为 m，则时间复杂度为 O(k+m)。 相关资源 The Knuth-Morris-Pratt Algorithm in my own words 来自 trekhleb/javascript-algorithms 仓库中的 KMP 实现 Knuth-Morris-Pratt algorithm","@type":"BlogPosting","headline":"理解 KMP 算法","dateModified":"2019-04-24T23:04:00+08:00","datePublished":"2019-04-24T23:04:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">理解 KMP 算法</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-04-24T23:04:00+08:00" itemprop="datePublished">Apr 24, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="理解-kmp-算法">理解 KMP 算法</h1>

<p><a href="https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm">KMP（The Knuth-Morris-Pratt Algorithm）</a>算法用于字符串匹配，从字符串中找出给定的子字符串。但它并不是很好理解和掌握。而理解它概念中的部分匹配表，是理解 KMP 算法的关键。</p>

<p>这里的讨论绕开其背后晦涩难懂的逻辑，着重从其运用上来理解它。</p>

<h2 id="字符串查找">字符串查找</h2>

<p>比如从字符串 <code class="language-plaintext highlighter-rouge">abcdef</code> 中找出 <code class="language-plaintext highlighter-rouge">abcdg</code> 子字符串。</p>

<p>朴素的解法，我们可以这样做，</p>

<ul>
  <li>分别取出第一位进行匹配，如果相同再取出各自的第二位。</li>
  <li>如果不同，则将索引后移一位，从总字符串第二位开始，重复步骤一。</li>
</ul>

<p>这种朴素解法的弊端在于，每次匹配失败，索引只后移一位，有很多冗余操作，效率不高。</p>

<p>在进行第一轮匹配中，即索引为 0 时，我们能够匹配出前四个字符 <code class="language-plaintext highlighter-rouge">abcd</code> 是相等的，后面发现想要的 <code class="language-plaintext highlighter-rouge">g</code> 与真实的 <code class="language-plaintext highlighter-rouge">e</code> 不符，标志着索引为 0 的情况匹配失败，开始查看索引为 1 时，但因为我们在第一轮匹配中，已经知道了总字符串中前四个字符的长相，但还是需要重复地挨个进行匹配。</p>

<h2 id="部分匹配表partial-match-table">部分匹配表/Partial Match Table</h2>

<p>以长度为 8 的字符串 <code class="language-plaintext highlighter-rouge">abababca</code>，为例，其部分匹配表格为：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char:  | a | b | a | b | a | b | c | a |
index: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 
value: | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 |
</code></pre></div></div>

<p>其中 <code class="language-plaintext highlighter-rouge">value</code> 行便是部分匹配表的值。</p>

<h3 id="子集">子集</h3>

<p>对于上面示例字符串，假如我们观察第 <code class="language-plaintext highlighter-rouge">index</code> 为 2 的位置，那么我们得到了字符串的一个子集 <code class="language-plaintext highlighter-rouge">aba</code>，如果我们观察 <code class="language-plaintext highlighter-rouge">index</code> 为 7 的位置，那得到的是整个字符串，这点是很显然的。当我们观察的位置不同时，表示我们关注的字符串中的子集不同，因为子字符串发生了变化。</p>

<h3 id="前缀--后缀">前缀 &amp; 后缀</h3>

<p>对于给定的字符串，从末尾开始去掉一个或多个字符，剩下的部分都叫作该字符串的<strong>真前缀（Proper prefix）</strong>，后面简称前缀。这里「真」不是「真·前缀」的意思，联想一下数学里面集合的「真子集」。比如 <code class="language-plaintext highlighter-rouge">banana</code>，其前缀有：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">b</code></li>
  <li><code class="language-plaintext highlighter-rouge">ba</code></li>
  <li><code class="language-plaintext highlighter-rouge">ban</code></li>
  <li><code class="language-plaintext highlighter-rouge">bana</code></li>
  <li><code class="language-plaintext highlighter-rouge">banan</code></li>
</ul>

<p>同理，从首部开始，去掉一个或多个字条，剩下的部分是该字符串的<strong>真后缀（Proper suffix）</strong>。还是 <code class="language-plaintext highlighter-rouge">banana</code>，其后缀有：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">anana</code></li>
  <li><code class="language-plaintext highlighter-rouge">nana</code></li>
  <li><code class="language-plaintext highlighter-rouge">ana</code></li>
  <li><code class="language-plaintext highlighter-rouge">na</code></li>
  <li><code class="language-plaintext highlighter-rouge">a</code></li>
</ul>

<h3 id="部分匹配值">部分匹配值</h3>

<p>可以看到，所有前缀和后缀在数量上是对称的，那么我们可以从前缀中找出一个，与后缀进行匹配，先不关心做这个匹配的意义。以最开始的文本 <code class="language-plaintext highlighter-rouge">abababca</code> 为例。</p>

<p>假如我们观察 <code class="language-plaintext highlighter-rouge">index</code> 为 2 的位置，此时子字符串为 <code class="language-plaintext highlighter-rouge">aba</code>，其前后缀分别为：</p>

<ul>
  <li>前缀：<code class="language-plaintext highlighter-rouge">a</code>，<code class="language-plaintext highlighter-rouge">ab</code></li>
  <li>后缀：<code class="language-plaintext highlighter-rouge">ba</code>，<code class="language-plaintext highlighter-rouge">a</code></li>
</ul>

<p>将前缀依次在后缀中去匹配，这里前后缀列表中能够匹配上的只有 <code class="language-plaintext highlighter-rouge">a</code> 这个子字符串，其长度为 1，所以将这个观测结果填入表中记下来，与开始看到的部分匹配表吻合了。</p>

<p>再比如来观察 <code class="language-plaintext highlighter-rouge">index</code> 为 3 的位置，此时得到的子字符串为 <code class="language-plaintext highlighter-rouge">abab</code>，此时的前后缀为：</p>

<ul>
  <li>前缀：<code class="language-plaintext highlighter-rouge">a</code>，<code class="language-plaintext highlighter-rouge">ab</code>，<code class="language-plaintext highlighter-rouge">aba</code></li>
  <li>后缀：<code class="language-plaintext highlighter-rouge">bab</code>，<code class="language-plaintext highlighter-rouge">ab</code>，<code class="language-plaintext highlighter-rouge">b</code></li>
</ul>

<p>此时可观察出其匹配项为 <code class="language-plaintext highlighter-rouge">ab</code>，长度为 2，也与上面部分匹配表中的值吻合。</p>

<p>再比如来观察 <code class="language-plaintext highlighter-rouge">index</code> 为 5 的位置，此时子字符串为 <code class="language-plaintext highlighter-rouge">ababab</code>，前后缀为：</p>

<ul>
  <li>前缀：<code class="language-plaintext highlighter-rouge">a</code>，<code class="language-plaintext highlighter-rouge">ab</code>，<code class="language-plaintext highlighter-rouge">aba</code>，<code class="language-plaintext highlighter-rouge">abab</code>，<code class="language-plaintext highlighter-rouge">ababa</code></li>
  <li>后缀：<code class="language-plaintext highlighter-rouge">babab</code>，<code class="language-plaintext highlighter-rouge">abab</code>，<code class="language-plaintext highlighter-rouge">bab</code>，<code class="language-plaintext highlighter-rouge">ab</code>，<code class="language-plaintext highlighter-rouge">b</code></li>
</ul>

<p>然后拿前缀中每个元素与后缀中的元素进行匹配，最后找出有两个匹配项，</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ab</code></li>
  <li><code class="language-plaintext highlighter-rouge">abab</code></li>
</ul>

<p>我们取长的这个 <code class="language-plaintext highlighter-rouge">abab</code>，其长度为 4。</p>

<p>所以现在再来看上面的部分匹配表，一是能理解其值是怎么来的，二是能理解其表示的意义，即，<strong>所有前缀与后缀的匹配项中长度最长的那一个的长度。</strong></p>

<p>当我们继续，进行到 <code class="language-plaintext highlighter-rouge">index</code> 为 6 时，子字符串为 <code class="language-plaintext highlighter-rouge">abababc</code>，可以预见，前后缀中找不到匹配。因为所有前缀都不包含 <code class="language-plaintext highlighter-rouge">c</code>，而所有后缀都包含 <code class="language-plaintext highlighter-rouge">c</code>。所以此时部分匹配值为 0。</p>

<p>再继续就到字符串末尾了，即整个字符串 <code class="language-plaintext highlighter-rouge">abababca</code>。也可以预见，因为所有前缀都以 <code class="language-plaintext highlighter-rouge">a</code> 开始，并且所有后缀都以 <code class="language-plaintext highlighter-rouge">a</code> 结尾，所以此时的部分匹配值最少为 1。继续会发现，因为后面的后缀开始有 <code class="language-plaintext highlighter-rouge">c</code> 的加入，使得后缀都包含 <code class="language-plaintext highlighter-rouge">ca</code>，而前缀中能够包含 <code class="language-plaintext highlighter-rouge">c</code> 的只有 <code class="language-plaintext highlighter-rouge">abababc</code>，而该长度 7 与同等长度的后缀 <code class="language-plaintext highlighter-rouge">bababca</code> 不匹配。至此就可以得出结论，匹配结果就是 1，没有更长的匹配了。</p>

<h2 id="部分匹配表的使用">部分匹配表的使用</h2>

<p>利用上面的部分匹配值，我们在进行字符串查找时，不必每次失败后只移动一位，而是可以移动多位，去掉一些冗余的匹配。这里有个公式如下：</p>

<blockquote>
  <p>If a partial match of length partial_match_length is found and table[partial_match_length] &gt; 1, we may skip ahead partial_match_length - table[partial_match_length - 1] characters.</p>
</blockquote>

<p>如果匹配过程中，匹配到了部分值为 <code class="language-plaintext highlighter-rouge">partial_match_length</code>，即目前找出前 <code class="language-plaintext highlighter-rouge">partial_match_length</code> 个字符是匹配的，将这个长度减一作为部分匹配表格中的 <code class="language-plaintext highlighter-rouge">index</code> 代入，查找其对应的 <code class="language-plaintext highlighter-rouge">value</code> 即 <code class="language-plaintext highlighter-rouge">table[partial_match_length-1]</code>，那么我们可以向前移动的步长为 <code class="language-plaintext highlighter-rouge">partial_match_length - table[partial_match_length - 1]</code>。</p>

<p>下面是本文开始时的那个部分匹配表:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char:  | a | b | a | b | a | b | c | a |
index: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 
value: | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 |
</code></pre></div></div>

<p>假设需要从 <code class="language-plaintext highlighter-rouge">bacbababaabcbab</code> 中查找 <code class="language-plaintext highlighter-rouge">abababca</code>，根据上面的公式我们来走一遍。</p>

<p>首次匹配发生在总字符串的第二个字符，</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bacbababaabcbab
 |
 abababca
</code></pre></div></div>

<p>此时匹配的长度为 1，部分匹配表中索引为 1-1=0 的位置对应的部分匹配值为 0，所以我们可以向前移动的距离是 <code class="language-plaintext highlighter-rouge">1-0</code> 1。其实也相当于没有跳跃，就是正常的本次匹配失败，索引后移一位的情况。这里没有节省任何成本。</p>

<p>继续直到再次发生匹配，此时匹配到的情况如下：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bacbababaabcbab
    <span class="o">||||</span>|
    abababca
</code></pre></div></div>

<p>现在匹配到的长度是 5，部分匹配表中 5-1=4 对应的部分匹配值为 3，所以我们可以向前移动 5-3=2，此时一下子就可以移动两位了。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    上一次的位置
    | 最新移动到的位置
    | |
bacbababaabcbab
    xx|||
      abababca
</code></pre></div></div>

<p>此时匹配到的长度为 3， 查找到 <code class="language-plaintext highlighter-rouge">table[partial_match_length-1]</code> 即 index 为 2 对应的值为 1，所以可向前移动的距离为 3-1=2。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bacbababaabcbab
      xx|
        abababca
</code></pre></div></div>

<p>此时我们需要查找的字符串其长度已经超出剩余可用来匹配的字符串了，所以可直接结束匹配，得到结论：没有查找到结果。</p>

<h2 id="javascript-中的实现">JavaScript 中的实现</h2>

<p>以下是来自 <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/knuth-morris-pratt/knuthMorrisPratt.js">trekhleb/javascript-algorithms</a> 中 JavaScript 版本的 KMP 算法实现：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @see https://www.youtube.com/watch?v=GTJr8OvyEVQ
 * @param {string} word
 * @return {number[]}
 */</span>
<span class="kd">function</span> <span class="nx">buildPatternTable</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">patternTable</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="kd">let</span> <span class="nx">prefixIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">suffixIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">suffixIndex</span> <span class="o">&lt;</span> <span class="nx">word</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">word</span><span class="p">[</span><span class="nx">prefixIndex</span><span class="p">]</span> <span class="o">===</span> <span class="nx">word</span><span class="p">[</span><span class="nx">suffixIndex</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">patternTable</span><span class="p">[</span><span class="nx">suffixIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">prefixIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">suffixIndex</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">prefixIndex</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">prefixIndex</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">patternTable</span><span class="p">[</span><span class="nx">suffixIndex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">suffixIndex</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">prefixIndex</span> <span class="o">=</span> <span class="nx">patternTable</span><span class="p">[</span><span class="nx">prefixIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">patternTable</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**
 * @param {string} text
 * @param {string} word
 * @return {number}
 */</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">knuthMorrisPratt</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">word</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">word</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">textIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">wordIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">patternTable</span> <span class="o">=</span> <span class="nx">buildPatternTable</span><span class="p">(</span><span class="nx">word</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">textIndex</span> <span class="o">&lt;</span> <span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">text</span><span class="p">[</span><span class="nx">textIndex</span><span class="p">]</span> <span class="o">===</span> <span class="nx">word</span><span class="p">[</span><span class="nx">wordIndex</span><span class="p">])</span> <span class="p">{</span>
      <span class="c1">// We've found a match.</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">wordIndex</span> <span class="o">===</span> <span class="nx">word</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="nx">textIndex</span> <span class="o">-</span> <span class="nx">word</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">wordIndex</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">textIndex</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">wordIndex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">wordIndex</span> <span class="o">=</span> <span class="nx">patternTable</span><span class="p">[</span><span class="nx">wordIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">wordIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">textIndex</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="时间复杂度">时间复杂度</h2>

<p>因为算法中涉及两部分字符串的线性对比，其时间复杂度为两字符串长度之和，假设需要搜索的关键词长度为 k，总字符串长度为 m，则时间复杂度为 O(k+m)。</p>

<h2 id="相关资源">相关资源</h2>

<ul>
  <li><a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/">The Knuth-Morris-Pratt Algorithm in my own words</a></li>
  <li><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/algorithms/string/knuth-morris-pratt/knuthMorrisPratt.js">来自 trekhleb/javascript-algorithms 仓库中的 KMP 实现</a></li>
  <li><a href="http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/kmpen.htm">Knuth-Morris-Pratt algorithm</a></li>
</ul>


  </div><a class="u-url" href="/2019/04/24/%E7%90%86%E8%A7%A3-KMP-%E7%AE%97%E6%B3%95.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
