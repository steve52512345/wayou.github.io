<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>命令行中的 vi 模式 | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="命令行中的 vi 模式" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="命令行中的 vi 模式 命令行中修改已经输入的命令比较麻烦，如果你不知道一些快捷键的话，只能使用方向键一个一个字符地移动到目标位置进行修改，对于比较复杂且过长的命令来说，效率不高。 以下信息来自 bash 的 man 页面： $ man bash # ... Commands for Moving beginning-of-line (C-a) Move to the start of the current line. end-of-line (C-e) Move to the end of the line. forward-char (C-f) Move forward a character. backward-char (C-b) Move back a character. forward-word (M-f) Move forward to the end of the next word. Words are composed of alphanu- meric characters (letters and digits). backward-word (M-b) Move back to the start of the current or previous word. Words are composed of alphanumeric characters (letters and digits). clear-screen (C-l) Clear the screen leaving the current line at the top of the screen. With an argument, refresh the current line without clearing the screen. redraw-current-line Refresh the current line. # ... 可看到 bash 本身提供了一些有用的快捷键可在命令中快速导航， control + a 定位到行首（start） control + e 定位到行末（end） control + f 向前移动一个单词（forward） control + b 向后移动一个单词（back） 移动光标，大部分情况下，我觉得记住这四个可以满足日常需求。 除了移动光标，还有一些编辑的快捷键，在 man 页面中 Killing and Yanking 部分， # ... Killing and Yanking kill-line (C-k) Kill the text from point to the end of the line. backward-kill-line (C-x Rubout) Kill backward to the beginning of the line. unix-line-discard (C-u) Kill backward from point to the beginning of the line. The killed text is saved on the kill-ring. kill-whole-line Kill all characters on the current line, no matter where point is. kill-word (M-d) Kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as those used by for- ward-word. backward-kill-word (M-Rubout) Kill the word behind point. Word boundaries are the same as those used by backward-word. unix-word-rubout (C-w) Kill the word behind point, using white space as a word boundary. The killed text is saved on the kill-ring. unix-filename-rubout Kill the word behind point, using white space and the slash character as the word boundaries. The killed text is saved on the kill-ring. delete-horizontal-space (M-\) Delete all spaces and tabs around point. kill-region Kill the text in the current region. copy-region-as-kill Copy the text in the region to the kill buffer. copy-backward-word Copy the word before point to the kill buffer. The word boundaries are the same as backward-word. copy-forward-word Copy the word following point to the kill buffer. The word boundaries are the same as forward-word. yank (C-y) Yank the top of the kill ring into the buffer at point. yank-pop (M-y) Rotate the kill ring, and yank the new top. Only works following yank or yank-pop. # ... 其中这一个我最常用： control + u 删除当前光标位置到行首的内容，配合着 control + e 把光标定位到行末再使用该命令，可实现清空整行的效果 除了这些快捷键，其实命令行还有个 vi 模式，该模式下的表现和在 vi 编辑器里一样，对于 vi 用户来说，进入这种模式后，编辑和修改命令就显得十分得心应手了。 开启 vi 模式 不同 shell 中开启的命令不一样，我比较偏好 fish，因为它的自动补全真的好用到无以复加。 运行 fish_vi_key_bindings 即可进入 vi 模式。 $ fish_vi_key_bindings 运行 fish_default_key_bindings 回到默认。 $ fish_default_key_bindings 命令行的 vi 模式演示 如果需要一直开始，可以配置文件中添加上述命令。 $ vi ~/.config/fish/config.fish # 其他代码 fish_vi_key_bindings 选择合适的主题 你可能需要一个可以在命令提示行中显示当前 vi 状态的主题。 推荐 fish 搭配 omf 使用 omf 中的主题。 fish 有默认的 vi 状态展示(indicator)，和主题很不搭配。 fish 默认的 vi 状态展示 需要手动去掉，配置文件中添加如下脚本： function fish_mode_prompt; end 修正 fish 中的自动补全 如果发现 vi 模式下， fish 的自动补全快捷键 control + f 不能用了，可在配置文件中添加如下脚本来修复这个快捷键： function fish_user_key_bindings for mode in insert default visual bind -M $mode \cf forward-char end end" />
<meta property="og:description" content="命令行中的 vi 模式 命令行中修改已经输入的命令比较麻烦，如果你不知道一些快捷键的话，只能使用方向键一个一个字符地移动到目标位置进行修改，对于比较复杂且过长的命令来说，效率不高。 以下信息来自 bash 的 man 页面： $ man bash # ... Commands for Moving beginning-of-line (C-a) Move to the start of the current line. end-of-line (C-e) Move to the end of the line. forward-char (C-f) Move forward a character. backward-char (C-b) Move back a character. forward-word (M-f) Move forward to the end of the next word. Words are composed of alphanu- meric characters (letters and digits). backward-word (M-b) Move back to the start of the current or previous word. Words are composed of alphanumeric characters (letters and digits). clear-screen (C-l) Clear the screen leaving the current line at the top of the screen. With an argument, refresh the current line without clearing the screen. redraw-current-line Refresh the current line. # ... 可看到 bash 本身提供了一些有用的快捷键可在命令中快速导航， control + a 定位到行首（start） control + e 定位到行末（end） control + f 向前移动一个单词（forward） control + b 向后移动一个单词（back） 移动光标，大部分情况下，我觉得记住这四个可以满足日常需求。 除了移动光标，还有一些编辑的快捷键，在 man 页面中 Killing and Yanking 部分， # ... Killing and Yanking kill-line (C-k) Kill the text from point to the end of the line. backward-kill-line (C-x Rubout) Kill backward to the beginning of the line. unix-line-discard (C-u) Kill backward from point to the beginning of the line. The killed text is saved on the kill-ring. kill-whole-line Kill all characters on the current line, no matter where point is. kill-word (M-d) Kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as those used by for- ward-word. backward-kill-word (M-Rubout) Kill the word behind point. Word boundaries are the same as those used by backward-word. unix-word-rubout (C-w) Kill the word behind point, using white space as a word boundary. The killed text is saved on the kill-ring. unix-filename-rubout Kill the word behind point, using white space and the slash character as the word boundaries. The killed text is saved on the kill-ring. delete-horizontal-space (M-\) Delete all spaces and tabs around point. kill-region Kill the text in the current region. copy-region-as-kill Copy the text in the region to the kill buffer. copy-backward-word Copy the word before point to the kill buffer. The word boundaries are the same as backward-word. copy-forward-word Copy the word following point to the kill buffer. The word boundaries are the same as forward-word. yank (C-y) Yank the top of the kill ring into the buffer at point. yank-pop (M-y) Rotate the kill ring, and yank the new top. Only works following yank or yank-pop. # ... 其中这一个我最常用： control + u 删除当前光标位置到行首的内容，配合着 control + e 把光标定位到行末再使用该命令，可实现清空整行的效果 除了这些快捷键，其实命令行还有个 vi 模式，该模式下的表现和在 vi 编辑器里一样，对于 vi 用户来说，进入这种模式后，编辑和修改命令就显得十分得心应手了。 开启 vi 模式 不同 shell 中开启的命令不一样，我比较偏好 fish，因为它的自动补全真的好用到无以复加。 运行 fish_vi_key_bindings 即可进入 vi 模式。 $ fish_vi_key_bindings 运行 fish_default_key_bindings 回到默认。 $ fish_default_key_bindings 命令行的 vi 模式演示 如果需要一直开始，可以配置文件中添加上述命令。 $ vi ~/.config/fish/config.fish # 其他代码 fish_vi_key_bindings 选择合适的主题 你可能需要一个可以在命令提示行中显示当前 vi 状态的主题。 推荐 fish 搭配 omf 使用 omf 中的主题。 fish 有默认的 vi 状态展示(indicator)，和主题很不搭配。 fish 默认的 vi 状态展示 需要手动去掉，配置文件中添加如下脚本： function fish_mode_prompt; end 修正 fish 中的自动补全 如果发现 vi 模式下， fish 的自动补全快捷键 control + f 不能用了，可在配置文件中添加如下脚本来修复这个快捷键： function fish_user_key_bindings for mode in insert default visual bind -M $mode \cf forward-char end end" />
<link rel="canonical" href="http://localhost:4000/2019/04/18/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84-vi-%E6%A8%A1%E5%BC%8F.html" />
<meta property="og:url" content="http://localhost:4000/2019/04/18/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84-vi-%E6%A8%A1%E5%BC%8F.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-18T23:04:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/04/18/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84-vi-%E6%A8%A1%E5%BC%8F.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/04/18/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84-vi-%E6%A8%A1%E5%BC%8F.html"},"description":"命令行中的 vi 模式 命令行中修改已经输入的命令比较麻烦，如果你不知道一些快捷键的话，只能使用方向键一个一个字符地移动到目标位置进行修改，对于比较复杂且过长的命令来说，效率不高。 以下信息来自 bash 的 man 页面： $ man bash # ... Commands for Moving beginning-of-line (C-a) Move to the start of the current line. end-of-line (C-e) Move to the end of the line. forward-char (C-f) Move forward a character. backward-char (C-b) Move back a character. forward-word (M-f) Move forward to the end of the next word. Words are composed of alphanu- meric characters (letters and digits). backward-word (M-b) Move back to the start of the current or previous word. Words are composed of alphanumeric characters (letters and digits). clear-screen (C-l) Clear the screen leaving the current line at the top of the screen. With an argument, refresh the current line without clearing the screen. redraw-current-line Refresh the current line. # ... 可看到 bash 本身提供了一些有用的快捷键可在命令中快速导航， control + a 定位到行首（start） control + e 定位到行末（end） control + f 向前移动一个单词（forward） control + b 向后移动一个单词（back） 移动光标，大部分情况下，我觉得记住这四个可以满足日常需求。 除了移动光标，还有一些编辑的快捷键，在 man 页面中 Killing and Yanking 部分， # ... Killing and Yanking kill-line (C-k) Kill the text from point to the end of the line. backward-kill-line (C-x Rubout) Kill backward to the beginning of the line. unix-line-discard (C-u) Kill backward from point to the beginning of the line. The killed text is saved on the kill-ring. kill-whole-line Kill all characters on the current line, no matter where point is. kill-word (M-d) Kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as those used by for- ward-word. backward-kill-word (M-Rubout) Kill the word behind point. Word boundaries are the same as those used by backward-word. unix-word-rubout (C-w) Kill the word behind point, using white space as a word boundary. The killed text is saved on the kill-ring. unix-filename-rubout Kill the word behind point, using white space and the slash character as the word boundaries. The killed text is saved on the kill-ring. delete-horizontal-space (M-\\) Delete all spaces and tabs around point. kill-region Kill the text in the current region. copy-region-as-kill Copy the text in the region to the kill buffer. copy-backward-word Copy the word before point to the kill buffer. The word boundaries are the same as backward-word. copy-forward-word Copy the word following point to the kill buffer. The word boundaries are the same as forward-word. yank (C-y) Yank the top of the kill ring into the buffer at point. yank-pop (M-y) Rotate the kill ring, and yank the new top. Only works following yank or yank-pop. # ... 其中这一个我最常用： control + u 删除当前光标位置到行首的内容，配合着 control + e 把光标定位到行末再使用该命令，可实现清空整行的效果 除了这些快捷键，其实命令行还有个 vi 模式，该模式下的表现和在 vi 编辑器里一样，对于 vi 用户来说，进入这种模式后，编辑和修改命令就显得十分得心应手了。 开启 vi 模式 不同 shell 中开启的命令不一样，我比较偏好 fish，因为它的自动补全真的好用到无以复加。 运行 fish_vi_key_bindings 即可进入 vi 模式。 $ fish_vi_key_bindings 运行 fish_default_key_bindings 回到默认。 $ fish_default_key_bindings 命令行的 vi 模式演示 如果需要一直开始，可以配置文件中添加上述命令。 $ vi ~/.config/fish/config.fish # 其他代码 fish_vi_key_bindings 选择合适的主题 你可能需要一个可以在命令提示行中显示当前 vi 状态的主题。 推荐 fish 搭配 omf 使用 omf 中的主题。 fish 有默认的 vi 状态展示(indicator)，和主题很不搭配。 fish 默认的 vi 状态展示 需要手动去掉，配置文件中添加如下脚本： function fish_mode_prompt; end 修正 fish 中的自动补全 如果发现 vi 模式下， fish 的自动补全快捷键 control + f 不能用了，可在配置文件中添加如下脚本来修复这个快捷键： function fish_user_key_bindings for mode in insert default visual bind -M $mode \\cf forward-char end end","@type":"BlogPosting","headline":"命令行中的 vi 模式","dateModified":"2019-04-18T23:04:00+08:00","datePublished":"2019-04-18T23:04:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">命令行中的 vi 模式</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-04-18T23:04:00+08:00" itemprop="datePublished">Apr 18, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="命令行中的-vi-模式">命令行中的 vi 模式</h1>

<p>命令行中修改已经输入的命令比较麻烦，如果你不知道一些快捷键的话，只能使用方向键一个一个字符地移动到目标位置进行修改，对于比较复杂且过长的命令来说，效率不高。</p>

<p>以下信息来自 bash 的 man 页面：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>man bash
<span class="c"># ...</span>

   Commands <span class="k">for </span>Moving
       beginning-of-line <span class="o">(</span>C-a<span class="o">)</span>
              Move to the start of the current line.
       end-of-line <span class="o">(</span>C-e<span class="o">)</span>
              Move to the end of the line.
       forward-char <span class="o">(</span>C-f<span class="o">)</span>
              Move forward a character.
       backward-char <span class="o">(</span>C-b<span class="o">)</span>
              Move back a character.
       forward-word <span class="o">(</span>M-f<span class="o">)</span>
              Move  forward  to  the end of the next word.  Words are composed of alphanu-
              meric characters <span class="o">(</span>letters and digits<span class="o">)</span><span class="nb">.</span>
       backward-word <span class="o">(</span>M-b<span class="o">)</span>
              Move back to the start of the current or previous word.  Words are  composed
              of alphanumeric characters <span class="o">(</span>letters and digits<span class="o">)</span><span class="nb">.</span>
       clear-screen <span class="o">(</span>C-l<span class="o">)</span>
              Clear the screen leaving the current line at the top of the screen.  With an
              argument, refresh the current line without clearing the screen.
       redraw-current-line
              Refresh the current line.

<span class="c"># ...</span>
</code></pre></div></div>

<p>可看到 bash 本身提供了一些有用的快捷键可在命令中快速导航，</p>

<ul>
  <li><kbd>control</kbd> + <kbd>a</kbd> 定位到行首（st<strong>a</strong>rt）</li>
  <li><kbd>control</kbd> + <kbd>e</kbd> 定位到行末（<strong>e</strong>nd）</li>
  <li><kbd>control</kbd> + <kbd>f</kbd> 向前移动一个单词（<strong>f</strong>orward）</li>
  <li><kbd>control</kbd> + <kbd>b</kbd> 向后移动一个单词（<strong>b</strong>ack）</li>
</ul>

<p>移动光标，大部分情况下，我觉得记住这四个可以满足日常需求。</p>

<p>除了移动光标，还有一些编辑的快捷键，在 man 页面中 Killing and Yanking 部分，</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ...</span>

   Killing and Yanking
       kill-line <span class="o">(</span>C-k<span class="o">)</span>
              Kill the text from point to the end of the line.
       backward-kill-line <span class="o">(</span>C-x Rubout<span class="o">)</span>
              Kill backward to the beginning of the line.
       unix-line-discard <span class="o">(</span>C-u<span class="o">)</span>
              Kill  backward  from point to the beginning of the line.  The killed text is
              saved on the kill-ring.
       kill-whole-line
              Kill all characters on the current line, no matter where point is.
       kill-word <span class="o">(</span>M-d<span class="o">)</span>
              Kill from point to the end of the current word, or <span class="k">if </span>between words, to  the
              end  of  the  next word.  Word boundaries are the same as those used by <span class="k">for</span>-
              ward-word.
       backward-kill-word <span class="o">(</span>M-Rubout<span class="o">)</span>
              Kill the word behind point.  Word boundaries are the same as those  used  by
              backward-word.
       unix-word-rubout <span class="o">(</span>C-w<span class="o">)</span>
              Kill  the  word  behind  point,  using  white space as a word boundary.  The
              killed text is saved on the kill-ring.
       unix-filename-rubout
              Kill the word behind point, using white space and the slash character as the
              word boundaries.  The killed text is saved on the kill-ring.
       delete-horizontal-space <span class="o">(</span>M-<span class="se">\)</span>
              Delete all spaces and tabs around point.
       kill-region
              Kill the text <span class="k">in </span>the current region.
       copy-region-as-kill
              Copy the text <span class="k">in </span>the region to the <span class="nb">kill </span>buffer.
       copy-backward-word
              Copy  the word before point to the <span class="nb">kill </span>buffer.  The word boundaries are the
              same as backward-word.
       copy-forward-word
              Copy the word following point to the <span class="nb">kill </span>buffer.  The word  boundaries  are
              the same as forward-word.
       yank <span class="o">(</span>C-y<span class="o">)</span>
              Yank the top of the <span class="nb">kill </span>ring into the buffer at point.
       yank-pop <span class="o">(</span>M-y<span class="o">)</span>
              Rotate  the  <span class="nb">kill  </span>ring, and yank the new top.  Only works following yank or
              yank-pop.

<span class="c"># ...</span>
</code></pre></div></div>

<p>其中这一个我最常用：</p>

<ul>
  <li><kbd>control</kbd> + <kbd>u</kbd> 删除当前光标位置到行首的内容，配合着 <kbd>control</kbd> + <kbd>e</kbd> 把光标定位到行末再使用该命令，可实现清空整行的效果</li>
</ul>

<p>除了这些快捷键，其实命令行还有个 vi 模式，该模式下的表现和在 vi 编辑器里一样，对于 vi 用户来说，进入这种模式后，编辑和修改命令就显得十分得心应手了。</p>

<h2 id="开启-vi-模式">开启 vi 模式</h2>

<p>不同 shell 中开启的命令不一样，我比较偏好 <a href="https://fishshell.com">fish</a>，因为它的自动补全真的好用到无以复加。</p>

<p>运行 <code class="language-plaintext highlighter-rouge">fish_vi_key_bindings</code> 即可进入 vi 模式。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>fish_vi_key_bindings
</code></pre></div></div>

<p>运行 <code class="language-plaintext highlighter-rouge">fish_default_key_bindings</code> 回到默认。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>fish_default_key_bindings
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/3783096/56299503-bf90b100-6166-11e9-8c1f-d103a7be9af2.gif" alt="命令行的 vi 模式演示" /></p>
<p align="center">命令行的 vi 模式演示</p>

<p>如果需要一直开始，可以配置文件中添加上述命令。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>vi ~/.config/fish/config.fish

<span class="c"># 其他代码</span>
fish_vi_key_bindings

</code></pre></div></div>

<h2 id="选择合适的主题">选择合适的主题</h2>

<p>你可能需要一个可以在命令提示行中显示当前  vi  状态的主题。</p>

<p>推荐 fish 搭配 omf 使用 omf 中的<a href="https://github.com/oh-my-fish/oh-my-fish/blob/master/docs/Themes.md">主题</a>。</p>

<p>fish 有默认的 vi 状态展示(indicator)，和主题很不搭配。</p>

<p><img src="https://user-images.githubusercontent.com/3783096/56299552-dafbbc00-6166-11e9-8120-6d67820d85d8.png" alt="fish 默认的 vi 状态展示" /></p>
<p align="center">fish 默认的 vi 状态展示</p>

<p>需要手动去掉，配置文件中添加如下脚本：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function </span>fish_mode_prompt<span class="p">;</span> end
</code></pre></div></div>

<h2 id="修正-fish-中的自动补全">修正 fish 中的自动补全</h2>

<p>如果发现 vi 模式下， fish 的自动补全快捷键 <kbd>control</kbd> + <kbd>f</kbd> 不能用了，可在配置文件中添加如下脚本来修复这个快捷键：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function </span>fish_user_key_bindings
    <span class="k">for </span>mode <span class="k">in </span>insert default visual
        <span class="nb">bind</span> <span class="nt">-M</span> <span class="nv">$mode</span> <span class="se">\c</span>f forward-char
    end
end
</code></pre></div></div>


  </div><a class="u-url" href="/2019/04/18/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84-vi-%E6%A8%A1%E5%BC%8F.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
