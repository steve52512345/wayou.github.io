<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>TypeScript this 入参 | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="TypeScript this 入参" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="TypeScript this 入参 考察下面的示例代码： class MyClass { constructor(protected foo: string) {} @MyDecorator bar() { console.log(&quot;bar&quot;); } } function MyDecorator( _target: any, _key: string, descriptor: PropertyDescriptor ) { const original = descriptor.value; descriptor.value = function(...args: any[]) { // 🚨Property &#39;foo&#39; does not exist on type &#39;PropertyDescriptor&#39;.ts(2339) console.log(this.foo); return original.apply(this, args); }; return descriptor; } const myClass = new MyClass(&quot;erm&quot;); myClass.bar(); 上面代码定义了一个类 MyClass，包含一个 protected 类型的 foo 属性。 同时定义了一个 MyDecorator 装饰器，在被装饰方法调用前访问上面的 protected foo 属性并且打印出来。 可以看到上面示例中，已经将 TypeScript 报错标识了出来，可以看到此时 this 所指的对象其实不对，指向了 PropertyDescriptor，所以在装饰器中试图访问 protected foo 时提示没有 foo 属性。 首先我们需要修正一下 this 的类型，因为该装饰器修饰的是类的方法，所以 descriptor.value 中 this 应该是被修饰方法所在的类才对。 function MyDecorator( _target: any, _key: string, descriptor: PropertyDescriptor ) { const original = descriptor.value; descriptor.value = function(...args: any[]) { // 🚨Property &#39;foo&#39; does not exist on type &#39;PropertyDescriptor&#39;.ts(2339) console.log((this as MyClass).foo); return original.apply(this, args); }; return descriptor; } 当我们试图通过强制类型转换修正 this 的类型时，发现新的错误出现了。因为 foo 被声明成了 protected 类型，它提示只能在 MyClass 中或其继承类中访问该属性。但我们明确知道，运行时 descriptor.value 确实是在这个类当中的。同时 Hover 到强制类型转换后的 this 上发现其类型还是 PropertyDescriptor，说明强制类型转换其实没生效。 强制类型转换失败 this 入参 对于这种需要修正函数中 this 所指的场景，TypeScript 提供了一种机制，可以在函数入参列表中第一个位置处，手动写入 this 标识其类型。但这个 this 入参只作为一个形式上的参数，供 TypeScript 做静态检查时使用，编译后是不会存在于真实代码中的。 function f(this: void) { // make sure `this` is unusable in this standalone function } 像上面这样，f 被指定了 this 类型为 void，即 f 这个函数的函数体内，不允许使用 this。这有什么用呢，请看以下示例： interface UIElement { addClickListener(onclick: (this: void, e: Event) =&gt; void): void; } class Handler { constructor(public info: string) {} onClickBad(this: Handler, e: Event) { this.info = e.type; } } let h = new Handler(&#39;foo&#39;); // 🚨error uiElement.addClickListener(h.onClickBad); 上面 uiElement.addClickListener 声明了只接收一个不依赖于 this 上下文的函数做为回调，但我们传入的 h.onClickBad 声明为它执行时依赖于 Handler 这个上下文。因此显式地修正函数的执行上下文可让 TypeScript 检查出相关的错误。 回到文章开头的示例，我们就知道如何修正它了。 只需要将设置 descriptor.value 地方，为其添加上 this 入参即可保证正确的上下文了。 function MyDecorator( _target: any, _key: string, descriptor: PropertyDescriptor ) { const original = descriptor.value; - descriptor.value = function(..args: any[]) { + descriptor.value = function(this: MyClass, ...args: any[]) { console.log((this as MyClass).foo); return original.apply(this, args); }; return descriptor; } 相关资源 TypeScript Handbook - Functions#this parameters" />
<meta property="og:description" content="TypeScript this 入参 考察下面的示例代码： class MyClass { constructor(protected foo: string) {} @MyDecorator bar() { console.log(&quot;bar&quot;); } } function MyDecorator( _target: any, _key: string, descriptor: PropertyDescriptor ) { const original = descriptor.value; descriptor.value = function(...args: any[]) { // 🚨Property &#39;foo&#39; does not exist on type &#39;PropertyDescriptor&#39;.ts(2339) console.log(this.foo); return original.apply(this, args); }; return descriptor; } const myClass = new MyClass(&quot;erm&quot;); myClass.bar(); 上面代码定义了一个类 MyClass，包含一个 protected 类型的 foo 属性。 同时定义了一个 MyDecorator 装饰器，在被装饰方法调用前访问上面的 protected foo 属性并且打印出来。 可以看到上面示例中，已经将 TypeScript 报错标识了出来，可以看到此时 this 所指的对象其实不对，指向了 PropertyDescriptor，所以在装饰器中试图访问 protected foo 时提示没有 foo 属性。 首先我们需要修正一下 this 的类型，因为该装饰器修饰的是类的方法，所以 descriptor.value 中 this 应该是被修饰方法所在的类才对。 function MyDecorator( _target: any, _key: string, descriptor: PropertyDescriptor ) { const original = descriptor.value; descriptor.value = function(...args: any[]) { // 🚨Property &#39;foo&#39; does not exist on type &#39;PropertyDescriptor&#39;.ts(2339) console.log((this as MyClass).foo); return original.apply(this, args); }; return descriptor; } 当我们试图通过强制类型转换修正 this 的类型时，发现新的错误出现了。因为 foo 被声明成了 protected 类型，它提示只能在 MyClass 中或其继承类中访问该属性。但我们明确知道，运行时 descriptor.value 确实是在这个类当中的。同时 Hover 到强制类型转换后的 this 上发现其类型还是 PropertyDescriptor，说明强制类型转换其实没生效。 强制类型转换失败 this 入参 对于这种需要修正函数中 this 所指的场景，TypeScript 提供了一种机制，可以在函数入参列表中第一个位置处，手动写入 this 标识其类型。但这个 this 入参只作为一个形式上的参数，供 TypeScript 做静态检查时使用，编译后是不会存在于真实代码中的。 function f(this: void) { // make sure `this` is unusable in this standalone function } 像上面这样，f 被指定了 this 类型为 void，即 f 这个函数的函数体内，不允许使用 this。这有什么用呢，请看以下示例： interface UIElement { addClickListener(onclick: (this: void, e: Event) =&gt; void): void; } class Handler { constructor(public info: string) {} onClickBad(this: Handler, e: Event) { this.info = e.type; } } let h = new Handler(&#39;foo&#39;); // 🚨error uiElement.addClickListener(h.onClickBad); 上面 uiElement.addClickListener 声明了只接收一个不依赖于 this 上下文的函数做为回调，但我们传入的 h.onClickBad 声明为它执行时依赖于 Handler 这个上下文。因此显式地修正函数的执行上下文可让 TypeScript 检查出相关的错误。 回到文章开头的示例，我们就知道如何修正它了。 只需要将设置 descriptor.value 地方，为其添加上 this 入参即可保证正确的上下文了。 function MyDecorator( _target: any, _key: string, descriptor: PropertyDescriptor ) { const original = descriptor.value; - descriptor.value = function(..args: any[]) { + descriptor.value = function(this: MyClass, ...args: any[]) { console.log((this as MyClass).foo); return original.apply(this, args); }; return descriptor; } 相关资源 TypeScript Handbook - Functions#this parameters" />
<link rel="canonical" href="http://localhost:4000/2019/06/19/TypeScript-this-%E5%85%A5%E5%8F%82.html" />
<meta property="og:url" content="http://localhost:4000/2019/06/19/TypeScript-this-%E5%85%A5%E5%8F%82.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-19T23:06:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/06/19/TypeScript-this-%E5%85%A5%E5%8F%82.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/06/19/TypeScript-this-%E5%85%A5%E5%8F%82.html"},"description":"TypeScript this 入参 考察下面的示例代码： class MyClass { constructor(protected foo: string) {} @MyDecorator bar() { console.log(&quot;bar&quot;); } } function MyDecorator( _target: any, _key: string, descriptor: PropertyDescriptor ) { const original = descriptor.value; descriptor.value = function(...args: any[]) { // 🚨Property &#39;foo&#39; does not exist on type &#39;PropertyDescriptor&#39;.ts(2339) console.log(this.foo); return original.apply(this, args); }; return descriptor; } const myClass = new MyClass(&quot;erm&quot;); myClass.bar(); 上面代码定义了一个类 MyClass，包含一个 protected 类型的 foo 属性。 同时定义了一个 MyDecorator 装饰器，在被装饰方法调用前访问上面的 protected foo 属性并且打印出来。 可以看到上面示例中，已经将 TypeScript 报错标识了出来，可以看到此时 this 所指的对象其实不对，指向了 PropertyDescriptor，所以在装饰器中试图访问 protected foo 时提示没有 foo 属性。 首先我们需要修正一下 this 的类型，因为该装饰器修饰的是类的方法，所以 descriptor.value 中 this 应该是被修饰方法所在的类才对。 function MyDecorator( _target: any, _key: string, descriptor: PropertyDescriptor ) { const original = descriptor.value; descriptor.value = function(...args: any[]) { // 🚨Property &#39;foo&#39; does not exist on type &#39;PropertyDescriptor&#39;.ts(2339) console.log((this as MyClass).foo); return original.apply(this, args); }; return descriptor; } 当我们试图通过强制类型转换修正 this 的类型时，发现新的错误出现了。因为 foo 被声明成了 protected 类型，它提示只能在 MyClass 中或其继承类中访问该属性。但我们明确知道，运行时 descriptor.value 确实是在这个类当中的。同时 Hover 到强制类型转换后的 this 上发现其类型还是 PropertyDescriptor，说明强制类型转换其实没生效。 强制类型转换失败 this 入参 对于这种需要修正函数中 this 所指的场景，TypeScript 提供了一种机制，可以在函数入参列表中第一个位置处，手动写入 this 标识其类型。但这个 this 入参只作为一个形式上的参数，供 TypeScript 做静态检查时使用，编译后是不会存在于真实代码中的。 function f(this: void) { // make sure `this` is unusable in this standalone function } 像上面这样，f 被指定了 this 类型为 void，即 f 这个函数的函数体内，不允许使用 this。这有什么用呢，请看以下示例： interface UIElement { addClickListener(onclick: (this: void, e: Event) =&gt; void): void; } class Handler { constructor(public info: string) {} onClickBad(this: Handler, e: Event) { this.info = e.type; } } let h = new Handler(&#39;foo&#39;); // 🚨error uiElement.addClickListener(h.onClickBad); 上面 uiElement.addClickListener 声明了只接收一个不依赖于 this 上下文的函数做为回调，但我们传入的 h.onClickBad 声明为它执行时依赖于 Handler 这个上下文。因此显式地修正函数的执行上下文可让 TypeScript 检查出相关的错误。 回到文章开头的示例，我们就知道如何修正它了。 只需要将设置 descriptor.value 地方，为其添加上 this 入参即可保证正确的上下文了。 function MyDecorator( _target: any, _key: string, descriptor: PropertyDescriptor ) { const original = descriptor.value; - descriptor.value = function(..args: any[]) { + descriptor.value = function(this: MyClass, ...args: any[]) { console.log((this as MyClass).foo); return original.apply(this, args); }; return descriptor; } 相关资源 TypeScript Handbook - Functions#this parameters","@type":"BlogPosting","headline":"TypeScript this 入参","dateModified":"2019-06-19T23:06:00+08:00","datePublished":"2019-06-19T23:06:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">TypeScript `this` 入参</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-06-19T23:06:00+08:00" itemprop="datePublished">Jun 19, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="typescript-this-入参">TypeScript <code class="language-plaintext highlighter-rouge">this</code> 入参</h1>

<p>考察下面的示例代码：</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="k">protected</span> <span class="nx">foo</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{}</span>

  <span class="p">@</span><span class="nd">MyDecorator</span>
  <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">MyDecorator</span><span class="p">(</span>
  <span class="nx">_target</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span>
  <span class="nx">_key</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
  <span class="nx">descriptor</span><span class="p">:</span> <span class="nx">PropertyDescriptor</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">original</span> <span class="o">=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(...</span><span class="nx">args</span><span class="p">:</span> <span class="kr">any</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// 🚨Property 'foo' does not exist on type 'PropertyDescriptor'.ts(2339)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">foo</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">original</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="nx">descriptor</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">myClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">(</span><span class="dl">"</span><span class="s2">erm</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">myClass</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span>

</code></pre></div></div>

<p>上面代码定义了一个类 <code class="language-plaintext highlighter-rouge">MyClass</code>，包含一个 <code class="language-plaintext highlighter-rouge">protected</code> 类型的 <code class="language-plaintext highlighter-rouge">foo</code> 属性。</p>

<p>同时定义了一个 <code class="language-plaintext highlighter-rouge">MyDecorator</code> 装饰器，在被装饰方法调用前访问上面的 <code class="language-plaintext highlighter-rouge">protected foo</code> 属性并且打印出来。</p>

<p>可以看到上面示例中，已经将 TypeScript 报错标识了出来，可以看到此时 <code class="language-plaintext highlighter-rouge">this</code> 所指的对象其实不对，指向了 <code class="language-plaintext highlighter-rouge">PropertyDescriptor</code>，所以在装饰器中试图访问 <code class="language-plaintext highlighter-rouge">protected foo</code> 时提示没有 <code class="language-plaintext highlighter-rouge">foo</code> 属性。</p>

<p>首先我们需要修正一下 <code class="language-plaintext highlighter-rouge">this</code> 的类型，因为该装饰器修饰的是类的方法，所以 <code class="language-plaintext highlighter-rouge">descriptor.value</code> 中 <code class="language-plaintext highlighter-rouge">this</code> 应该是被修饰方法所在的类才对。</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">function MyDecorator(
</span>  _target: any,
  _key: string,
  descriptor: PropertyDescriptor
<span class="err">)</span> {
  const original = descriptor.value;
  descriptor.value = function(...args: any[]) {
    // 🚨Property 'foo' does not exist on type 'PropertyDescriptor'.ts(2339)
    console.log((this as MyClass).foo);
    return original.apply(this, args);
  };
  return descriptor;
<span class="err">}</span>
</code></pre></div></div>

<p>当我们试图通过强制类型转换修正 <code class="language-plaintext highlighter-rouge">this</code> 的类型时，发现新的错误出现了。因为 <code class="language-plaintext highlighter-rouge">foo</code> 被声明成了 <code class="language-plaintext highlighter-rouge">protected</code> 类型，它提示只能在 <code class="language-plaintext highlighter-rouge">MyClass</code> 中或其继承类中访问该属性。但我们明确知道，运行时 <code class="language-plaintext highlighter-rouge">descriptor.value</code> 确实是在这个类当中的。同时 Hover 到强制类型转换后的 <code class="language-plaintext highlighter-rouge">this</code> 上发现其类型还是 <code class="language-plaintext highlighter-rouge">PropertyDescriptor</code>，说明强制类型转换其实没生效。</p>

<p><img src="https://user-images.githubusercontent.com/3783096/59554334-0a4a7000-8fd4-11e9-8c18-24493f082544.png" alt="强制类型转换失败" /></p>
<p align="center">强制类型转换失败</p>

<h2 id="this-入参"><code class="language-plaintext highlighter-rouge">this</code> 入参</h2>

<p>对于这种需要修正函数中 <code class="language-plaintext highlighter-rouge">this</code> 所指的场景，TypeScript 提供了一种机制，可以在函数入参列表中第一个位置处，手动写入 <code class="language-plaintext highlighter-rouge">this</code> 标识其类型。但这个 <code class="language-plaintext highlighter-rouge">this</code> 入参只作为一个形式上的参数，供 TypeScript 做静态检查时使用，编译后是不会存在于真实代码中的。</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="k">this</span><span class="p">:</span> <span class="k">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// make sure `this` is unusable in this standalone function</span>
<span class="p">}</span>
</code></pre></div></div>

<p>像上面这样，<code class="language-plaintext highlighter-rouge">f</code> 被指定了 <code class="language-plaintext highlighter-rouge">this</code> 类型为 <code class="language-plaintext highlighter-rouge">void</code>，即 <code class="language-plaintext highlighter-rouge">f</code> 这个函数的函数体内，不允许使用 <code class="language-plaintext highlighter-rouge">this</code>。这有什么用呢，请看以下示例：</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">UIElement</span> <span class="p">{</span>
  <span class="nx">addClickListener</span><span class="p">(</span><span class="nx">onclick</span><span class="p">:</span> <span class="p">(</span><span class="k">this</span><span class="p">:</span> <span class="k">void</span><span class="p">,</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">Event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">):</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nx">Handler</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">info</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{}</span>
  <span class="nx">onClickBad</span><span class="p">(</span><span class="k">this</span><span class="p">:</span> <span class="nx">Handler</span><span class="p">,</span> <span class="nx">e</span><span class="p">:</span> <span class="nx">Event</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">info</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="kd">type</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">h</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Handler</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// 🚨error</span>
<span class="nx">uiElement</span><span class="p">.</span><span class="nx">addClickListener</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">onClickBad</span><span class="p">);</span> 
</code></pre></div></div>

<p>上面 <code class="language-plaintext highlighter-rouge">uiElement.addClickListener</code> 声明了只接收一个不依赖于 <code class="language-plaintext highlighter-rouge">this</code> 上下文的函数做为回调，但我们传入的 <code class="language-plaintext highlighter-rouge">h.onClickBad</code> 声明为它执行时依赖于 <code class="language-plaintext highlighter-rouge">Handler</code> 这个上下文。因此显式地修正函数的执行上下文可让 TypeScript 检查出相关的错误。</p>

<p>回到文章开头的示例，我们就知道如何修正它了。</p>

<p>只需要将设置 <code class="language-plaintext highlighter-rouge">descriptor.value</code> 地方，为其添加上 <code class="language-plaintext highlighter-rouge">this</code> 入参即可保证正确的上下文了。</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">function MyDecorator(
</span>  _target: any,
  _key: string,
  descriptor: PropertyDescriptor
<span class="err">)</span> {
  const original = descriptor.value;
<span class="gd">-  descriptor.value = function(..args: any[]) {
</span><span class="gi">+  descriptor.value = function(this: MyClass, ...args: any[]) {
</span>    console.log((this as MyClass).foo);
    return original.apply(this, args);
  };
  return descriptor;
<span class="err">}</span>
</code></pre></div></div>

<h2 id="相关资源">相关资源</h2>

<ul>
  <li><a href="https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters">TypeScript Handbook  - Functions#this parameters</a></li>
</ul>


  </div><a class="u-url" href="/2019/06/19/TypeScript-this-%E5%85%A5%E5%8F%82.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
