<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>React controlled 及 uncontrolled 组件 | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="React controlled 及 uncontrolled 组件" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="React controlled 及 uncontrolled 组件 通过 props 来设置其 value 值的组件便是一种 controlled 组件。典型的 form 表单中，像 输入框 &lt;input&gt; 下拉框 &lt;select&gt; 多选框 &lt;input type=&quot;checkbox&quot;&gt; 单选框 &lt;input type=&quot;radio&quot;&gt; 文本框 &lt;textarea&gt; 这些，都可通过 props 来设置初始值，同时通过监听其身上的 onChanges 事件来将最新的值回传到 React 中。这样，组件的值便始终与 React 中的状态是同步的。 class Form extends Component { constructor() { super(); this.state = { name: &#39;&#39;, }; } handleNameChange = (event) =&gt; { this.setState({ name: event.target.value }); }; render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={this.state.name} onChange={this.handleNameChange} /&gt; &lt;/div&gt; ); } } 如上， controlled 类型的组件需要在组件中有对应的 state 来保存相应的值。同时需要为组件编写值更新后的监听逻辑。 对应的 uncontrolled 类型，便方便得多，它其实就是普通的 HTML 标签。 对于 uncontrolled 类型的组件，通过 ref 来获取它身上的 value 值。 class Form extends Component { handleSubmitClick = () =&gt; { const name = this._name.value; // do something with `name` } render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref={input =&gt; this._name = input} /&gt; &lt;button onClick={this.handleSubmitClick}&gt;Sign up&lt;/button&gt; &lt;/div&gt; ); } } 可以看出，uncontorlled 类型的组件，其值是存储在 DOM 节点上的，在需要的时候，比如表单提交时，再通过 ref 获取到相应的 DOM 节点取出它的值。 对比之下，controlled 类型的组件是时实地将最新的值推送（push）到 React 中，而 uncontrolled 类型的组件是在需要的时候去拉取（pull）它身上的值。 对比与取舍 虽然 ref 在官方文档中是不推荐的，也不代表说 uncontrolled 类型的组件就不能使用；虽然 controlled 类型的组件这种，数据走 state 更新和维护的方式，更加 React 一点，也不是说在编写表单时就需要全部使用 controlled 类型的组件。两者在不同情况下可以自由取舍，完全看需要。 controlled 类型的组件虽然写起来会比较麻烦，其值与 React state 始终同步，所以有一些优点， 很方便地对用户输入的值进行校验，然后展示相应的错误信息。 可以时实地格式化用的输入，对于特定类型的值比如信用卡，手机等。 根据用户的填写情况时实将表单的提交按钮禁用或启用。 所以如果需要上述这些东西，可以考虑 controlled 类型来编写组件，而 uncontrolled 类型代码上写起来很简洁点，少了 state 及事件绑定，可用在功能简单，或者 React 快速上手，快速实现功能的场景。 相关资源 Forms Uncontrolled Components Controlled and uncontrolled form inputs in React don’t have to be complicated" />
<meta property="og:description" content="React controlled 及 uncontrolled 组件 通过 props 来设置其 value 值的组件便是一种 controlled 组件。典型的 form 表单中，像 输入框 &lt;input&gt; 下拉框 &lt;select&gt; 多选框 &lt;input type=&quot;checkbox&quot;&gt; 单选框 &lt;input type=&quot;radio&quot;&gt; 文本框 &lt;textarea&gt; 这些，都可通过 props 来设置初始值，同时通过监听其身上的 onChanges 事件来将最新的值回传到 React 中。这样，组件的值便始终与 React 中的状态是同步的。 class Form extends Component { constructor() { super(); this.state = { name: &#39;&#39;, }; } handleNameChange = (event) =&gt; { this.setState({ name: event.target.value }); }; render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={this.state.name} onChange={this.handleNameChange} /&gt; &lt;/div&gt; ); } } 如上， controlled 类型的组件需要在组件中有对应的 state 来保存相应的值。同时需要为组件编写值更新后的监听逻辑。 对应的 uncontrolled 类型，便方便得多，它其实就是普通的 HTML 标签。 对于 uncontrolled 类型的组件，通过 ref 来获取它身上的 value 值。 class Form extends Component { handleSubmitClick = () =&gt; { const name = this._name.value; // do something with `name` } render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref={input =&gt; this._name = input} /&gt; &lt;button onClick={this.handleSubmitClick}&gt;Sign up&lt;/button&gt; &lt;/div&gt; ); } } 可以看出，uncontorlled 类型的组件，其值是存储在 DOM 节点上的，在需要的时候，比如表单提交时，再通过 ref 获取到相应的 DOM 节点取出它的值。 对比之下，controlled 类型的组件是时实地将最新的值推送（push）到 React 中，而 uncontrolled 类型的组件是在需要的时候去拉取（pull）它身上的值。 对比与取舍 虽然 ref 在官方文档中是不推荐的，也不代表说 uncontrolled 类型的组件就不能使用；虽然 controlled 类型的组件这种，数据走 state 更新和维护的方式，更加 React 一点，也不是说在编写表单时就需要全部使用 controlled 类型的组件。两者在不同情况下可以自由取舍，完全看需要。 controlled 类型的组件虽然写起来会比较麻烦，其值与 React state 始终同步，所以有一些优点， 很方便地对用户输入的值进行校验，然后展示相应的错误信息。 可以时实地格式化用的输入，对于特定类型的值比如信用卡，手机等。 根据用户的填写情况时实将表单的提交按钮禁用或启用。 所以如果需要上述这些东西，可以考虑 controlled 类型来编写组件，而 uncontrolled 类型代码上写起来很简洁点，少了 state 及事件绑定，可用在功能简单，或者 React 快速上手，快速实现功能的场景。 相关资源 Forms Uncontrolled Components Controlled and uncontrolled form inputs in React don’t have to be complicated" />
<link rel="canonical" href="http://localhost:4000/2019/06/11/React-controlled-%E5%8F%8A-uncontrolled-%E7%BB%84%E4%BB%B6.html" />
<meta property="og:url" content="http://localhost:4000/2019/06/11/React-controlled-%E5%8F%8A-uncontrolled-%E7%BB%84%E4%BB%B6.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-11T23:06:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/06/11/React-controlled-%E5%8F%8A-uncontrolled-%E7%BB%84%E4%BB%B6.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/06/11/React-controlled-%E5%8F%8A-uncontrolled-%E7%BB%84%E4%BB%B6.html"},"description":"React controlled 及 uncontrolled 组件 通过 props 来设置其 value 值的组件便是一种 controlled 组件。典型的 form 表单中，像 输入框 &lt;input&gt; 下拉框 &lt;select&gt; 多选框 &lt;input type=&quot;checkbox&quot;&gt; 单选框 &lt;input type=&quot;radio&quot;&gt; 文本框 &lt;textarea&gt; 这些，都可通过 props 来设置初始值，同时通过监听其身上的 onChanges 事件来将最新的值回传到 React 中。这样，组件的值便始终与 React 中的状态是同步的。 class Form extends Component { constructor() { super(); this.state = { name: &#39;&#39;, }; } handleNameChange = (event) =&gt; { this.setState({ name: event.target.value }); }; render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={this.state.name} onChange={this.handleNameChange} /&gt; &lt;/div&gt; ); } } 如上， controlled 类型的组件需要在组件中有对应的 state 来保存相应的值。同时需要为组件编写值更新后的监听逻辑。 对应的 uncontrolled 类型，便方便得多，它其实就是普通的 HTML 标签。 对于 uncontrolled 类型的组件，通过 ref 来获取它身上的 value 值。 class Form extends Component { handleSubmitClick = () =&gt; { const name = this._name.value; // do something with `name` } render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref={input =&gt; this._name = input} /&gt; &lt;button onClick={this.handleSubmitClick}&gt;Sign up&lt;/button&gt; &lt;/div&gt; ); } } 可以看出，uncontorlled 类型的组件，其值是存储在 DOM 节点上的，在需要的时候，比如表单提交时，再通过 ref 获取到相应的 DOM 节点取出它的值。 对比之下，controlled 类型的组件是时实地将最新的值推送（push）到 React 中，而 uncontrolled 类型的组件是在需要的时候去拉取（pull）它身上的值。 对比与取舍 虽然 ref 在官方文档中是不推荐的，也不代表说 uncontrolled 类型的组件就不能使用；虽然 controlled 类型的组件这种，数据走 state 更新和维护的方式，更加 React 一点，也不是说在编写表单时就需要全部使用 controlled 类型的组件。两者在不同情况下可以自由取舍，完全看需要。 controlled 类型的组件虽然写起来会比较麻烦，其值与 React state 始终同步，所以有一些优点， 很方便地对用户输入的值进行校验，然后展示相应的错误信息。 可以时实地格式化用的输入，对于特定类型的值比如信用卡，手机等。 根据用户的填写情况时实将表单的提交按钮禁用或启用。 所以如果需要上述这些东西，可以考虑 controlled 类型来编写组件，而 uncontrolled 类型代码上写起来很简洁点，少了 state 及事件绑定，可用在功能简单，或者 React 快速上手，快速实现功能的场景。 相关资源 Forms Uncontrolled Components Controlled and uncontrolled form inputs in React don’t have to be complicated","@type":"BlogPosting","headline":"React controlled 及 uncontrolled 组件","dateModified":"2019-06-11T23:06:00+08:00","datePublished":"2019-06-11T23:06:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">React `controlled` 及 `uncontrolled` 组件</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-06-11T23:06:00+08:00" itemprop="datePublished">Jun 11, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="react-controlled-及-uncontrolled-组件">React <code class="language-plaintext highlighter-rouge">controlled</code> 及 <code class="language-plaintext highlighter-rouge">uncontrolled</code> 组件</h1>

<p>通过 <code class="language-plaintext highlighter-rouge">props</code> 来设置其 <code class="language-plaintext highlighter-rouge">value</code> 值的组件便是一种 <code class="language-plaintext highlighter-rouge">controlled</code> 组件。典型的 form 表单中，像</p>

<ul>
  <li>输入框 <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code></li>
  <li>下拉框 <code class="language-plaintext highlighter-rouge">&lt;select&gt;</code></li>
  <li>多选框 <code class="language-plaintext highlighter-rouge">&lt;input type="checkbox"&gt;</code></li>
  <li>单选框 <code class="language-plaintext highlighter-rouge">&lt;input type="radio"&gt;</code></li>
  <li>文本框 <code class="language-plaintext highlighter-rouge">&lt;textarea&gt;</code></li>
</ul>

<p>这些，都可通过 <code class="language-plaintext highlighter-rouge">props</code> 来设置初始值，同时通过监听其身上的 <code class="language-plaintext highlighter-rouge">onChanges</code> 事件来将最新的值回传到 React 中。这样，组件的值便始终与 React 中的状态是同步的。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Form</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">name</span><span class="p">:</span> <span class="dl">''</span><span class="p">,</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="nx">handleNameChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span> <span class="p">});</span>
  <span class="p">};</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">input</span>
          <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span>
          <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span>
          <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleNameChange</span><span class="p">}</span>
        <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如上， <code class="language-plaintext highlighter-rouge">controlled</code> 类型的组件需要在组件中有对应的 <code class="language-plaintext highlighter-rouge">state</code> 来保存相应的值。同时需要为组件编写值更新后的监听逻辑。</p>

<p>对应的 <code class="language-plaintext highlighter-rouge">uncontrolled</code> 类型，便方便得多，它其实就是普通的 HTML 标签。</p>

<p>对于 <code class="language-plaintext highlighter-rouge">uncontrolled</code> 类型的组件，通过 ref 来获取它身上的 <code class="language-plaintext highlighter-rouge">value</code> 值。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Form</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">handleSubmitClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="c1">// do something with `name`</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">input</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="nx">input</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleSubmitClick</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Sign</span> <span class="nx">up</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看出，<code class="language-plaintext highlighter-rouge">uncontorlled</code> 类型的组件，其值是存储在 DOM 节点上的，在需要的时候，比如表单提交时，再通过 ref 获取到相应的 DOM 节点取出它的值。</p>

<p>对比之下，<code class="language-plaintext highlighter-rouge">controlled</code> 类型的组件是时实地将最新的值推送（push）到 React 中，而 <code class="language-plaintext highlighter-rouge">uncontrolled</code> 类型的组件是在需要的时候去拉取（pull）它身上的值。</p>

<h2 id="对比与取舍">对比与取舍</h2>

<p>虽然 <code class="language-plaintext highlighter-rouge">ref</code> 在官方文档中是不推荐的，也不代表说 <code class="language-plaintext highlighter-rouge">uncontrolled</code> 类型的组件就不能使用；虽然 <code class="language-plaintext highlighter-rouge">controlled</code> 类型的组件这种，数据走 state 更新和维护的方式，更加 React 一点，也不是说在编写表单时就需要全部使用 <code class="language-plaintext highlighter-rouge">controlled</code> 类型的组件。两者在不同情况下可以自由取舍，完全看需要。</p>

<p><code class="language-plaintext highlighter-rouge">controlled</code> 类型的组件虽然写起来会比较麻烦，其值与 React state 始终同步，所以有一些优点，</p>

<ul>
  <li>很方便地对用户输入的值进行校验，然后展示相应的错误信息。</li>
  <li>可以时实地格式化用的输入，对于特定类型的值比如信用卡，手机等。</li>
  <li>根据用户的填写情况时实将表单的提交按钮禁用或启用。</li>
</ul>

<p>所以如果需要上述这些东西，可以考虑 <code class="language-plaintext highlighter-rouge">controlled</code> 类型来编写组件，而 <code class="language-plaintext highlighter-rouge">uncontrolled</code> 类型代码上写起来很简洁点，少了 state 及事件绑定，可用在功能简单，或者 React 快速上手，快速实现功能的场景。</p>

<h2 id="相关资源">相关资源</h2>

<ul>
  <li><a href="https://reactjs.org/docs/forms.html">Forms</a></li>
  <li><a href="https://reactjs.org/docs/uncontrolled-components.html">Uncontrolled Components</a></li>
  <li><a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/">Controlled and uncontrolled form inputs in React don’t have to be complicated</a></li>
</ul>


  </div><a class="u-url" href="/2019/06/11/React-controlled-%E5%8F%8A-uncontrolled-%E7%BB%84%E4%BB%B6.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
