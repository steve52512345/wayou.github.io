<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Node.js 中的 stream | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Node.js 中的 stream" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Nod.js 中的 stream 什么是 stream Stream 借鉴自 Unix 编程哲学中的 pipe。 Unix shell 命令中，管道式的操作 | 将上一个命令的输出作为下一个命令的输入。Node.js stream 中则是通过 .pip() 方法来进行的。 来看一个 stream 的运用场景：从服务器读取文件并返回给页面。 朴素的实现： var http = require(&#39;http&#39;); var fs = require(&#39;fs&#39;); var server = http.createServer(function (req, res) { fs.readFile(__dirname + &#39;/data.txt&#39;, function (err, data) { res.end(data); }); }); server.listen(8000); stream 实现： var http = require(&#39;http&#39;); var fs = require(&#39;fs&#39;); var server = http.createServer(function (req, res) { var stream = fs.createReadStream(__dirname + &#39;/data.txt&#39;); stream.pipe(res); }); server.listen(8000); 好处： 代码更加简洁。 可自由组合各种模块来处理数据。 stream 的种类 分五种： readable writable duplex transform classic readable readable 类型的流产生的数据，可通过 .pip() 输送到能够消费（consume）流数据的地方，比如 writable，transform，duplex 类型的对象。 一个 readable stream 示例： var Readable = require(&#39;stream&#39;).Readable; var rs = new Readable; rs.push(&#39;beep &#39;); rs.push(&#39;boop\n&#39;); rs.push(null); rs.pipe(process.stdout); 运行结果： $ node read0.js beep boop _read 方法与按需输出 上面 rs.push(null) 表示没有更多数据了。直接将数据塞入到 readable 流中，然后被缓冲起来，直到被消费（示例中消费方为 process.stdout，即输出到命令行。）。因为消费者有可能并不能立即消费这些内容，直接 push 数据后会消耗不必要的资源。 更好的做法是，让 readable 流只在消费者需要数据的时候再 push。这是通过定义能 raedable 对象定义 ._read 方法来完成的。 var Readable = require(&#39;stream&#39;).Readable; var rs = Readable(); var c = 97; rs._read = function () { rs.push(String.fromCharCode(c++)); if (c &gt; &#39;z&#39;.charCodeAt(0)) rs.push(null); }; rs.pipe(process.stdout); 运行结果： $ node read1.js abcdefghijklmnopqrstuvwxyz 这种方式下，定义了 readable 流产生数据的方法 ._read，但并没有马上执行并输出数据，而是在 process.stdout 读取时，才调用输出的。 _read 方法可动态接收一个可选的 size 参数，由消费方指定一次读取想要多少字节的数据，当然，_read 方法的实现中是可以忽略这个入参的。 下面的示例可证明 _read 方法是消费方调用的时候才执行的，而不是主动执行。 var Readable = require(&#39;stream&#39;).Readable; var rs = Readable(); var c = 97 - 1; rs._read = function () { if (c &gt;= &#39;z&#39;.charCodeAt(0)) return rs.push(null); setTimeout(function () { rs.push(String.fromCharCode(++c)); }, 100); }; rs.pipe(process.stdout); process.on(&#39;exit&#39;, function () { console.error(&#39;\n_read() called &#39; + (c - 97) + &#39; times&#39;); }); process.stdout.on(&#39;error&#39;, process.exit); 输出任意数据 上面展示的是输出简单字符串，如果需要输出其他复杂数据，初始化时设置上正确的 objectMode 参数，Readable({ objectMode: true }) 消费 readable 流产生的数据 一般情况下， 我们会将 readable 产生的数据直接传递给其他的消费方，比如 through 或 concat-stream 创建的流对象。但直接操作来自 readable 的数据也是可以的。 process.stdin.on(&#39;readable&#39;, function () { var buf = process.stdin.read(); console.dir(buf); }); 上面的示例代码中，监听了来自命令行的输入，有数据时 stdin readable 事件便会触发，然后可通过调用 read() 方法获取到数据。数据结束时 read() 返回 null 表示没有更多数据了。 $ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume0.js &lt;Buffer 61 62 63 0a&gt; &lt;Buffer 64 65 66 0a&gt; &lt;Buffer 67 68 69 0a&gt; null 同时 read() 方法支持传递一个 size 指定一次获取多少的字节（bytes）。比如一次只获取 3 字节的数据： process.stdin.on(&#39;readable&#39;, function () { var buf = process.stdin.read(3); console.dir(buf); }); 这将导致我们获取到的数据是不完整的，因为指定了尺寸后，超出的部分是拿不到的。 $ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume1.js &lt;Buffer 61 62 63&gt; &lt;Buffer 0a 64 65&gt; &lt;Buffer 66 0a 67&gt; 此时可通过调用 read(0) 告诉 Node.js 我们不希望丢弃超出的部分。这样超出的部分会在后面的读取中陆续输出。 process.stdin.on(&#39;readable&#39;, function () { var buf = process.stdin.read(3); console.dir(buf); + process.stdin.read(0); }); $ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume2.js &lt;Buffer 61 62 63&gt; &lt;Buffer **0a** 64 65&gt; &lt;Buffer 66 **0a** 67&gt; &lt;Buffer 68 69 **0a**&gt; 除了调用 read(0)，还可调用 unshift() 方法将多余数据放回去。这样下次 read() 的时候数据都还在。比如一个解析换行的示例，遇到换行时将本行输出，剩下的数据塞回，以在下一行处理时使用。 var offset = 0; process.stdin.on(&#39;readable&#39;, function () { var buf = process.stdin.read(); if (!buf) return; for (; offset &lt; buf.length; offset++) { if (buf[offset] === 0x0a) { console.dir(buf.slice(0, offset).toString()); buf = buf.slice(offset + 1); offset = 0; process.stdin.unshift(buf); return; } } process.stdin.unshift(buf); }); $ tail -n +50000 /usr/share/dict/american-english | head -n10 | node lines.js &#39;hearties&#39; &#39;heartiest&#39; &#39;heartily&#39; &#39;heartiness&#39; &#39;heartiness\&#39;s&#39; &#39;heartland&#39; &#39;heartland\&#39;s&#39; &#39;heartlands&#39; &#39;heartless&#39; &#39;heartlessly&#39; writable 流 writable 流可作为 .pip() 的对象。 src.pipe(writableStream) 创建 writable 流 需要实现 ._write(chunk, enc, next) 方法，其中： chunk 为接收到的数据 enc 当 opts.decodeString 为 false 且收到的数据这字符串时，它表示字符串的编码 next(err) 数据处理后的回调，可传递一个错误信息以表示数据处理失败 默认情况下，获取到的字符串数据会转为 Buffer，可设置 Writable({ decodeStrings: false }) 来获取字符串数据。 一个 writable 示例： var Writable = require(&#39;stream&#39;).Writable; var ws = Writable(); ws._write = function (chunk, enc, next) { console.dir(chunk); next(); }; process.stdin.pipe(ws); 向 writable 流写入数据 通过调用 writable 流的 write 方法来写入。 process.stdout.write(&#39;beep boop\n&#39;); 通过调用 end() 来结束数据的写入。 var fs = require(&#39;fs&#39;); var ws = fs.createWriteStream(&#39;message.txt&#39;); ws.write(&#39;beep &#39;); setTimeout(function () { ws.end(&#39;boop\n&#39;); }, 1000); duplex 双工类型的流，同时具有 writable 和 readable 流的功能。Node.js 内建的 zlib,TCP sockets 以及 crypto 都是双工类型的。 所以可对双工类型的流进行如下操作： a.pip(b).pip(a) transform 一种特殊类型的双工流，区别在于 transform 类型其输出是输入的转换。跟它的名字一样，这里面对数据进行一些转换后输出。比如，通过 zlib.createGzip 来对数据进行 gzip 的压缩。有时候也将这种类型的流称为 through steam。 classic stream 这里指使用旧版 api 的流。当一个流身上绑定了 data 事件的监听时，便会回退为经典旧版的流。 classic readable stream 当有数据时它会派发 data 事件，数据输出结束时派发 end 事件给消费者。 .pipe() 通过检查 stream.readable 以判断该流是否是 readable 类型。 classic readable 流的创建 一个 classic readable 流的创建示例： var Stream = require(&#39;stream&#39;); var stream = new Stream; stream.readable = true; var c = 64; var iv = setInterval(function () { if (++c &gt;= 75) { clearInterval(iv); stream.emit(&#39;end&#39;); } else stream.emit(&#39;data&#39;, String.fromCharCode(c)); }, 100); stream.pipe(process.stdout); 从 classic readable 流读取数据 数据读取是通过监听流上的 data 与 end 事件。 一个从 classic readable 流读取数据的示例： process.stdin.on(&#39;data&#39;, function (buf) { console.log(buf); }); process.stdin.on(&#39;end&#39;, function () { console.log(&#39;__END__&#39;); }); 一般不建议通过这种方式来操作，一旦给流绑定 data 事件处理器，即回退到旧的 api 来使用流。如果真的有兼容操作旧版流的需求，应该通过 through 或 concat-stream 来进行。 classic writable stream 只需要实现 .write(buf), .end(buf) 及 .destroy() 方法即可，比较简单。 内建的流对象 总结 本质上，所有流都是 EventEmitter，通过事件可写入和读取数据。但通过新的 stream api，可方便地通过 .pipe() 方法来使用流而不是事件的方式。 使用 stream 可显著提高程序性能，特别是处理数据量大的情况下。它可以将数据分片处理，而不是粗暴地将数据看作一个整体。但掌握并熟练是需要一定时间练习的。 参考 stream handbook Node.js Streams: Everything you need to know core stream documentation perguth/node-streams" />
<meta property="og:description" content="Nod.js 中的 stream 什么是 stream Stream 借鉴自 Unix 编程哲学中的 pipe。 Unix shell 命令中，管道式的操作 | 将上一个命令的输出作为下一个命令的输入。Node.js stream 中则是通过 .pip() 方法来进行的。 来看一个 stream 的运用场景：从服务器读取文件并返回给页面。 朴素的实现： var http = require(&#39;http&#39;); var fs = require(&#39;fs&#39;); var server = http.createServer(function (req, res) { fs.readFile(__dirname + &#39;/data.txt&#39;, function (err, data) { res.end(data); }); }); server.listen(8000); stream 实现： var http = require(&#39;http&#39;); var fs = require(&#39;fs&#39;); var server = http.createServer(function (req, res) { var stream = fs.createReadStream(__dirname + &#39;/data.txt&#39;); stream.pipe(res); }); server.listen(8000); 好处： 代码更加简洁。 可自由组合各种模块来处理数据。 stream 的种类 分五种： readable writable duplex transform classic readable readable 类型的流产生的数据，可通过 .pip() 输送到能够消费（consume）流数据的地方，比如 writable，transform，duplex 类型的对象。 一个 readable stream 示例： var Readable = require(&#39;stream&#39;).Readable; var rs = new Readable; rs.push(&#39;beep &#39;); rs.push(&#39;boop\n&#39;); rs.push(null); rs.pipe(process.stdout); 运行结果： $ node read0.js beep boop _read 方法与按需输出 上面 rs.push(null) 表示没有更多数据了。直接将数据塞入到 readable 流中，然后被缓冲起来，直到被消费（示例中消费方为 process.stdout，即输出到命令行。）。因为消费者有可能并不能立即消费这些内容，直接 push 数据后会消耗不必要的资源。 更好的做法是，让 readable 流只在消费者需要数据的时候再 push。这是通过定义能 raedable 对象定义 ._read 方法来完成的。 var Readable = require(&#39;stream&#39;).Readable; var rs = Readable(); var c = 97; rs._read = function () { rs.push(String.fromCharCode(c++)); if (c &gt; &#39;z&#39;.charCodeAt(0)) rs.push(null); }; rs.pipe(process.stdout); 运行结果： $ node read1.js abcdefghijklmnopqrstuvwxyz 这种方式下，定义了 readable 流产生数据的方法 ._read，但并没有马上执行并输出数据，而是在 process.stdout 读取时，才调用输出的。 _read 方法可动态接收一个可选的 size 参数，由消费方指定一次读取想要多少字节的数据，当然，_read 方法的实现中是可以忽略这个入参的。 下面的示例可证明 _read 方法是消费方调用的时候才执行的，而不是主动执行。 var Readable = require(&#39;stream&#39;).Readable; var rs = Readable(); var c = 97 - 1; rs._read = function () { if (c &gt;= &#39;z&#39;.charCodeAt(0)) return rs.push(null); setTimeout(function () { rs.push(String.fromCharCode(++c)); }, 100); }; rs.pipe(process.stdout); process.on(&#39;exit&#39;, function () { console.error(&#39;\n_read() called &#39; + (c - 97) + &#39; times&#39;); }); process.stdout.on(&#39;error&#39;, process.exit); 输出任意数据 上面展示的是输出简单字符串，如果需要输出其他复杂数据，初始化时设置上正确的 objectMode 参数，Readable({ objectMode: true }) 消费 readable 流产生的数据 一般情况下， 我们会将 readable 产生的数据直接传递给其他的消费方，比如 through 或 concat-stream 创建的流对象。但直接操作来自 readable 的数据也是可以的。 process.stdin.on(&#39;readable&#39;, function () { var buf = process.stdin.read(); console.dir(buf); }); 上面的示例代码中，监听了来自命令行的输入，有数据时 stdin readable 事件便会触发，然后可通过调用 read() 方法获取到数据。数据结束时 read() 返回 null 表示没有更多数据了。 $ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume0.js &lt;Buffer 61 62 63 0a&gt; &lt;Buffer 64 65 66 0a&gt; &lt;Buffer 67 68 69 0a&gt; null 同时 read() 方法支持传递一个 size 指定一次获取多少的字节（bytes）。比如一次只获取 3 字节的数据： process.stdin.on(&#39;readable&#39;, function () { var buf = process.stdin.read(3); console.dir(buf); }); 这将导致我们获取到的数据是不完整的，因为指定了尺寸后，超出的部分是拿不到的。 $ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume1.js &lt;Buffer 61 62 63&gt; &lt;Buffer 0a 64 65&gt; &lt;Buffer 66 0a 67&gt; 此时可通过调用 read(0) 告诉 Node.js 我们不希望丢弃超出的部分。这样超出的部分会在后面的读取中陆续输出。 process.stdin.on(&#39;readable&#39;, function () { var buf = process.stdin.read(3); console.dir(buf); + process.stdin.read(0); }); $ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume2.js &lt;Buffer 61 62 63&gt; &lt;Buffer **0a** 64 65&gt; &lt;Buffer 66 **0a** 67&gt; &lt;Buffer 68 69 **0a**&gt; 除了调用 read(0)，还可调用 unshift() 方法将多余数据放回去。这样下次 read() 的时候数据都还在。比如一个解析换行的示例，遇到换行时将本行输出，剩下的数据塞回，以在下一行处理时使用。 var offset = 0; process.stdin.on(&#39;readable&#39;, function () { var buf = process.stdin.read(); if (!buf) return; for (; offset &lt; buf.length; offset++) { if (buf[offset] === 0x0a) { console.dir(buf.slice(0, offset).toString()); buf = buf.slice(offset + 1); offset = 0; process.stdin.unshift(buf); return; } } process.stdin.unshift(buf); }); $ tail -n +50000 /usr/share/dict/american-english | head -n10 | node lines.js &#39;hearties&#39; &#39;heartiest&#39; &#39;heartily&#39; &#39;heartiness&#39; &#39;heartiness\&#39;s&#39; &#39;heartland&#39; &#39;heartland\&#39;s&#39; &#39;heartlands&#39; &#39;heartless&#39; &#39;heartlessly&#39; writable 流 writable 流可作为 .pip() 的对象。 src.pipe(writableStream) 创建 writable 流 需要实现 ._write(chunk, enc, next) 方法，其中： chunk 为接收到的数据 enc 当 opts.decodeString 为 false 且收到的数据这字符串时，它表示字符串的编码 next(err) 数据处理后的回调，可传递一个错误信息以表示数据处理失败 默认情况下，获取到的字符串数据会转为 Buffer，可设置 Writable({ decodeStrings: false }) 来获取字符串数据。 一个 writable 示例： var Writable = require(&#39;stream&#39;).Writable; var ws = Writable(); ws._write = function (chunk, enc, next) { console.dir(chunk); next(); }; process.stdin.pipe(ws); 向 writable 流写入数据 通过调用 writable 流的 write 方法来写入。 process.stdout.write(&#39;beep boop\n&#39;); 通过调用 end() 来结束数据的写入。 var fs = require(&#39;fs&#39;); var ws = fs.createWriteStream(&#39;message.txt&#39;); ws.write(&#39;beep &#39;); setTimeout(function () { ws.end(&#39;boop\n&#39;); }, 1000); duplex 双工类型的流，同时具有 writable 和 readable 流的功能。Node.js 内建的 zlib,TCP sockets 以及 crypto 都是双工类型的。 所以可对双工类型的流进行如下操作： a.pip(b).pip(a) transform 一种特殊类型的双工流，区别在于 transform 类型其输出是输入的转换。跟它的名字一样，这里面对数据进行一些转换后输出。比如，通过 zlib.createGzip 来对数据进行 gzip 的压缩。有时候也将这种类型的流称为 through steam。 classic stream 这里指使用旧版 api 的流。当一个流身上绑定了 data 事件的监听时，便会回退为经典旧版的流。 classic readable stream 当有数据时它会派发 data 事件，数据输出结束时派发 end 事件给消费者。 .pipe() 通过检查 stream.readable 以判断该流是否是 readable 类型。 classic readable 流的创建 一个 classic readable 流的创建示例： var Stream = require(&#39;stream&#39;); var stream = new Stream; stream.readable = true; var c = 64; var iv = setInterval(function () { if (++c &gt;= 75) { clearInterval(iv); stream.emit(&#39;end&#39;); } else stream.emit(&#39;data&#39;, String.fromCharCode(c)); }, 100); stream.pipe(process.stdout); 从 classic readable 流读取数据 数据读取是通过监听流上的 data 与 end 事件。 一个从 classic readable 流读取数据的示例： process.stdin.on(&#39;data&#39;, function (buf) { console.log(buf); }); process.stdin.on(&#39;end&#39;, function () { console.log(&#39;__END__&#39;); }); 一般不建议通过这种方式来操作，一旦给流绑定 data 事件处理器，即回退到旧的 api 来使用流。如果真的有兼容操作旧版流的需求，应该通过 through 或 concat-stream 来进行。 classic writable stream 只需要实现 .write(buf), .end(buf) 及 .destroy() 方法即可，比较简单。 内建的流对象 总结 本质上，所有流都是 EventEmitter，通过事件可写入和读取数据。但通过新的 stream api，可方便地通过 .pipe() 方法来使用流而不是事件的方式。 使用 stream 可显著提高程序性能，特别是处理数据量大的情况下。它可以将数据分片处理，而不是粗暴地将数据看作一个整体。但掌握并熟练是需要一定时间练习的。 参考 stream handbook Node.js Streams: Everything you need to know core stream documentation perguth/node-streams" />
<link rel="canonical" href="http://localhost:4000/2019/03/31/Node.js-%E4%B8%AD%E7%9A%84-stream.html" />
<meta property="og:url" content="http://localhost:4000/2019/03/31/Node.js-%E4%B8%AD%E7%9A%84-stream.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-31T14:03:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/03/31/Node.js-%E4%B8%AD%E7%9A%84-stream.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/03/31/Node.js-%E4%B8%AD%E7%9A%84-stream.html"},"description":"Nod.js 中的 stream 什么是 stream Stream 借鉴自 Unix 编程哲学中的 pipe。 Unix shell 命令中，管道式的操作 | 将上一个命令的输出作为下一个命令的输入。Node.js stream 中则是通过 .pip() 方法来进行的。 来看一个 stream 的运用场景：从服务器读取文件并返回给页面。 朴素的实现： var http = require(&#39;http&#39;); var fs = require(&#39;fs&#39;); var server = http.createServer(function (req, res) { fs.readFile(__dirname + &#39;/data.txt&#39;, function (err, data) { res.end(data); }); }); server.listen(8000); stream 实现： var http = require(&#39;http&#39;); var fs = require(&#39;fs&#39;); var server = http.createServer(function (req, res) { var stream = fs.createReadStream(__dirname + &#39;/data.txt&#39;); stream.pipe(res); }); server.listen(8000); 好处： 代码更加简洁。 可自由组合各种模块来处理数据。 stream 的种类 分五种： readable writable duplex transform classic readable readable 类型的流产生的数据，可通过 .pip() 输送到能够消费（consume）流数据的地方，比如 writable，transform，duplex 类型的对象。 一个 readable stream 示例： var Readable = require(&#39;stream&#39;).Readable; var rs = new Readable; rs.push(&#39;beep &#39;); rs.push(&#39;boop\\n&#39;); rs.push(null); rs.pipe(process.stdout); 运行结果： $ node read0.js beep boop _read 方法与按需输出 上面 rs.push(null) 表示没有更多数据了。直接将数据塞入到 readable 流中，然后被缓冲起来，直到被消费（示例中消费方为 process.stdout，即输出到命令行。）。因为消费者有可能并不能立即消费这些内容，直接 push 数据后会消耗不必要的资源。 更好的做法是，让 readable 流只在消费者需要数据的时候再 push。这是通过定义能 raedable 对象定义 ._read 方法来完成的。 var Readable = require(&#39;stream&#39;).Readable; var rs = Readable(); var c = 97; rs._read = function () { rs.push(String.fromCharCode(c++)); if (c &gt; &#39;z&#39;.charCodeAt(0)) rs.push(null); }; rs.pipe(process.stdout); 运行结果： $ node read1.js abcdefghijklmnopqrstuvwxyz 这种方式下，定义了 readable 流产生数据的方法 ._read，但并没有马上执行并输出数据，而是在 process.stdout 读取时，才调用输出的。 _read 方法可动态接收一个可选的 size 参数，由消费方指定一次读取想要多少字节的数据，当然，_read 方法的实现中是可以忽略这个入参的。 下面的示例可证明 _read 方法是消费方调用的时候才执行的，而不是主动执行。 var Readable = require(&#39;stream&#39;).Readable; var rs = Readable(); var c = 97 - 1; rs._read = function () { if (c &gt;= &#39;z&#39;.charCodeAt(0)) return rs.push(null); setTimeout(function () { rs.push(String.fromCharCode(++c)); }, 100); }; rs.pipe(process.stdout); process.on(&#39;exit&#39;, function () { console.error(&#39;\\n_read() called &#39; + (c - 97) + &#39; times&#39;); }); process.stdout.on(&#39;error&#39;, process.exit); 输出任意数据 上面展示的是输出简单字符串，如果需要输出其他复杂数据，初始化时设置上正确的 objectMode 参数，Readable({ objectMode: true }) 消费 readable 流产生的数据 一般情况下， 我们会将 readable 产生的数据直接传递给其他的消费方，比如 through 或 concat-stream 创建的流对象。但直接操作来自 readable 的数据也是可以的。 process.stdin.on(&#39;readable&#39;, function () { var buf = process.stdin.read(); console.dir(buf); }); 上面的示例代码中，监听了来自命令行的输入，有数据时 stdin readable 事件便会触发，然后可通过调用 read() 方法获取到数据。数据结束时 read() 返回 null 表示没有更多数据了。 $ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume0.js &lt;Buffer 61 62 63 0a&gt; &lt;Buffer 64 65 66 0a&gt; &lt;Buffer 67 68 69 0a&gt; null 同时 read() 方法支持传递一个 size 指定一次获取多少的字节（bytes）。比如一次只获取 3 字节的数据： process.stdin.on(&#39;readable&#39;, function () { var buf = process.stdin.read(3); console.dir(buf); }); 这将导致我们获取到的数据是不完整的，因为指定了尺寸后，超出的部分是拿不到的。 $ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume1.js &lt;Buffer 61 62 63&gt; &lt;Buffer 0a 64 65&gt; &lt;Buffer 66 0a 67&gt; 此时可通过调用 read(0) 告诉 Node.js 我们不希望丢弃超出的部分。这样超出的部分会在后面的读取中陆续输出。 process.stdin.on(&#39;readable&#39;, function () { var buf = process.stdin.read(3); console.dir(buf); + process.stdin.read(0); }); $ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume2.js &lt;Buffer 61 62 63&gt; &lt;Buffer **0a** 64 65&gt; &lt;Buffer 66 **0a** 67&gt; &lt;Buffer 68 69 **0a**&gt; 除了调用 read(0)，还可调用 unshift() 方法将多余数据放回去。这样下次 read() 的时候数据都还在。比如一个解析换行的示例，遇到换行时将本行输出，剩下的数据塞回，以在下一行处理时使用。 var offset = 0; process.stdin.on(&#39;readable&#39;, function () { var buf = process.stdin.read(); if (!buf) return; for (; offset &lt; buf.length; offset++) { if (buf[offset] === 0x0a) { console.dir(buf.slice(0, offset).toString()); buf = buf.slice(offset + 1); offset = 0; process.stdin.unshift(buf); return; } } process.stdin.unshift(buf); }); $ tail -n +50000 /usr/share/dict/american-english | head -n10 | node lines.js &#39;hearties&#39; &#39;heartiest&#39; &#39;heartily&#39; &#39;heartiness&#39; &#39;heartiness\\&#39;s&#39; &#39;heartland&#39; &#39;heartland\\&#39;s&#39; &#39;heartlands&#39; &#39;heartless&#39; &#39;heartlessly&#39; writable 流 writable 流可作为 .pip() 的对象。 src.pipe(writableStream) 创建 writable 流 需要实现 ._write(chunk, enc, next) 方法，其中： chunk 为接收到的数据 enc 当 opts.decodeString 为 false 且收到的数据这字符串时，它表示字符串的编码 next(err) 数据处理后的回调，可传递一个错误信息以表示数据处理失败 默认情况下，获取到的字符串数据会转为 Buffer，可设置 Writable({ decodeStrings: false }) 来获取字符串数据。 一个 writable 示例： var Writable = require(&#39;stream&#39;).Writable; var ws = Writable(); ws._write = function (chunk, enc, next) { console.dir(chunk); next(); }; process.stdin.pipe(ws); 向 writable 流写入数据 通过调用 writable 流的 write 方法来写入。 process.stdout.write(&#39;beep boop\\n&#39;); 通过调用 end() 来结束数据的写入。 var fs = require(&#39;fs&#39;); var ws = fs.createWriteStream(&#39;message.txt&#39;); ws.write(&#39;beep &#39;); setTimeout(function () { ws.end(&#39;boop\\n&#39;); }, 1000); duplex 双工类型的流，同时具有 writable 和 readable 流的功能。Node.js 内建的 zlib,TCP sockets 以及 crypto 都是双工类型的。 所以可对双工类型的流进行如下操作： a.pip(b).pip(a) transform 一种特殊类型的双工流，区别在于 transform 类型其输出是输入的转换。跟它的名字一样，这里面对数据进行一些转换后输出。比如，通过 zlib.createGzip 来对数据进行 gzip 的压缩。有时候也将这种类型的流称为 through steam。 classic stream 这里指使用旧版 api 的流。当一个流身上绑定了 data 事件的监听时，便会回退为经典旧版的流。 classic readable stream 当有数据时它会派发 data 事件，数据输出结束时派发 end 事件给消费者。 .pipe() 通过检查 stream.readable 以判断该流是否是 readable 类型。 classic readable 流的创建 一个 classic readable 流的创建示例： var Stream = require(&#39;stream&#39;); var stream = new Stream; stream.readable = true; var c = 64; var iv = setInterval(function () { if (++c &gt;= 75) { clearInterval(iv); stream.emit(&#39;end&#39;); } else stream.emit(&#39;data&#39;, String.fromCharCode(c)); }, 100); stream.pipe(process.stdout); 从 classic readable 流读取数据 数据读取是通过监听流上的 data 与 end 事件。 一个从 classic readable 流读取数据的示例： process.stdin.on(&#39;data&#39;, function (buf) { console.log(buf); }); process.stdin.on(&#39;end&#39;, function () { console.log(&#39;__END__&#39;); }); 一般不建议通过这种方式来操作，一旦给流绑定 data 事件处理器，即回退到旧的 api 来使用流。如果真的有兼容操作旧版流的需求，应该通过 through 或 concat-stream 来进行。 classic writable stream 只需要实现 .write(buf), .end(buf) 及 .destroy() 方法即可，比较简单。 内建的流对象 总结 本质上，所有流都是 EventEmitter，通过事件可写入和读取数据。但通过新的 stream api，可方便地通过 .pipe() 方法来使用流而不是事件的方式。 使用 stream 可显著提高程序性能，特别是处理数据量大的情况下。它可以将数据分片处理，而不是粗暴地将数据看作一个整体。但掌握并熟练是需要一定时间练习的。 参考 stream handbook Node.js Streams: Everything you need to know core stream documentation perguth/node-streams","@type":"BlogPosting","headline":"Node.js 中的 stream","dateModified":"2019-03-31T14:03:00+08:00","datePublished":"2019-03-31T14:03:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Node.js 中的 stream</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-03-31T14:03:00+08:00" itemprop="datePublished">Mar 31, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="nodjs-中的-stream">Nod.js 中的 stream</h1>

<h3 id="什么是-stream">什么是 stream</h3>

<p>Stream 借鉴自 Unix 编程哲学中的 pipe。</p>

<p>Unix shell 命令中，管道式的操作 <code class="language-plaintext highlighter-rouge">|</code> 将上一个命令的输出作为下一个命令的输入。Node.js stream 中则是通过 <code class="language-plaintext highlighter-rouge">.pip()</code> 方法来进行的。</p>

<p>来看一个 stream 的运用场景：从服务器读取文件并返回给页面。</p>

<ul>
  <li>朴素的实现：</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">http</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">__dirname</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">/data.txt</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">});</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8000</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">stream</code> 实现：</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">http</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">stream</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">createReadStream</span><span class="p">(</span><span class="nx">__dirname</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">/data.txt</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">stream</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8000</span><span class="p">);</span>

</code></pre></div></div>

<p>好处：</p>
<ul>
  <li>代码更加简洁。</li>
  <li>可自由组合各种模块来处理数据。</li>
</ul>

<h3 id="stream-的种类">stream 的种类</h3>

<p>分五种：</p>
<ul>
  <li>readable</li>
  <li>writable</li>
  <li>duplex</li>
  <li>transform</li>
  <li>classic</li>
</ul>

<h4 id="readable">readable</h4>

<p>readable 类型的流产生的数据，可通过 <code class="language-plaintext highlighter-rouge">.pip()</code> 输送到能够消费（consume）流数据的地方，比如 writable，transform，duplex 类型的对象。</p>

<p>一个 readable stream 示例：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Readable</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">stream</span><span class="dl">'</span><span class="p">).</span><span class="nx">Readable</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">rs</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Readable</span><span class="p">;</span>
<span class="nx">rs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">'</span><span class="s1">beep </span><span class="dl">'</span><span class="p">);</span>
<span class="nx">rs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">'</span><span class="s1">boop</span><span class="se">\n</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">rs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="nx">rs</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">);</span>

</code></pre></div></div>

<p>运行结果：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node read0.js
beep boop
</code></pre></div></div>

<h4 id="_read-方法与按需输出"><code class="language-plaintext highlighter-rouge">_read</code> 方法与按需输出</h4>

<p>上面 <code class="language-plaintext highlighter-rouge">rs.push(null)</code> 表示没有更多数据了。直接将数据塞入到 readable 流中，然后被缓冲起来，直到被消费（示例中消费方为 <code class="language-plaintext highlighter-rouge">process.stdout</code>，即输出到命令行。）。因为消费者有可能并不能立即消费这些内容，直接 <code class="language-plaintext highlighter-rouge">push</code> 数据后会消耗不必要的资源。</p>

<p>更好的做法是，让 readable 流只在消费者需要数据的时候再 <code class="language-plaintext highlighter-rouge">push</code>。这是通过定义能 raedable 对象定义 <code class="language-plaintext highlighter-rouge">._read</code> 方法来完成的。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Readable</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">stream</span><span class="dl">'</span><span class="p">).</span><span class="nx">Readable</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">rs</span> <span class="o">=</span> <span class="nx">Readable</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">97</span><span class="p">;</span>
<span class="nx">rs</span><span class="p">.</span><span class="nx">_read</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">rs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="nx">c</span><span class="o">++</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">&gt;</span> <span class="dl">'</span><span class="s1">z</span><span class="dl">'</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">rs</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">);</span>
</code></pre></div></div>

<p>运行结果：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span> <span class="nx">node</span> <span class="nx">read1</span><span class="p">.</span><span class="nx">js</span>
<span class="nx">abcdefghijklmnopqrstuvwxyz</span>

</code></pre></div></div>

<p>这种方式下，定义了 readable 流产生数据的方法 <code class="language-plaintext highlighter-rouge">._read</code>，但并没有马上执行并输出数据，而是在 <code class="language-plaintext highlighter-rouge">process.stdout</code> 读取时，才调用输出的。</p>

<p><code class="language-plaintext highlighter-rouge">_read</code> 方法可动态接收一个可选的 <code class="language-plaintext highlighter-rouge">size</code> 参数，由消费方指定一次读取想要多少字节的数据，当然，<code class="language-plaintext highlighter-rouge">_read</code> 方法的实现中是可以忽略这个入参的。</p>

<p>下面的示例可证明 <code class="language-plaintext highlighter-rouge">_read</code> 方法是消费方调用的时候才执行的，而不是主动执行。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Readable</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">stream</span><span class="dl">'</span><span class="p">).</span><span class="nx">Readable</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">rs</span> <span class="o">=</span> <span class="nx">Readable</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">97</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

<span class="nx">rs</span><span class="p">.</span><span class="nx">_read</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">&gt;=</span> <span class="dl">'</span><span class="s1">z</span><span class="dl">'</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="k">return</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
    
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">rs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="o">++</span><span class="nx">c</span><span class="p">));</span>
    <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">rs</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">);</span>

<span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">exit</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="s1">_read() called </span><span class="dl">'</span> <span class="o">+</span> <span class="p">(</span><span class="nx">c</span> <span class="o">-</span> <span class="mi">97</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> times</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">,</span> <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span><span class="p">);</span>

</code></pre></div></div>

<h4 id="输出任意数据">输出任意数据</h4>

<p>上面展示的是输出简单字符串，如果需要输出其他复杂数据，初始化时设置上正确的 <code class="language-plaintext highlighter-rouge">objectMode</code> 参数，<code class="language-plaintext highlighter-rouge">Readable({ objectMode: true })</code></p>

<h4 id="消费-readable-流产生的数据">消费 readable 流产生的数据</h4>

<p>一般情况下， 我们会将 readable 产生的数据直接传递给其他的消费方，比如 <a href="https://npmjs.org/package/through">through</a> 或 <a href="https://npmjs.org/package/concat-stream">concat-stream</a> 创建的流对象。但直接操作来自 readable 的数据也是可以的。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">readable</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">read</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">buf</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>上面的示例代码中，监听了来自命令行的输入，有数据时 stdin <code class="language-plaintext highlighter-rouge">readable</code> 事件便会触发，然后可通过调用 <code class="language-plaintext highlighter-rouge">read()</code> 方法获取到数据。数据结束时 <code class="language-plaintext highlighter-rouge">read()</code> 返回 <code class="language-plaintext highlighter-rouge">null</code> 表示没有更多数据了。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="o">(</span><span class="nb">echo </span>abc<span class="p">;</span> <span class="nb">sleep </span>1<span class="p">;</span> <span class="nb">echo </span>def<span class="p">;</span> <span class="nb">sleep </span>1<span class="p">;</span> <span class="nb">echo </span>ghi<span class="o">)</span> | node consume0.js 
&lt;Buffer 61 62 63 0a&gt;
&lt;Buffer 64 65 66 0a&gt;
&lt;Buffer 67 68 69 0a&gt;
null
</code></pre></div></div>

<p>同时 <code class="language-plaintext highlighter-rouge">read()</code> 方法支持传递一个 size 指定一次获取多少的字节（bytes）。比如一次只获取 3 字节的数据：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">readable</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">read</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">buf</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>这将导致我们获取到的数据是不完整的，因为指定了尺寸后，超出的部分是拿不到的。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="o">(</span><span class="nb">echo </span>abc<span class="p">;</span> <span class="nb">sleep </span>1<span class="p">;</span> <span class="nb">echo </span>def<span class="p">;</span> <span class="nb">sleep </span>1<span class="p">;</span> <span class="nb">echo </span>ghi<span class="o">)</span> | node consume1.js 
&lt;Buffer 61 62 63&gt;
&lt;Buffer 0a 64 65&gt;
&lt;Buffer 66 0a 67&gt;
</code></pre></div></div>

<p>此时可通过调用 <code class="language-plaintext highlighter-rouge">read(0)</code> 告诉 Node.js 我们不希望丢弃超出的部分。这样超出的部分会在后面的读取中陆续输出。</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">process.stdin.on('readable', function () {
</span>    var buf = process.stdin.read(3);
    console.dir(buf);
<span class="gi">+    process.stdin.read(0);
</span><span class="err">});</span>
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="o">(</span><span class="nb">echo </span>abc<span class="p">;</span> <span class="nb">sleep </span>1<span class="p">;</span> <span class="nb">echo </span>def<span class="p">;</span> <span class="nb">sleep </span>1<span class="p">;</span> <span class="nb">echo </span>ghi<span class="o">)</span> | node consume2.js 
&lt;Buffer 61 62 63&gt;
&lt;Buffer <span class="k">**</span>0a<span class="k">**</span> 64 65&gt;
&lt;Buffer 66 <span class="k">**</span>0a<span class="k">**</span> 67&gt;
&lt;Buffer 68 69 <span class="k">**</span>0a<span class="k">**</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>除了调用 <code class="language-plaintext highlighter-rouge">read(0)</code>，还可调用 <code class="language-plaintext highlighter-rouge">unshift()</code> 方法将多余数据放回去。这样下次 <code class="language-plaintext highlighter-rouge">read()</code> 的时候数据都还在。比如一个解析换行的示例，遇到换行时将本行输出，剩下的数据塞回，以在下一行处理时使用。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">readable</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">buf</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">read</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">buf</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="nx">offset</span> <span class="o">&lt;</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="nx">offset</span><span class="p">]</span> <span class="o">===</span> <span class="mh">0x0a</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">buf</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">offset</span><span class="p">).</span><span class="nx">toString</span><span class="p">());</span>
            <span class="nx">buf</span> <span class="o">=</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="nx">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">buf</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">buf</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">tail</span> <span class="nt">-n</span> +50000 /usr/share/dict/american-english | <span class="nb">head</span> <span class="nt">-n10</span> | node lines.js 
<span class="s1">'hearties'</span>
<span class="s1">'heartiest'</span>
<span class="s1">'heartily'</span>
<span class="s1">'heartiness'</span>
<span class="s1">'heartiness\'</span>s<span class="s1">'
'</span>heartland<span class="s1">'
'</span>heartland<span class="se">\'</span>s<span class="s1">'
'</span>heartlands<span class="s1">'
'</span>heartless<span class="s1">'
'</span>heartlessly<span class="s1">'
</span></code></pre></div></div>

<h3 id="writable-流">writable 流</h3>

<p>writable 流可作为 <code class="language-plaintext highlighter-rouge">.pip()</code> 的对象。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">src</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">writableStream</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="创建-writable-流">创建 writable 流</h4>

<p>需要实现 <code class="language-plaintext highlighter-rouge">._write(chunk, enc, next)</code> 方法，其中：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">chunk</code> 为接收到的数据</li>
  <li><code class="language-plaintext highlighter-rouge">enc</code>  当 <code class="language-plaintext highlighter-rouge">opts.decodeString</code> 为 <code class="language-plaintext highlighter-rouge">false</code> 且收到的数据这字符串时，它表示字符串的编码</li>
  <li><code class="language-plaintext highlighter-rouge">next(err)</code> 数据处理后的回调，可传递一个错误信息以表示数据处理失败</li>
</ul>

<p>默认情况下，获取到的字符串数据会转为  <code class="language-plaintext highlighter-rouge">Buffer</code>，可设置 <code class="language-plaintext highlighter-rouge">Writable({ decodeStrings: false })</code> 来获取字符串数据。</p>

<p>一个 writable 示例：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Writable</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">stream</span><span class="dl">'</span><span class="p">).</span><span class="nx">Writable</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">ws</span> <span class="o">=</span> <span class="nx">Writable</span><span class="p">();</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">_write</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">,</span> <span class="nx">enc</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
    <span class="nx">next</span><span class="p">();</span>
<span class="p">};</span>

<span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">ws</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="向-writable-流写入数据">向 writable 流写入数据</h4>

<p>通过调用 writable 流的 <code class="language-plaintext highlighter-rouge">write</code> 方法来写入。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">'</span><span class="s1">beep boop</span><span class="se">\n</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>通过调用 <code class="language-plaintext highlighter-rouge">end()</code> 来结束数据的写入。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">ws</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">createWriteStream</span><span class="p">(</span><span class="dl">'</span><span class="s1">message.txt</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">ws</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">'</span><span class="s1">beep </span><span class="dl">'</span><span class="p">);</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">ws</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="dl">'</span><span class="s1">boop</span><span class="se">\n</span><span class="dl">'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="duplex">duplex</h3>

<p>双工类型的流，同时具有 writable 和 readable 流的功能。Node.js 内建的 <code class="language-plaintext highlighter-rouge">zlib</code>,<code class="language-plaintext highlighter-rouge">TCP sockets</code> 以及 <code class="language-plaintext highlighter-rouge">crypto</code> 都是双工类型的。</p>

<p>所以可对双工类型的流进行如下操作：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">a</span><span class="p">.</span><span class="nx">pip</span><span class="p">(</span><span class="nx">b</span><span class="p">).</span><span class="nx">pip</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="transform">transform</h3>

<p>一种特殊类型的双工流，区别在于 transform 类型其输出是输入的转换。跟它的名字一样，这里面对数据进行一些转换后输出。比如，通过 <code class="language-plaintext highlighter-rouge">zlib.createGzip</code> 来对数据进行 gzip 的压缩。有时候也将这种类型的流称为 <code class="language-plaintext highlighter-rouge">through steam</code>。</p>

<h3 id="classic-stream">classic stream</h3>

<p>这里指使用旧版 api 的流。当一个流身上绑定了 <code class="language-plaintext highlighter-rouge">data</code> 事件的监听时，便会回退为经典旧版的流。</p>

<h4 id="classic-readable-stream">classic readable stream</h4>

<p>当有数据时它会派发 <code class="language-plaintext highlighter-rouge">data</code> 事件，数据输出结束时派发 <code class="language-plaintext highlighter-rouge">end</code> 事件给消费者。</p>

<p><code class="language-plaintext highlighter-rouge">.pipe()</code>  通过检查 <code class="language-plaintext highlighter-rouge">stream.readable</code> 以判断该流是否是 readable 类型。</p>

<h4 id="classic-readable-流的创建">classic readable 流的创建</h4>

<p>一个 classic readable 流的创建示例：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Stream</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">stream</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">stream</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stream</span><span class="p">;</span>
<span class="nx">stream</span><span class="p">.</span><span class="nx">readable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">iv</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="nx">c</span> <span class="o">&gt;=</span> <span class="mi">75</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">iv</span><span class="p">);</span>
        <span class="nx">stream</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">end</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="nx">stream</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">data</span><span class="dl">'</span><span class="p">,</span> <span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="nx">c</span><span class="p">));</span>
<span class="p">},</span> <span class="mi">100</span><span class="p">);</span>

<span class="nx">stream</span><span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">stdout</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="从-classic-readable-流读取数据">从 classic readable 流读取数据</h4>

<p>数据读取是通过监听流上的 <code class="language-plaintext highlighter-rouge">data</code> 与 <code class="language-plaintext highlighter-rouge">end</code> 事件。</p>

<p>一个从 classic readable 流读取数据的示例：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">data</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">buf</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">process</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">end</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">__END__</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>一般不建议通过这种方式来操作，一旦给流绑定 <code class="language-plaintext highlighter-rouge">data</code> 事件处理器，即回退到旧的 api 来使用流。如果真的有兼容操作旧版流的需求，应该通过 <a href="https://www.npmjs.com/package/through">through</a> 或 <a href="https://npmjs.org/package/concat-stream">concat-stream</a> 来进行。</p>

<h4 id="classic-writable-stream">classic writable stream</h4>

<p>只需要实现 <code class="language-plaintext highlighter-rouge">.write(buf)</code>, <code class="language-plaintext highlighter-rouge">.end(buf)</code> 及 <code class="language-plaintext highlighter-rouge">.destroy()</code> 方法即可，比较简单。</p>

<h3 id="内建的流对象">内建的流对象</h3>

<p><img src="https://user-images.githubusercontent.com/3783096/51087824-f1266480-1792-11e9-9736-e86055590997.png" alt="image" /></p>

<h3 id="总结">总结</h3>

<p>本质上，所有流都是 <code class="language-plaintext highlighter-rouge">EventEmitter</code>，通过事件可写入和读取数据。但通过新的 stream api，可方便地通过 <code class="language-plaintext highlighter-rouge">.pipe()</code> 方法来使用流而不是事件的方式。</p>

<p>使用 stream 可显著提高程序性能，特别是处理数据量大的情况下。它可以将数据分片处理，而不是粗暴地将数据看作一个整体。但掌握并熟练是需要一定时间练习的。</p>

<h3 id="参考">参考</h3>

<ul>
  <li><a href="https://github.com/substack/stream-handbook">stream handbook</a></li>
  <li><a href="https://medium.freecodecamp.org/node-js-streams-everything-you-need-to-know-c9141306be93">Node.js Streams: Everything you need to know</a></li>
  <li><a href="http://nodejs.org/docs/latest/api/stream.html#stream_stream">core stream documentation</a></li>
  <li><a href="https://github.com/perguth/node-streams">perguth/node-streams</a></li>
</ul>


  </div><a class="u-url" href="/2019/03/31/Node.js-%E4%B8%AD%E7%9A%84-stream.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
