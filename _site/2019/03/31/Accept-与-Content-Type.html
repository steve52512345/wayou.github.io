<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Accept 与 Content-Type | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Accept 与 Content-Type" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Accept 与 Content-Type Accept 表示请求方希望的资源类型，或者能解析识别的类型 Content-Type 表示实际发送的资源类型 这里资源类型通过 MIME types 表示。 Accept Accept 是浏览器发送的请求头，用于表示想要的资源类型。根据请求的上下文不同，所设置的 Accept 请求头会相应变化。服务器根据 content negotiation 规则选择最合适的类型设置 Content-Type 并返回。 例如请求路由页面时，Chrome 设置 Accept 为 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 对于页面中的样式文件 css，其 Accept 为： Accept: text/css,*/*;q=0.1 可用的值有以下几种： &lt;MIME_type&gt;/&lt;MIME_subtype&gt;，精确指定，示例： text/html。 &lt;MIME_type&gt;/*, 不限制子类型，比如 image/* 会匹配 image/png, image/svg, image/gif 以及其他任何图片类型。 */* 任意 MIME 类型。 ;q= (q-factor weighting) 多种类型组合的情况，通过指定权重（quality value）来表明每种类型的优先级。 Quality value Header 中逗号分隔的值，每项的权重，或优先级。 比如： text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 表示： 值 优先级 text/html 和 application/xhtml+xml 1.0 application/xml 0.9 */* 0.8 Content-Type 用来表示资源的类型。某些情况下，浏览器会对资源的类型进行嗅探而忽略掉服务器返回的 Content-Type。如果想强制客户端使用服务器返回的类型，可加上 X-Content-Type-Options:nosniff 响应头。 支持的值有： media-type，常见的 Content-Type 可 参考这里。 charset，指定资源编码类型。 boundary， 多个资源实例情况下，指定资源的分界符。比如 form 表单提交时分隔多个表单字段，见后面示例。 一般情况下，包含在由服务器发送给客户端的响应头里。但也存在浏览器发送给服务器的情况，比如 POST 请求，表单提交这种由浏览器向服务器发送数据的情况下。 表单的提交类型 form 表单中，提交的内容类型通过表单的 enctype 属性来指定。包含两种： application/x-www-form-urlencoded 较古老的格式，只支持简单文本，不支持文件上传。 multipart/form-data 较新，支持文件上传，尺寸较大的二进制数据等。 一个表单提交示例 通过 koa.js 搭建一个简单的表单提交示例，以查看 Content-Type。 server.js const { createReadStream } = require(&quot;fs&quot;); const Koa = require(&quot;koa&quot;); const app = new Koa(); const router = require(&quot;koa-router&quot;)(); const koaBody = require(&quot;koa-body&quot;); router .get(&quot;/&quot;, async ctx =&gt; { ctx.type = &quot;html&quot;; ctx.body = createReadStream(&quot;form.html&quot;); }) .post( &quot;/submit&quot;, koaBody({ multipart: true }), ctx =&gt; { console.log(&quot;form data is:&quot;, ctx.request.body); ctx.body = JSON.stringify(ctx.request.body); } ); app.use(router.routes()); app.listen(3000); console.log(`server started at http://localhost:3000`); form.html &lt;form action=&quot;/submit&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; foo:&lt;input type=&quot;text&quot; name=&quot;foo&quot; /&gt; bar:&lt;input type=&quot;text&quot; name=&quot;bar&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; 访问页面并提交后，可在 Chrome DevTools 网络面板看到，/submit 这个 POST 请求相关的信息： Request Headers … Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryNgS8sggyuawQSr8W … Form Data ------WebKitFormBoundaryNgS8sggyuawQSr8W Content-Disposition: form-data; name=&quot;foo&quot; 1 ------WebKitFormBoundaryNgS8sggyuawQSr8W Content-Disposition: form-data; name=&quot;bar&quot; 2 ------WebKitFormBoundaryNgS8sggyuawQSr8W-- 这里 ------WebKitFormBoundaryNgS8sggyuawQSr8W 便是上面提到的 boundary ，用以分隔表单内容字段。 内容协商/Content Negotiation 前面提到客户端通过设置 Accept 请求头设置请求资源的类型，服务器根据 content negotiation 规则返回。 Content negotiation 是这么一种机制，同一 URI可响应多种资源，客户端可自行决定请求何种资源（譬如文档的语言，图片格式，文件编码类型）。 ￼ 来自 MDN 展示内容协商流程的图片 内容协商包含两种方式： 客户端通过设置请求头由服务器决定合适的类型进行返回（服务器驱动 ）。 服务器通过设置响应头中响应代码为 300 （Multiple Choices）或 406 （Not Acceptable）作为备用方案（客户端驱动）。 除了 Accept ，用于主动发起内容协商的请求头还有： Accept-Charset：期望的字符集。 Accept-Encoding：期望的编码方式。 Accept-Language：期望的语言。 服务器驱动的内容协商 由客户端发送一组期望的类型，服务器根据自己的算法决定出最合适的类型进行返回，具体实现因服务器类型而异。服务器驱动是最常见的方式，但其也有一些明显的缺点： 由于不是完全了解客户端的兼容性，服务器的返回有时候存在局限性。相反，客户端驱动的是服务器返回多个选择，客户端根据自己的情况选用最合适的，因为客户端自己最了解自己支持哪些。 关于客户端的信息在多次请求中会冗余（当然，请求头冗余的情况在 HTTP/2 中有所缓解），也存在安全隐患（HTTP fingerprinting）。 多种类型的资源被返回后，服务端的缓存策略不再那么有效并且实现会变得复杂。 客户端驱动的内容协商 来自 MDN 展示客户端驱动内容协商流程的图片 得到真实资源前多了一次选择的请求。 参考 Accept Difference between the Accept and Content-Type HTTP headers Content negotiation Content-Type" />
<meta property="og:description" content="Accept 与 Content-Type Accept 表示请求方希望的资源类型，或者能解析识别的类型 Content-Type 表示实际发送的资源类型 这里资源类型通过 MIME types 表示。 Accept Accept 是浏览器发送的请求头，用于表示想要的资源类型。根据请求的上下文不同，所设置的 Accept 请求头会相应变化。服务器根据 content negotiation 规则选择最合适的类型设置 Content-Type 并返回。 例如请求路由页面时，Chrome 设置 Accept 为 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 对于页面中的样式文件 css，其 Accept 为： Accept: text/css,*/*;q=0.1 可用的值有以下几种： &lt;MIME_type&gt;/&lt;MIME_subtype&gt;，精确指定，示例： text/html。 &lt;MIME_type&gt;/*, 不限制子类型，比如 image/* 会匹配 image/png, image/svg, image/gif 以及其他任何图片类型。 */* 任意 MIME 类型。 ;q= (q-factor weighting) 多种类型组合的情况，通过指定权重（quality value）来表明每种类型的优先级。 Quality value Header 中逗号分隔的值，每项的权重，或优先级。 比如： text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 表示： 值 优先级 text/html 和 application/xhtml+xml 1.0 application/xml 0.9 */* 0.8 Content-Type 用来表示资源的类型。某些情况下，浏览器会对资源的类型进行嗅探而忽略掉服务器返回的 Content-Type。如果想强制客户端使用服务器返回的类型，可加上 X-Content-Type-Options:nosniff 响应头。 支持的值有： media-type，常见的 Content-Type 可 参考这里。 charset，指定资源编码类型。 boundary， 多个资源实例情况下，指定资源的分界符。比如 form 表单提交时分隔多个表单字段，见后面示例。 一般情况下，包含在由服务器发送给客户端的响应头里。但也存在浏览器发送给服务器的情况，比如 POST 请求，表单提交这种由浏览器向服务器发送数据的情况下。 表单的提交类型 form 表单中，提交的内容类型通过表单的 enctype 属性来指定。包含两种： application/x-www-form-urlencoded 较古老的格式，只支持简单文本，不支持文件上传。 multipart/form-data 较新，支持文件上传，尺寸较大的二进制数据等。 一个表单提交示例 通过 koa.js 搭建一个简单的表单提交示例，以查看 Content-Type。 server.js const { createReadStream } = require(&quot;fs&quot;); const Koa = require(&quot;koa&quot;); const app = new Koa(); const router = require(&quot;koa-router&quot;)(); const koaBody = require(&quot;koa-body&quot;); router .get(&quot;/&quot;, async ctx =&gt; { ctx.type = &quot;html&quot;; ctx.body = createReadStream(&quot;form.html&quot;); }) .post( &quot;/submit&quot;, koaBody({ multipart: true }), ctx =&gt; { console.log(&quot;form data is:&quot;, ctx.request.body); ctx.body = JSON.stringify(ctx.request.body); } ); app.use(router.routes()); app.listen(3000); console.log(`server started at http://localhost:3000`); form.html &lt;form action=&quot;/submit&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; foo:&lt;input type=&quot;text&quot; name=&quot;foo&quot; /&gt; bar:&lt;input type=&quot;text&quot; name=&quot;bar&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; 访问页面并提交后，可在 Chrome DevTools 网络面板看到，/submit 这个 POST 请求相关的信息： Request Headers … Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryNgS8sggyuawQSr8W … Form Data ------WebKitFormBoundaryNgS8sggyuawQSr8W Content-Disposition: form-data; name=&quot;foo&quot; 1 ------WebKitFormBoundaryNgS8sggyuawQSr8W Content-Disposition: form-data; name=&quot;bar&quot; 2 ------WebKitFormBoundaryNgS8sggyuawQSr8W-- 这里 ------WebKitFormBoundaryNgS8sggyuawQSr8W 便是上面提到的 boundary ，用以分隔表单内容字段。 内容协商/Content Negotiation 前面提到客户端通过设置 Accept 请求头设置请求资源的类型，服务器根据 content negotiation 规则返回。 Content negotiation 是这么一种机制，同一 URI可响应多种资源，客户端可自行决定请求何种资源（譬如文档的语言，图片格式，文件编码类型）。 ￼ 来自 MDN 展示内容协商流程的图片 内容协商包含两种方式： 客户端通过设置请求头由服务器决定合适的类型进行返回（服务器驱动 ）。 服务器通过设置响应头中响应代码为 300 （Multiple Choices）或 406 （Not Acceptable）作为备用方案（客户端驱动）。 除了 Accept ，用于主动发起内容协商的请求头还有： Accept-Charset：期望的字符集。 Accept-Encoding：期望的编码方式。 Accept-Language：期望的语言。 服务器驱动的内容协商 由客户端发送一组期望的类型，服务器根据自己的算法决定出最合适的类型进行返回，具体实现因服务器类型而异。服务器驱动是最常见的方式，但其也有一些明显的缺点： 由于不是完全了解客户端的兼容性，服务器的返回有时候存在局限性。相反，客户端驱动的是服务器返回多个选择，客户端根据自己的情况选用最合适的，因为客户端自己最了解自己支持哪些。 关于客户端的信息在多次请求中会冗余（当然，请求头冗余的情况在 HTTP/2 中有所缓解），也存在安全隐患（HTTP fingerprinting）。 多种类型的资源被返回后，服务端的缓存策略不再那么有效并且实现会变得复杂。 客户端驱动的内容协商 来自 MDN 展示客户端驱动内容协商流程的图片 得到真实资源前多了一次选择的请求。 参考 Accept Difference between the Accept and Content-Type HTTP headers Content negotiation Content-Type" />
<link rel="canonical" href="http://localhost:4000/2019/03/31/Accept-%E4%B8%8E-Content-Type.html" />
<meta property="og:url" content="http://localhost:4000/2019/03/31/Accept-%E4%B8%8E-Content-Type.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-31T12:03:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/03/31/Accept-%E4%B8%8E-Content-Type.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/03/31/Accept-%E4%B8%8E-Content-Type.html"},"description":"Accept 与 Content-Type Accept 表示请求方希望的资源类型，或者能解析识别的类型 Content-Type 表示实际发送的资源类型 这里资源类型通过 MIME types 表示。 Accept Accept 是浏览器发送的请求头，用于表示想要的资源类型。根据请求的上下文不同，所设置的 Accept 请求头会相应变化。服务器根据 content negotiation 规则选择最合适的类型设置 Content-Type 并返回。 例如请求路由页面时，Chrome 设置 Accept 为 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 对于页面中的样式文件 css，其 Accept 为： Accept: text/css,*/*;q=0.1 可用的值有以下几种： &lt;MIME_type&gt;/&lt;MIME_subtype&gt;，精确指定，示例： text/html。 &lt;MIME_type&gt;/*, 不限制子类型，比如 image/* 会匹配 image/png, image/svg, image/gif 以及其他任何图片类型。 */* 任意 MIME 类型。 ;q= (q-factor weighting) 多种类型组合的情况，通过指定权重（quality value）来表明每种类型的优先级。 Quality value Header 中逗号分隔的值，每项的权重，或优先级。 比如： text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 表示： 值 优先级 text/html 和 application/xhtml+xml 1.0 application/xml 0.9 */* 0.8 Content-Type 用来表示资源的类型。某些情况下，浏览器会对资源的类型进行嗅探而忽略掉服务器返回的 Content-Type。如果想强制客户端使用服务器返回的类型，可加上 X-Content-Type-Options:nosniff 响应头。 支持的值有： media-type，常见的 Content-Type 可 参考这里。 charset，指定资源编码类型。 boundary， 多个资源实例情况下，指定资源的分界符。比如 form 表单提交时分隔多个表单字段，见后面示例。 一般情况下，包含在由服务器发送给客户端的响应头里。但也存在浏览器发送给服务器的情况，比如 POST 请求，表单提交这种由浏览器向服务器发送数据的情况下。 表单的提交类型 form 表单中，提交的内容类型通过表单的 enctype 属性来指定。包含两种： application/x-www-form-urlencoded 较古老的格式，只支持简单文本，不支持文件上传。 multipart/form-data 较新，支持文件上传，尺寸较大的二进制数据等。 一个表单提交示例 通过 koa.js 搭建一个简单的表单提交示例，以查看 Content-Type。 server.js const { createReadStream } = require(&quot;fs&quot;); const Koa = require(&quot;koa&quot;); const app = new Koa(); const router = require(&quot;koa-router&quot;)(); const koaBody = require(&quot;koa-body&quot;); router .get(&quot;/&quot;, async ctx =&gt; { ctx.type = &quot;html&quot;; ctx.body = createReadStream(&quot;form.html&quot;); }) .post( &quot;/submit&quot;, koaBody({ multipart: true }), ctx =&gt; { console.log(&quot;form data is:&quot;, ctx.request.body); ctx.body = JSON.stringify(ctx.request.body); } ); app.use(router.routes()); app.listen(3000); console.log(`server started at http://localhost:3000`); form.html &lt;form action=&quot;/submit&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; foo:&lt;input type=&quot;text&quot; name=&quot;foo&quot; /&gt; bar:&lt;input type=&quot;text&quot; name=&quot;bar&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; 访问页面并提交后，可在 Chrome DevTools 网络面板看到，/submit 这个 POST 请求相关的信息： Request Headers … Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryNgS8sggyuawQSr8W … Form Data ------WebKitFormBoundaryNgS8sggyuawQSr8W Content-Disposition: form-data; name=&quot;foo&quot; 1 ------WebKitFormBoundaryNgS8sggyuawQSr8W Content-Disposition: form-data; name=&quot;bar&quot; 2 ------WebKitFormBoundaryNgS8sggyuawQSr8W-- 这里 ------WebKitFormBoundaryNgS8sggyuawQSr8W 便是上面提到的 boundary ，用以分隔表单内容字段。 内容协商/Content Negotiation 前面提到客户端通过设置 Accept 请求头设置请求资源的类型，服务器根据 content negotiation 规则返回。 Content negotiation 是这么一种机制，同一 URI可响应多种资源，客户端可自行决定请求何种资源（譬如文档的语言，图片格式，文件编码类型）。 ￼ 来自 MDN 展示内容协商流程的图片 内容协商包含两种方式： 客户端通过设置请求头由服务器决定合适的类型进行返回（服务器驱动 ）。 服务器通过设置响应头中响应代码为 300 （Multiple Choices）或 406 （Not Acceptable）作为备用方案（客户端驱动）。 除了 Accept ，用于主动发起内容协商的请求头还有： Accept-Charset：期望的字符集。 Accept-Encoding：期望的编码方式。 Accept-Language：期望的语言。 服务器驱动的内容协商 由客户端发送一组期望的类型，服务器根据自己的算法决定出最合适的类型进行返回，具体实现因服务器类型而异。服务器驱动是最常见的方式，但其也有一些明显的缺点： 由于不是完全了解客户端的兼容性，服务器的返回有时候存在局限性。相反，客户端驱动的是服务器返回多个选择，客户端根据自己的情况选用最合适的，因为客户端自己最了解自己支持哪些。 关于客户端的信息在多次请求中会冗余（当然，请求头冗余的情况在 HTTP/2 中有所缓解），也存在安全隐患（HTTP fingerprinting）。 多种类型的资源被返回后，服务端的缓存策略不再那么有效并且实现会变得复杂。 客户端驱动的内容协商 来自 MDN 展示客户端驱动内容协商流程的图片 得到真实资源前多了一次选择的请求。 参考 Accept Difference between the Accept and Content-Type HTTP headers Content negotiation Content-Type","@type":"BlogPosting","headline":"Accept 与 Content-Type","dateModified":"2019-03-31T12:03:00+08:00","datePublished":"2019-03-31T12:03:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Accept 与 Content-Type</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-03-31T12:03:00+08:00" itemprop="datePublished">Mar 31, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="accept-与-content-type">Accept 与 Content-Type</h1>

<ul>
  <li>Accept 表示请求方希望的资源类型，或者能解析识别的类型</li>
  <li>Content-Type 表示实际发送的资源类型</li>
</ul>

<p>这里资源类型通过 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME types</a> 表示。</p>

<h3 id="accept">Accept</h3>

<p>Accept 是浏览器发送的请求头，用于表示想要的资源类型。根据请求的上下文不同，所设置的 Accept 请求头会相应变化。服务器根据 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation">content negotiation</a> 规则选择最合适的类型设置 <code class="language-plaintext highlighter-rouge">Content-Type</code> 并返回。</p>

<p>例如请求路由页面时，Chrome 设置 Accept 为</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
</code></pre></div></div>

<p>对于页面中的样式文件 css，其 Accept 为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Accept: text/css,*/*;q=0.1
</code></pre></div></div>

<p>可用的值有以下几种：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;MIME_type&gt;/&lt;MIME_subtype&gt;</code>，精确指定，示例： <code class="language-plaintext highlighter-rouge">text/html</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;MIME_type&gt;/*</code>, 不限制子类型，比如 <code class="language-plaintext highlighter-rouge">image/*</code> 会匹配 <code class="language-plaintext highlighter-rouge">image/png</code>, <code class="language-plaintext highlighter-rouge">image/svg</code>, <code class="language-plaintext highlighter-rouge">image/gif</code> 以及其他任何图片类型。</li>
  <li><code class="language-plaintext highlighter-rouge">*/*</code> 任意 MIME 类型。</li>
  <li><code class="language-plaintext highlighter-rouge">;q= (q-factor weighting)</code> 多种类型组合的情况，通过指定权重（<a href="https://developer.mozilla.org/en-US/docs/Glossary/Quality_values">quality value</a>）来表明每种类型的优先级。</li>
</ul>

<h4 id="quality-value">Quality value</h4>

<p>Header 中逗号分隔的值，每项的权重，或优先级。
比如：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
</code></pre></div></div>

<p>表示：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">值</th>
      <th style="text-align: left">优先级</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">text/html</code> 和 <code class="language-plaintext highlighter-rouge">application/xhtml+xml</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">1.0</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">application/xml</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">0.9</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">*/*</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">0.8</code></td>
    </tr>
  </tbody>
</table>

<h3 id="content-type">Content-Type</h3>

<p>用来表示资源的类型。某些情况下，浏览器会对资源的类型进行嗅探而忽略掉服务器返回的 <code class="language-plaintext highlighter-rouge">Content-Type</code>。如果想强制客户端使用服务器返回的类型，可加上 <code class="language-plaintext highlighter-rouge">X-Content-Type-Options:nosniff</code> 响应头。</p>

<p>支持的值有：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">media-type</code>，常见的 Content-Type 可 <a href="https://stackoverflow.com/a/48704300/1553656">参考这里</a>。</li>
  <li><code class="language-plaintext highlighter-rouge">charset</code>，指定资源编码类型。</li>
  <li><code class="language-plaintext highlighter-rouge">boundary</code>， 多个资源实例情况下，指定资源的分界符。比如 form 表单提交时分隔多个表单字段，见后面示例。</li>
</ul>

<p>一般情况下，包含在由服务器发送给客户端的响应头里。但也存在浏览器发送给服务器的情况，比如 POST 请求，表单提交这种由浏览器向服务器发送数据的情况下。</p>

<h4 id="表单的提交类型">表单的提交类型</h4>

<p>form 表单中，提交的内容类型通过表单的 <code class="language-plaintext highlighter-rouge">enctype</code> 属性来指定。包含两种：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">application/x-www-form-urlencoded</code> 较古老的格式，只支持简单文本，不支持文件上传。</li>
  <li><code class="language-plaintext highlighter-rouge">multipart/form-data</code> 较新，支持文件上传，尺寸较大的二进制数据等。</li>
</ul>

<h4 id="一个表单提交示例">一个表单提交示例</h4>

<p>通过 koa.js 搭建一个简单的表单提交示例，以查看 Content-Type。</p>

<p><em>server.js</em></p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span> <span class="nx">createReadStream</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">fs</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">Koa</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">koa</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Koa</span><span class="p">();</span>
<span class="kd">const</span> <span class="nx">router</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">koa-router</span><span class="dl">"</span><span class="p">)();</span>
<span class="kd">const</span> <span class="nx">koaBody</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">koa-body</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">router</span>
  <span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">"</span><span class="s2">/</span><span class="dl">"</span><span class="p">,</span> <span class="k">async</span> <span class="nx">ctx</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">html</span><span class="dl">"</span><span class="p">;</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">body</span> <span class="o">=</span> <span class="nx">createReadStream</span><span class="p">(</span><span class="dl">"</span><span class="s2">form.html</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="nx">post</span><span class="p">(</span>
    <span class="dl">"</span><span class="s2">/submit</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">koaBody</span><span class="p">({</span>
      <span class="na">multipart</span><span class="p">:</span> <span class="kc">true</span>
    <span class="p">}),</span>
    <span class="nx">ctx</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">form data is:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>
      <span class="nx">ctx</span><span class="p">.</span><span class="nx">body</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">);</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">router</span><span class="p">.</span><span class="nx">routes</span><span class="p">());</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`server started at http://localhost:3000`</span><span class="p">);</span>
</code></pre></div></div>

<p><em>form.html</em></p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">"/submit"</span> <span class="na">method=</span><span class="s">"POST"</span> <span class="na">enctype=</span><span class="s">"multipart/form-data"</span><span class="nt">&gt;</span>
  foo:<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"foo"</span> <span class="nt">/&gt;</span> 
  bar:<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"bar"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">"submit"</span><span class="nt">&gt;</span>submit<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</code></pre></div></div>

<p>访问页面并提交后，可在 Chrome DevTools 网络面板看到，<code class="language-plaintext highlighter-rouge">/submit</code> 这个 POST 请求相关的信息：</p>

<p>Request Headers</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>…
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryNgS8sggyuawQSr8W
…
</code></pre></div></div>

<p>Form Data</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>------WebKitFormBoundaryNgS8sggyuawQSr8W
Content-Disposition: form-data; name="foo"

1
------WebKitFormBoundaryNgS8sggyuawQSr8W
Content-Disposition: form-data; name="bar"

2
------WebKitFormBoundaryNgS8sggyuawQSr8W--
</code></pre></div></div>

<p>这里 <code class="language-plaintext highlighter-rouge">------WebKitFormBoundaryNgS8sggyuawQSr8W</code> 便是上面提到的 <code class="language-plaintext highlighter-rouge">boundary </code>，用以分隔表单内容字段。</p>

<h3 id="内容协商content-negotiation">内容协商/Content Negotiation</h3>

<p>前面提到客户端通过设置 Accept 请求头设置请求资源的类型，服务器根据 content negotiation 规则返回。</p>

<p>Content negotiation 是这么一种机制，同一 URI可响应多种资源，客户端可自行决定请求何种资源（譬如文档的语言，图片格式，文件编码类型）。
￼
<img src="https://user-images.githubusercontent.com/3783096/50970937-c2ec1f00-151d-11e9-8c8e-9e98e742a626.png" alt="image" />
<em>来自 MDN 展示内容协商流程的图片</em></p>

<p>内容协商包含两种方式：</p>
<ul>
  <li>客户端通过设置请求头由服务器决定合适的类型进行返回（服务器驱动 ）。</li>
  <li>服务器通过设置响应头中响应代码为 300 （<code class="language-plaintext highlighter-rouge">Multiple Choices</code>）或 406 （<code class="language-plaintext highlighter-rouge">Not Acceptable</code>）作为备用方案（客户端驱动）。</li>
</ul>

<p>除了 Accept ，用于主动发起内容协商的请求头还有：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Accept-Charset</code>：期望的字符集。</li>
  <li><code class="language-plaintext highlighter-rouge">Accept-Encoding</code>：期望的编码方式。</li>
  <li><code class="language-plaintext highlighter-rouge">Accept-Language</code>：期望的语言。</li>
</ul>

<h4 id="服务器驱动的内容协商">服务器驱动的内容协商</h4>

<p>由客户端发送一组期望的类型，服务器根据自己的算法决定出最合适的类型进行返回，具体实现因服务器类型而异。服务器驱动是最常见的方式，但其也有一些明显的缺点：</p>
<ul>
  <li>由于不是完全了解客户端的兼容性，服务器的返回有时候存在局限性。相反，客户端驱动的是服务器返回多个选择，客户端根据自己的情况选用最合适的，因为客户端自己最了解自己支持哪些。</li>
  <li>关于客户端的信息在多次请求中会冗余（当然，请求头冗余的情况在 HTTP/2 中有所缓解），也存在安全隐患（HTTP fingerprinting）。</li>
  <li>多种类型的资源被返回后，服务端的缓存策略不再那么有效并且实现会变得复杂。</li>
</ul>

<h4 id="客户端驱动的内容协商">客户端驱动的内容协商</h4>

<p><img src="https://user-images.githubusercontent.com/3783096/50970964-d13a3b00-151d-11e9-9538-d1264cb71f2b.png" alt="image" />
<em>来自 MDN 展示客户端驱动内容协商流程的图片</em></p>

<p>得到真实资源前多了一次选择的请求。</p>

<h3 id="参考">参考</h3>

<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept">Accept</a></li>
  <li><a href="https://webmasters.stackexchange.com/questions/31212/difference-between-the-accept-and-content-type-http-headers">Difference between the Accept and Content-Type HTTP headers</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation">Content negotiation</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type">Content-Type</a></li>
</ul>


  </div><a class="u-url" href="/2019/03/31/Accept-%E4%B8%8E-Content-Type.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
