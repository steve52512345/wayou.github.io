<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Content Security Policy (CSP) 介绍 | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Content Security Policy (CSP) 介绍" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Content Security Policy (CSP) 介绍 当我不经意间在 Twitter 页面 view source 后，发现了惊喜。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Twitter&lt;/title&gt; &lt;style&gt; body { background-color: #ffffff; font-family: sans-serif; } a { color: #1da1f2; } svg { color: #1da1f2; display: block; fill: currentcolor; height: 21px; margin: 13px auto; width: 24px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;center&gt;If you’re not redirected soon, please &lt;a href=&quot;/&quot;&gt;use this link&lt;/a&gt;.&lt;/center&gt; &lt;/noscript&gt; &lt;script nonce=&quot;SG0bV9rOanQfzG0ccU8WQw==&quot;&gt; document.cookie = &quot;app_shell_visited=1;path=/;max-age=5&quot;; location.replace(location.href.split(&quot;#&quot;)[0]); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 相比平时看到的其他站点的源码，可以说是很清爽了。没有乱七八糟的标签，功能却一样不少。特别有迷惑性，以为这便是页面所有的源码，但查看 DevTools 的 Source 面板后很容易知道这并不是真实的 HTML 代码。但为何页面源码给出的是如此清爽的版本，这里先不研究。 把目光移向 script 标签时，发现一个不认识的 nonce 属性。它以及它后面的神秘字符串成功引起了我的好奇。再去看 Google 首页的源码，也有好些 nonce 的运用。是时候去了解一下这里的 nonce 是什么了。 ! &lt;script nonce=&quot;SG0bV9rOanQfzG0ccU8WQw==&quot;&gt; document.cookie = &quot;app_shell_visited=1;path=/;max-age=5&quot;; location.replace(location.href.split(&quot;#&quot;)[0]); &lt;/script&gt; Content Security Policy (CSP) 要了解 nonce， 先了解 Content-Security-Policy(CSP)。 我们都知道浏览器有同源策略（same-origin policy）的安全限制，即每个站点只允许加载来自和自身同域（origin）的数据，https://a.com 是无法从 https://b.com 加载到资源的。每个站点被严格限制在了自已的孤岛上，自己就是一个沙盒，这样很安全，整个网络不会杂乱无章。主要地，它能解决大部分安全问题。假若没有同源策略，恶意代码能够轻松在浏览器端执行然后获取各种隐私信息：银行帐号，社交数据等。 那网站间如何进行数据共享，当然是有办法的，了解下 CORS。 现实中，问题是同源策略也并不是万无一失，跨域攻击 Cross-site scripting (XSS) 便包含五花八门绕开限制的手段，形式上通过向页面注入恶意代码完成信息的窃取或攻击。比如 UGC 类型的站点，因为内容依赖用户创建，这就开了很大一个口子，允许用户输入的内容运行在页面上。当然，因为我们都知道会有注入攻击，所以对用户输入的内容进行防 XSS 过滤也成了标配。 Content-Security-Policy 从另一方面给浏览器加了层防护，能极大地减少这种攻击的发生。 原理 CSP 通过告诉浏览器一系列规则，严格规定页面中哪些资源允许有哪些来源， 不在指定范围内的统统拒绝。相比同源策略，CSP 可以说是很严格了。 其实施有两种途径： 服务器添加 Content-Security-Policy 响应头来指定规则 HTML 中添加 &lt;meta&gt; 标签来指定 Content-Security-Policy 规则 ￼ mobile.twitter.com header 中的 CSP 规则 为了测试方便，以下示例均使用 &lt;meta&gt; 标签来开启 CSP 规则。但 &lt;meta&gt; 中有些指令是不能使用的，后面会了解到。只有响应头中才能使用全部的限制指令。 一个简单示例 创建一个 HTML 文件放入以下内容： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39; https://unpkg.com&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在该测试文件所在目录开启一个本地 server 以访问，这里使用 Python 自带的 server: $ python -m SimpleHTTPServer 8000 然后访问 localhost:8000 以观察结果： ￼ 符合 CSP 规则情况下的正常访问 然后我们将 Content-Security-Policy 改成不允许任何资源再试一下： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; - &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39; https://unpkg.com&quot;&gt; + &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src ‘none’&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 触发 CSP 规则资源被 block 的情况 下面我们来解释这里设置的 CSP 规则及理解为何资源加载失败。 CSP 规则 无论是 header 中还是 &lt;meta&gt; 标签中指定，其值的格式都是统一的，由一系列 CSP 指令（directive）组合而成。 示例： Content-Security-Policy: &lt;policy-directive&gt;; &lt;policy-directive&gt;… 这里 directive，即指令，是 CSP 规范中规定用以详细详述某种资源的来源，比如前面示例中使用的 script-src，指定脚本可以有哪些合法来源，img-src 则指定图片，以下是常用指令： base-uri 限制可出现在页面 &lt;base&gt; 标签中的链接。 child-src 列出可用于 worker 及以 frame 形式嵌入的链接。 譬如: child-src https://youtube.com 表示只能从 Youtube 嵌入视频资源。 connect-src 可发起连接的地址 (通过 XHR, WebSockets 或 EventSource)。 font-src 字体来源。譬如，要使用 Google web fonts 则需要添加 font-src https://themes.googleusercontent.com 规则。 form-action &lt;form&gt; 标签可提交的地址。 frame-ancestors 当前页面可被哪些来源所嵌入（与 child-src 正好相反）。作用于 &lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt; 及 &lt;applet&gt;。 该指令不能通过 &lt;meta&gt; 指定且只对非 HTML文档类型的资源生效。 frame-src 该指令已在 level 2 中废弃但会在 level 3 中恢复使用。未指定的情况下回退到 tochild-src 指令。 img-src 指定图片来源。 media-src 限制音视频资源的来源。 object-src Flash 及其他插件的来源。 plugin-types 限制页面中可加载的插件类型。 report-uri 指定一个可接收 CSP 报告的地址，浏览器会在相应指令不通过时发送报告。不能通过 &lt;meta&gt; 标签来指定。 style-src 限制样式文件的来源。 upgrade-insecure-requests 指导客户端将页面地址重写，HTTP 转 HTTPS。用于站点中有大量旧地址需要重定向的情形。 worker-src CSP Level 3 中的指令，规定可用于 worker, shared worker, 或 service worker 中的地址。 child-src  与 frame-ancestors  看起来比较像。前者规定的是页面中可加载哪些 iframe，后者规定谁可以以 iframe 加载本页。 比如来自不同站点的两个网页 A 与 B，B 中有 iframe 加载了 A。那么 A 的 frame-ancestors 需要包含 B B 的 child-src 需要包含 A 默认情况下，这些指令都是最大条件开放的，可以理解为其默认值为 *。比如 img-src，如果不明确指定，则可以从所有地方加载图片资源。 还有种特殊的指令 default-src，如果指定了它的值，则相当于改变了这些未指定的指令的默认值。可以理解为，上面 img-src 如果没指定，本来其默认值是 *，可以加载所有来源的图片，但设置 default-src 后，默认值就成了 default-src 指定的值。 常见的做法会设置 default-src ‘self’，这样所有资源都被限制在了和页面同域下。如果此时想要加载从 CDN 来的图片，将图片来源单独添加上即可。 Content-Security-Policy: default-src ‘self’; img-src https://cdn.example.com 现在来看开头那个示例，也许现在就能看明白了。因为页面中需要从 CDN 加载 React 库，所以我们&lt;meta&gt; 标签指定了如下 CSP 规则： script-src &#39;self&#39; https://unpkg.com 这里的 self 及后来改成的 none 是预设值，需用引号包裹，否则会当成 URI 来解析。这里的 CSP 规则表示页面中脚本只能从同域及 https://unpkg.com 加载。假如我们把后者去掉，同样会像上图截图那样 React 库会加载失败，同时控制台中会有加载失败的日志及被触发的规则列出来。 改成 none 之后表示页面不加载任何脚本，即使自己站点上的脚本都无法被加载执行。这里不妨试一下在 csp_test.html 旁边创建一个脚本文件 test.js: test.js alert(‘来自 test.js 的问候！’) 同时在页面中引用它： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;none&#39;&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; + &lt;script src=&quot;./test.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 页面执行结果： script-src none 时页面将不加载任何脚本 是的，哪怕是自己的脚本也无法被加载执行。CSP 就是这样严格和明确，不存在模棱两可的情况。所以在指定来源时，我们需要确认 URI 是否正确。 指令可接受的值 指令后面跟的来源，有两种写法 预设值 URI 通配符 预设值 其中预设值有以下这些： none 不匹配任何东西。 self 匹配当前域，但不包括子域。比如 example.com 可以，api.example.com 则会匹配失败。 unsafe-inline 允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。 unsafe-eval 允许通过字符串动态创建的脚本执行，比如 eval，setTimeout 等。 特别地，在 CSP 的严格控制下，页面中内联脚本及样式也会受影响，在没有明确指定的情况下，其不能被浏览器执行。 考虑下面的代码： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;style&gt; body{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;script&gt; window.onload=function(){ alert(&#39;hi jack!&#39;) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ￼ 未指定 CSP 的情况 根据 MDN 上的描述，如果站点未指定 CSP 无则，浏览器默认不会开启相应检查，所以上面一切运行正常，只受正常的同域限制 。 If the site doesn’t offer the CSP header, browsers likewise use the standard same-origin policy. — 来自 MDN 关于 Content Security Policy (CSP) 的描述 我们加上 CSP 限制： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; + &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;style&gt; body{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;script&gt; window.onload=function(){ alert(&#39;hi jack!&#39;) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 配置站点默认只信息同域的资源，但注意，这个设置并不包含内联的情况，所以结果会如下图。 内联代码被禁止 如何修复它呢。如果我们想要允许页面内的内联脚本或样式，则需要明确地通过 script-src 和 style-src 指出来。 csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; ! &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39; ‘unsafe-inline’”&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;style&gt; body{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;script&gt; window.onload=function(){ alert(&#39;hi jack!&#39;) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这里 default-src &#39;self&#39; ‘unsave-inline’ 配置默认可信的来源有这些： 和页面同域的，以及内联的。 刷新页面，样式及脚本又可以正常执行了。 通常是不建议使用 unsafe-inline 的（同样也不推荐使用 unsafe-eval），因为内联的脚本和样式维护不便，也不利用良好地组织代码。最佳实践是样式抽离到样式文件，脚本放到单独的 js 文件中加载，让 HTML 文件纯粹一点才是好的做法。即使是 onclick=“myHandler” 或 href=“javascript:;” 这种平时常见的写法，也属于内联的脚本，是需要改造的。 如果页面中非得用内联的写法，还有种方式。即页面中这些内联的脚本或样式标签，赋值一个加密串，这个加密串由服务器生成，同时这个加密串被添加到页面的响应头里面。 &lt;script nonce=EDNnf03nceIOfn39fn3e9h3sdfa&gt;   // 这里放置内联在 HTML 中的代码 &lt;/script&gt; 页面 HTTP 响应头的 Content-Security-Policy 配置中包含相同的加密串： Content-Security-Policy: script-src &#39;nonce-EDNnf03nceIOfn39fn3e9h3sdfa&#39; 注意这里的 nonce- 前缀。 这也就是文章开头看到的方式，到这里明白了。 &lt;style&gt; 标签也是类似的处理。 这里的加密串一定是随机不可预测的，否则达不到安全效果，且每次页面被访问时重新生成。 除了使用 noce 指定加密串，还可以通过混淆的 hash 值来达到目的。这种做法不需要在标签上加 nonce 而是将需要内嵌的代码本身使用加密算法生成 hash 后放入 CSP 指令中作为值使用，这里的加密算法支持 sha256, sha384 和 sha512。此时 CSP 中使用的前缀为相应的算法名。 hash 方式的示例： &lt;script&gt;alert(&#39;Hello, world.&#39;);&lt;/script&gt; Content-Security-Policy: script-src &#39;sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng=&#39; eval js 中好些地方是可以以字符串方式动态创建代码并执行，这被认为是不安全的，所以不推荐使用，一般最佳实践里都会提。 setTimeout/setInterval 可接收一段字符串作为代码执行。setTimout(‘alert(1)’,1000)。 eval 。eval(‘alert(1)’)。 Function 构造函数。 new Function(‘alert(1)’)。 和内联一样，有专门的指令 unsafe-eval 以允许类似代码的执行。但建议的做法是对于 eval 和 Function 构造器，杜绝使用，而 setTimeout/setInterval 可改造为非字符串形式。 setTimout(function(){ alert(1); }, 1000) URI 除了上面的预设值，还可通过提供完整的 URI 或带通配符 * 的地址来匹配，以指定资源的合法来源。这里 URI 的规则和配置服务器的跨域响应头是一样的，参考 Same-origin policy。 *://*.example.com:* 会匹配所有 example.com 的子域名，但不包括 example.com。 http://example.com 和 http://www.example.com 是两个不同的 URI。 http://example.com:80 和 http://example.com 也是是两个不同的 URI，虽然网站默认端口就是 80 根据维基百科 Uniform Resource Identifier 页面 给出的解释，一个完整的 URI 由以下部分组成： URI = scheme:[//authority]path[?query][#fragment] 其中 authority 又包含： authority = [userinfo@]host[:port] 所以你可以认为其中某一项不同，那都是两个 URI。了解这点很重要，一如上面列出的第一条例子 *.example.com， 我们很容易先入为主地认为既然已经允许了该域名的所有子域名，那必然 example.com 也是合法的。 因为 URI 是进行动态匹配的，所以解释了上面提到的预设值缘何要加引号。因为如果不加引号的话， self 会表示 host 是 self 的资源地址，而不会表示原有的意思。 优先级 CSP 的配置是很灵活的。每条指令可指定多个来源，空格分开。而一条 CSP 规则可由多条指令组成，指令间用分号隔开。各指令间没有顺序的要求，因为每条指令都是各司其职。甚至一次响应中， Content-Security-Policy 响应头都可以重复设置。 我们来看这些情形下 CSP 的表现。 对于设置了多次响应头的情况，最严格的规则会生效。比如下面两条响应头中，虽然 第二条中设置 connect-src 允许 http://example.com/，但第一条里面设置了 connect-src 为 none，所以更加严格的 none 会生效。参见 Multiple content security policies。 Content-Security-Policy: default-src &#39;self&#39; http://example.com; connect-src &#39;none&#39;; Content-Security-Policy: connect-src http://example.com/; script-src http://example.com/ 同一指令多次指定，以第一个为准，后续的会被忽略。 csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;;default-src &#39;unsafe-inline&#39;;&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;style&gt; body{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;script&gt; window.onload=function(){ alert(&#39;hi jack!&#39;) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 重复配置同一指令时效果展示 很智能地， 浏览器不仅会将检测不过的资源及指令打印出来，重复配置时被忽略的指令也会提示出来。 指定 default-src 的情况下，它会充当 Fetch 类指令 的默认值。即 default-src 并不对所有指令生效，其他指令默认值仍是 *。 发送报告 当检测到非法资源时，除了控制台看到的报错信息，也可以让浏览器将日志发送到服务器以供后续分析使用。接收报告的地址可在 Content-Security-Policy 响应头中通过 report-uri 指令来配置。当然，服务端需要编写相应的服务来接收该数据。 Content-Security-Policy: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser; 服务端拿到的是以 JSON 形式传来的数据。 {   &quot;csp-report&quot;: {     &quot;document-uri&quot;: &quot;http://example.org/page.html&quot;,     &quot;referrer&quot;: &quot;http://evil.example.com/&quot;,     &quot;blocked-uri&quot;: &quot;http://evil.example.com/evil.js&quot;,     &quot;violated-directive&quot;: &quot;script-src &#39;self&#39; https://apis.google.com&quot;,     &quot;original-policy&quot;: &quot;script-src &#39;self&#39; https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser&quot;   } } 报告模式 CSP 提供了一种报告模式，该模式下资源不会真的被限制加载，只会对检测到的问题进行上报 ，以 JSON 数据的形式发送到 report-uri 指定的地方。 通过指定 Content-Security-Policy-Report-Only 而不是 Content-Security-Policy，则开启了报告模式。 Content-Security-Policy-Report-Only: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser; 当然，你也可以同时指定两种响应头，各自里的规则还会正常执行，不会互相影响。比如： Content-Security-Policy: img-src *; Content-Security-Policy-Report-Only: img-src ‘none’; report-uri http://reportcollector.example.com/collector.cgi 这里图片还是会正常加载，但是 img-src ‘none’ 也会检测到并且发送报告。 报告模式对于测试非常有用。在开启 CSP 之前肯定需要对整站做全面的测试，将发现的问题及时修复后再真正开启，比如上面提到的对内联代码的改造。 推荐的做法 这样的安全措施当然是能尽快启用就尽快。以下是推荐的做法： 先只开启报告模式，看影响范围，修改问题。 添加指令时从 default-src ‘none’ 开始，查看报错，逐步添加规则直至满足要求。 上线后观察一段时间，稳定后再由报告模式转到强制执行。 浏览器兼容性 目前发布的 Level 3 规范 中大部分还未被浏览器实现，通过 Can I Use 的数据 来看，除 IE 外，Level 2 的功能已经得到了很好的支持。这里还有一分来自 W3C 跟踪的各浏览器实现情况的统计：Implementation Report for Content Security Policy Level 2。 对于浏览器不支持的情况，也不必担心，会回退到同源策略的限制上。 相关资源 Why is the same origin policy so important? Content Security Policy (CSP) Content Security Policy from Web Fundamentals Improving Browser Security with CSP" />
<meta property="og:description" content="Content Security Policy (CSP) 介绍 当我不经意间在 Twitter 页面 view source 后，发现了惊喜。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Twitter&lt;/title&gt; &lt;style&gt; body { background-color: #ffffff; font-family: sans-serif; } a { color: #1da1f2; } svg { color: #1da1f2; display: block; fill: currentcolor; height: 21px; margin: 13px auto; width: 24px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;center&gt;If you’re not redirected soon, please &lt;a href=&quot;/&quot;&gt;use this link&lt;/a&gt;.&lt;/center&gt; &lt;/noscript&gt; &lt;script nonce=&quot;SG0bV9rOanQfzG0ccU8WQw==&quot;&gt; document.cookie = &quot;app_shell_visited=1;path=/;max-age=5&quot;; location.replace(location.href.split(&quot;#&quot;)[0]); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 相比平时看到的其他站点的源码，可以说是很清爽了。没有乱七八糟的标签，功能却一样不少。特别有迷惑性，以为这便是页面所有的源码，但查看 DevTools 的 Source 面板后很容易知道这并不是真实的 HTML 代码。但为何页面源码给出的是如此清爽的版本，这里先不研究。 把目光移向 script 标签时，发现一个不认识的 nonce 属性。它以及它后面的神秘字符串成功引起了我的好奇。再去看 Google 首页的源码，也有好些 nonce 的运用。是时候去了解一下这里的 nonce 是什么了。 ! &lt;script nonce=&quot;SG0bV9rOanQfzG0ccU8WQw==&quot;&gt; document.cookie = &quot;app_shell_visited=1;path=/;max-age=5&quot;; location.replace(location.href.split(&quot;#&quot;)[0]); &lt;/script&gt; Content Security Policy (CSP) 要了解 nonce， 先了解 Content-Security-Policy(CSP)。 我们都知道浏览器有同源策略（same-origin policy）的安全限制，即每个站点只允许加载来自和自身同域（origin）的数据，https://a.com 是无法从 https://b.com 加载到资源的。每个站点被严格限制在了自已的孤岛上，自己就是一个沙盒，这样很安全，整个网络不会杂乱无章。主要地，它能解决大部分安全问题。假若没有同源策略，恶意代码能够轻松在浏览器端执行然后获取各种隐私信息：银行帐号，社交数据等。 那网站间如何进行数据共享，当然是有办法的，了解下 CORS。 现实中，问题是同源策略也并不是万无一失，跨域攻击 Cross-site scripting (XSS) 便包含五花八门绕开限制的手段，形式上通过向页面注入恶意代码完成信息的窃取或攻击。比如 UGC 类型的站点，因为内容依赖用户创建，这就开了很大一个口子，允许用户输入的内容运行在页面上。当然，因为我们都知道会有注入攻击，所以对用户输入的内容进行防 XSS 过滤也成了标配。 Content-Security-Policy 从另一方面给浏览器加了层防护，能极大地减少这种攻击的发生。 原理 CSP 通过告诉浏览器一系列规则，严格规定页面中哪些资源允许有哪些来源， 不在指定范围内的统统拒绝。相比同源策略，CSP 可以说是很严格了。 其实施有两种途径： 服务器添加 Content-Security-Policy 响应头来指定规则 HTML 中添加 &lt;meta&gt; 标签来指定 Content-Security-Policy 规则 ￼ mobile.twitter.com header 中的 CSP 规则 为了测试方便，以下示例均使用 &lt;meta&gt; 标签来开启 CSP 规则。但 &lt;meta&gt; 中有些指令是不能使用的，后面会了解到。只有响应头中才能使用全部的限制指令。 一个简单示例 创建一个 HTML 文件放入以下内容： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39; https://unpkg.com&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在该测试文件所在目录开启一个本地 server 以访问，这里使用 Python 自带的 server: $ python -m SimpleHTTPServer 8000 然后访问 localhost:8000 以观察结果： ￼ 符合 CSP 规则情况下的正常访问 然后我们将 Content-Security-Policy 改成不允许任何资源再试一下： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; - &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39; https://unpkg.com&quot;&gt; + &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src ‘none’&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 触发 CSP 规则资源被 block 的情况 下面我们来解释这里设置的 CSP 规则及理解为何资源加载失败。 CSP 规则 无论是 header 中还是 &lt;meta&gt; 标签中指定，其值的格式都是统一的，由一系列 CSP 指令（directive）组合而成。 示例： Content-Security-Policy: &lt;policy-directive&gt;; &lt;policy-directive&gt;… 这里 directive，即指令，是 CSP 规范中规定用以详细详述某种资源的来源，比如前面示例中使用的 script-src，指定脚本可以有哪些合法来源，img-src 则指定图片，以下是常用指令： base-uri 限制可出现在页面 &lt;base&gt; 标签中的链接。 child-src 列出可用于 worker 及以 frame 形式嵌入的链接。 譬如: child-src https://youtube.com 表示只能从 Youtube 嵌入视频资源。 connect-src 可发起连接的地址 (通过 XHR, WebSockets 或 EventSource)。 font-src 字体来源。譬如，要使用 Google web fonts 则需要添加 font-src https://themes.googleusercontent.com 规则。 form-action &lt;form&gt; 标签可提交的地址。 frame-ancestors 当前页面可被哪些来源所嵌入（与 child-src 正好相反）。作用于 &lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt; 及 &lt;applet&gt;。 该指令不能通过 &lt;meta&gt; 指定且只对非 HTML文档类型的资源生效。 frame-src 该指令已在 level 2 中废弃但会在 level 3 中恢复使用。未指定的情况下回退到 tochild-src 指令。 img-src 指定图片来源。 media-src 限制音视频资源的来源。 object-src Flash 及其他插件的来源。 plugin-types 限制页面中可加载的插件类型。 report-uri 指定一个可接收 CSP 报告的地址，浏览器会在相应指令不通过时发送报告。不能通过 &lt;meta&gt; 标签来指定。 style-src 限制样式文件的来源。 upgrade-insecure-requests 指导客户端将页面地址重写，HTTP 转 HTTPS。用于站点中有大量旧地址需要重定向的情形。 worker-src CSP Level 3 中的指令，规定可用于 worker, shared worker, 或 service worker 中的地址。 child-src  与 frame-ancestors  看起来比较像。前者规定的是页面中可加载哪些 iframe，后者规定谁可以以 iframe 加载本页。 比如来自不同站点的两个网页 A 与 B，B 中有 iframe 加载了 A。那么 A 的 frame-ancestors 需要包含 B B 的 child-src 需要包含 A 默认情况下，这些指令都是最大条件开放的，可以理解为其默认值为 *。比如 img-src，如果不明确指定，则可以从所有地方加载图片资源。 还有种特殊的指令 default-src，如果指定了它的值，则相当于改变了这些未指定的指令的默认值。可以理解为，上面 img-src 如果没指定，本来其默认值是 *，可以加载所有来源的图片，但设置 default-src 后，默认值就成了 default-src 指定的值。 常见的做法会设置 default-src ‘self’，这样所有资源都被限制在了和页面同域下。如果此时想要加载从 CDN 来的图片，将图片来源单独添加上即可。 Content-Security-Policy: default-src ‘self’; img-src https://cdn.example.com 现在来看开头那个示例，也许现在就能看明白了。因为页面中需要从 CDN 加载 React 库，所以我们&lt;meta&gt; 标签指定了如下 CSP 规则： script-src &#39;self&#39; https://unpkg.com 这里的 self 及后来改成的 none 是预设值，需用引号包裹，否则会当成 URI 来解析。这里的 CSP 规则表示页面中脚本只能从同域及 https://unpkg.com 加载。假如我们把后者去掉，同样会像上图截图那样 React 库会加载失败，同时控制台中会有加载失败的日志及被触发的规则列出来。 改成 none 之后表示页面不加载任何脚本，即使自己站点上的脚本都无法被加载执行。这里不妨试一下在 csp_test.html 旁边创建一个脚本文件 test.js: test.js alert(‘来自 test.js 的问候！’) 同时在页面中引用它： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;none&#39;&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; + &lt;script src=&quot;./test.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 页面执行结果： script-src none 时页面将不加载任何脚本 是的，哪怕是自己的脚本也无法被加载执行。CSP 就是这样严格和明确，不存在模棱两可的情况。所以在指定来源时，我们需要确认 URI 是否正确。 指令可接受的值 指令后面跟的来源，有两种写法 预设值 URI 通配符 预设值 其中预设值有以下这些： none 不匹配任何东西。 self 匹配当前域，但不包括子域。比如 example.com 可以，api.example.com 则会匹配失败。 unsafe-inline 允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。 unsafe-eval 允许通过字符串动态创建的脚本执行，比如 eval，setTimeout 等。 特别地，在 CSP 的严格控制下，页面中内联脚本及样式也会受影响，在没有明确指定的情况下，其不能被浏览器执行。 考虑下面的代码： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;style&gt; body{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;script&gt; window.onload=function(){ alert(&#39;hi jack!&#39;) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ￼ 未指定 CSP 的情况 根据 MDN 上的描述，如果站点未指定 CSP 无则，浏览器默认不会开启相应检查，所以上面一切运行正常，只受正常的同域限制 。 If the site doesn’t offer the CSP header, browsers likewise use the standard same-origin policy. — 来自 MDN 关于 Content Security Policy (CSP) 的描述 我们加上 CSP 限制： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; + &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;style&gt; body{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;script&gt; window.onload=function(){ alert(&#39;hi jack!&#39;) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 配置站点默认只信息同域的资源，但注意，这个设置并不包含内联的情况，所以结果会如下图。 内联代码被禁止 如何修复它呢。如果我们想要允许页面内的内联脚本或样式，则需要明确地通过 script-src 和 style-src 指出来。 csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; ! &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39; ‘unsafe-inline’”&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;style&gt; body{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;script&gt; window.onload=function(){ alert(&#39;hi jack!&#39;) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这里 default-src &#39;self&#39; ‘unsave-inline’ 配置默认可信的来源有这些： 和页面同域的，以及内联的。 刷新页面，样式及脚本又可以正常执行了。 通常是不建议使用 unsafe-inline 的（同样也不推荐使用 unsafe-eval），因为内联的脚本和样式维护不便，也不利用良好地组织代码。最佳实践是样式抽离到样式文件，脚本放到单独的 js 文件中加载，让 HTML 文件纯粹一点才是好的做法。即使是 onclick=“myHandler” 或 href=“javascript:;” 这种平时常见的写法，也属于内联的脚本，是需要改造的。 如果页面中非得用内联的写法，还有种方式。即页面中这些内联的脚本或样式标签，赋值一个加密串，这个加密串由服务器生成，同时这个加密串被添加到页面的响应头里面。 &lt;script nonce=EDNnf03nceIOfn39fn3e9h3sdfa&gt;   // 这里放置内联在 HTML 中的代码 &lt;/script&gt; 页面 HTTP 响应头的 Content-Security-Policy 配置中包含相同的加密串： Content-Security-Policy: script-src &#39;nonce-EDNnf03nceIOfn39fn3e9h3sdfa&#39; 注意这里的 nonce- 前缀。 这也就是文章开头看到的方式，到这里明白了。 &lt;style&gt; 标签也是类似的处理。 这里的加密串一定是随机不可预测的，否则达不到安全效果，且每次页面被访问时重新生成。 除了使用 noce 指定加密串，还可以通过混淆的 hash 值来达到目的。这种做法不需要在标签上加 nonce 而是将需要内嵌的代码本身使用加密算法生成 hash 后放入 CSP 指令中作为值使用，这里的加密算法支持 sha256, sha384 和 sha512。此时 CSP 中使用的前缀为相应的算法名。 hash 方式的示例： &lt;script&gt;alert(&#39;Hello, world.&#39;);&lt;/script&gt; Content-Security-Policy: script-src &#39;sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng=&#39; eval js 中好些地方是可以以字符串方式动态创建代码并执行，这被认为是不安全的，所以不推荐使用，一般最佳实践里都会提。 setTimeout/setInterval 可接收一段字符串作为代码执行。setTimout(‘alert(1)’,1000)。 eval 。eval(‘alert(1)’)。 Function 构造函数。 new Function(‘alert(1)’)。 和内联一样，有专门的指令 unsafe-eval 以允许类似代码的执行。但建议的做法是对于 eval 和 Function 构造器，杜绝使用，而 setTimeout/setInterval 可改造为非字符串形式。 setTimout(function(){ alert(1); }, 1000) URI 除了上面的预设值，还可通过提供完整的 URI 或带通配符 * 的地址来匹配，以指定资源的合法来源。这里 URI 的规则和配置服务器的跨域响应头是一样的，参考 Same-origin policy。 *://*.example.com:* 会匹配所有 example.com 的子域名，但不包括 example.com。 http://example.com 和 http://www.example.com 是两个不同的 URI。 http://example.com:80 和 http://example.com 也是是两个不同的 URI，虽然网站默认端口就是 80 根据维基百科 Uniform Resource Identifier 页面 给出的解释，一个完整的 URI 由以下部分组成： URI = scheme:[//authority]path[?query][#fragment] 其中 authority 又包含： authority = [userinfo@]host[:port] 所以你可以认为其中某一项不同，那都是两个 URI。了解这点很重要，一如上面列出的第一条例子 *.example.com， 我们很容易先入为主地认为既然已经允许了该域名的所有子域名，那必然 example.com 也是合法的。 因为 URI 是进行动态匹配的，所以解释了上面提到的预设值缘何要加引号。因为如果不加引号的话， self 会表示 host 是 self 的资源地址，而不会表示原有的意思。 优先级 CSP 的配置是很灵活的。每条指令可指定多个来源，空格分开。而一条 CSP 规则可由多条指令组成，指令间用分号隔开。各指令间没有顺序的要求，因为每条指令都是各司其职。甚至一次响应中， Content-Security-Policy 响应头都可以重复设置。 我们来看这些情形下 CSP 的表现。 对于设置了多次响应头的情况，最严格的规则会生效。比如下面两条响应头中，虽然 第二条中设置 connect-src 允许 http://example.com/，但第一条里面设置了 connect-src 为 none，所以更加严格的 none 会生效。参见 Multiple content security policies。 Content-Security-Policy: default-src &#39;self&#39; http://example.com; connect-src &#39;none&#39;; Content-Security-Policy: connect-src http://example.com/; script-src http://example.com/ 同一指令多次指定，以第一个为准，后续的会被忽略。 csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;;default-src &#39;unsafe-inline&#39;;&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;style&gt; body{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;script&gt; window.onload=function(){ alert(&#39;hi jack!&#39;) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 重复配置同一指令时效果展示 很智能地， 浏览器不仅会将检测不过的资源及指令打印出来，重复配置时被忽略的指令也会提示出来。 指定 default-src 的情况下，它会充当 Fetch 类指令 的默认值。即 default-src 并不对所有指令生效，其他指令默认值仍是 *。 发送报告 当检测到非法资源时，除了控制台看到的报错信息，也可以让浏览器将日志发送到服务器以供后续分析使用。接收报告的地址可在 Content-Security-Policy 响应头中通过 report-uri 指令来配置。当然，服务端需要编写相应的服务来接收该数据。 Content-Security-Policy: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser; 服务端拿到的是以 JSON 形式传来的数据。 {   &quot;csp-report&quot;: {     &quot;document-uri&quot;: &quot;http://example.org/page.html&quot;,     &quot;referrer&quot;: &quot;http://evil.example.com/&quot;,     &quot;blocked-uri&quot;: &quot;http://evil.example.com/evil.js&quot;,     &quot;violated-directive&quot;: &quot;script-src &#39;self&#39; https://apis.google.com&quot;,     &quot;original-policy&quot;: &quot;script-src &#39;self&#39; https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser&quot;   } } 报告模式 CSP 提供了一种报告模式，该模式下资源不会真的被限制加载，只会对检测到的问题进行上报 ，以 JSON 数据的形式发送到 report-uri 指定的地方。 通过指定 Content-Security-Policy-Report-Only 而不是 Content-Security-Policy，则开启了报告模式。 Content-Security-Policy-Report-Only: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser; 当然，你也可以同时指定两种响应头，各自里的规则还会正常执行，不会互相影响。比如： Content-Security-Policy: img-src *; Content-Security-Policy-Report-Only: img-src ‘none’; report-uri http://reportcollector.example.com/collector.cgi 这里图片还是会正常加载，但是 img-src ‘none’ 也会检测到并且发送报告。 报告模式对于测试非常有用。在开启 CSP 之前肯定需要对整站做全面的测试，将发现的问题及时修复后再真正开启，比如上面提到的对内联代码的改造。 推荐的做法 这样的安全措施当然是能尽快启用就尽快。以下是推荐的做法： 先只开启报告模式，看影响范围，修改问题。 添加指令时从 default-src ‘none’ 开始，查看报错，逐步添加规则直至满足要求。 上线后观察一段时间，稳定后再由报告模式转到强制执行。 浏览器兼容性 目前发布的 Level 3 规范 中大部分还未被浏览器实现，通过 Can I Use 的数据 来看，除 IE 外，Level 2 的功能已经得到了很好的支持。这里还有一分来自 W3C 跟踪的各浏览器实现情况的统计：Implementation Report for Content Security Policy Level 2。 对于浏览器不支持的情况，也不必担心，会回退到同源策略的限制上。 相关资源 Why is the same origin policy so important? Content Security Policy (CSP) Content Security Policy from Web Fundamentals Improving Browser Security with CSP" />
<link rel="canonical" href="http://localhost:4000/2018/08/13/Content-Security-Policy-(CSP)-%E4%BB%8B%E7%BB%8D.html" />
<meta property="og:url" content="http://localhost:4000/2018/08/13/Content-Security-Policy-(CSP)-%E4%BB%8B%E7%BB%8D.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-13T01:08:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2018/08/13/Content-Security-Policy-(CSP)-%E4%BB%8B%E7%BB%8D.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/08/13/Content-Security-Policy-(CSP)-%E4%BB%8B%E7%BB%8D.html"},"description":"Content Security Policy (CSP) 介绍 当我不经意间在 Twitter 页面 view source 后，发现了惊喜。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Twitter&lt;/title&gt; &lt;style&gt; body { background-color: #ffffff; font-family: sans-serif; } a { color: #1da1f2; } svg { color: #1da1f2; display: block; fill: currentcolor; height: 21px; margin: 13px auto; width: 24px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;center&gt;If you’re not redirected soon, please &lt;a href=&quot;/&quot;&gt;use this link&lt;/a&gt;.&lt;/center&gt; &lt;/noscript&gt; &lt;script nonce=&quot;SG0bV9rOanQfzG0ccU8WQw==&quot;&gt; document.cookie = &quot;app_shell_visited=1;path=/;max-age=5&quot;; location.replace(location.href.split(&quot;#&quot;)[0]); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 相比平时看到的其他站点的源码，可以说是很清爽了。没有乱七八糟的标签，功能却一样不少。特别有迷惑性，以为这便是页面所有的源码，但查看 DevTools 的 Source 面板后很容易知道这并不是真实的 HTML 代码。但为何页面源码给出的是如此清爽的版本，这里先不研究。 把目光移向 script 标签时，发现一个不认识的 nonce 属性。它以及它后面的神秘字符串成功引起了我的好奇。再去看 Google 首页的源码，也有好些 nonce 的运用。是时候去了解一下这里的 nonce 是什么了。 ! &lt;script nonce=&quot;SG0bV9rOanQfzG0ccU8WQw==&quot;&gt; document.cookie = &quot;app_shell_visited=1;path=/;max-age=5&quot;; location.replace(location.href.split(&quot;#&quot;)[0]); &lt;/script&gt; Content Security Policy (CSP) 要了解 nonce， 先了解 Content-Security-Policy(CSP)。 我们都知道浏览器有同源策略（same-origin policy）的安全限制，即每个站点只允许加载来自和自身同域（origin）的数据，https://a.com 是无法从 https://b.com 加载到资源的。每个站点被严格限制在了自已的孤岛上，自己就是一个沙盒，这样很安全，整个网络不会杂乱无章。主要地，它能解决大部分安全问题。假若没有同源策略，恶意代码能够轻松在浏览器端执行然后获取各种隐私信息：银行帐号，社交数据等。 那网站间如何进行数据共享，当然是有办法的，了解下 CORS。 现实中，问题是同源策略也并不是万无一失，跨域攻击 Cross-site scripting (XSS) 便包含五花八门绕开限制的手段，形式上通过向页面注入恶意代码完成信息的窃取或攻击。比如 UGC 类型的站点，因为内容依赖用户创建，这就开了很大一个口子，允许用户输入的内容运行在页面上。当然，因为我们都知道会有注入攻击，所以对用户输入的内容进行防 XSS 过滤也成了标配。 Content-Security-Policy 从另一方面给浏览器加了层防护，能极大地减少这种攻击的发生。 原理 CSP 通过告诉浏览器一系列规则，严格规定页面中哪些资源允许有哪些来源， 不在指定范围内的统统拒绝。相比同源策略，CSP 可以说是很严格了。 其实施有两种途径： 服务器添加 Content-Security-Policy 响应头来指定规则 HTML 中添加 &lt;meta&gt; 标签来指定 Content-Security-Policy 规则 ￼ mobile.twitter.com header 中的 CSP 规则 为了测试方便，以下示例均使用 &lt;meta&gt; 标签来开启 CSP 规则。但 &lt;meta&gt; 中有些指令是不能使用的，后面会了解到。只有响应头中才能使用全部的限制指令。 一个简单示例 创建一个 HTML 文件放入以下内容： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39; https://unpkg.com&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在该测试文件所在目录开启一个本地 server 以访问，这里使用 Python 自带的 server: $ python -m SimpleHTTPServer 8000 然后访问 localhost:8000 以观察结果： ￼ 符合 CSP 规则情况下的正常访问 然后我们将 Content-Security-Policy 改成不允许任何资源再试一下： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; - &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39; https://unpkg.com&quot;&gt; + &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src ‘none’&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 触发 CSP 规则资源被 block 的情况 下面我们来解释这里设置的 CSP 规则及理解为何资源加载失败。 CSP 规则 无论是 header 中还是 &lt;meta&gt; 标签中指定，其值的格式都是统一的，由一系列 CSP 指令（directive）组合而成。 示例： Content-Security-Policy: &lt;policy-directive&gt;; &lt;policy-directive&gt;… 这里 directive，即指令，是 CSP 规范中规定用以详细详述某种资源的来源，比如前面示例中使用的 script-src，指定脚本可以有哪些合法来源，img-src 则指定图片，以下是常用指令： base-uri 限制可出现在页面 &lt;base&gt; 标签中的链接。 child-src 列出可用于 worker 及以 frame 形式嵌入的链接。 譬如: child-src https://youtube.com 表示只能从 Youtube 嵌入视频资源。 connect-src 可发起连接的地址 (通过 XHR, WebSockets 或 EventSource)。 font-src 字体来源。譬如，要使用 Google web fonts 则需要添加 font-src https://themes.googleusercontent.com 规则。 form-action &lt;form&gt; 标签可提交的地址。 frame-ancestors 当前页面可被哪些来源所嵌入（与 child-src 正好相反）。作用于 &lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt; 及 &lt;applet&gt;。 该指令不能通过 &lt;meta&gt; 指定且只对非 HTML文档类型的资源生效。 frame-src 该指令已在 level 2 中废弃但会在 level 3 中恢复使用。未指定的情况下回退到 tochild-src 指令。 img-src 指定图片来源。 media-src 限制音视频资源的来源。 object-src Flash 及其他插件的来源。 plugin-types 限制页面中可加载的插件类型。 report-uri 指定一个可接收 CSP 报告的地址，浏览器会在相应指令不通过时发送报告。不能通过 &lt;meta&gt; 标签来指定。 style-src 限制样式文件的来源。 upgrade-insecure-requests 指导客户端将页面地址重写，HTTP 转 HTTPS。用于站点中有大量旧地址需要重定向的情形。 worker-src CSP Level 3 中的指令，规定可用于 worker, shared worker, 或 service worker 中的地址。 child-src  与 frame-ancestors  看起来比较像。前者规定的是页面中可加载哪些 iframe，后者规定谁可以以 iframe 加载本页。 比如来自不同站点的两个网页 A 与 B，B 中有 iframe 加载了 A。那么 A 的 frame-ancestors 需要包含 B B 的 child-src 需要包含 A 默认情况下，这些指令都是最大条件开放的，可以理解为其默认值为 *。比如 img-src，如果不明确指定，则可以从所有地方加载图片资源。 还有种特殊的指令 default-src，如果指定了它的值，则相当于改变了这些未指定的指令的默认值。可以理解为，上面 img-src 如果没指定，本来其默认值是 *，可以加载所有来源的图片，但设置 default-src 后，默认值就成了 default-src 指定的值。 常见的做法会设置 default-src ‘self’，这样所有资源都被限制在了和页面同域下。如果此时想要加载从 CDN 来的图片，将图片来源单独添加上即可。 Content-Security-Policy: default-src ‘self’; img-src https://cdn.example.com 现在来看开头那个示例，也许现在就能看明白了。因为页面中需要从 CDN 加载 React 库，所以我们&lt;meta&gt; 标签指定了如下 CSP 规则： script-src &#39;self&#39; https://unpkg.com 这里的 self 及后来改成的 none 是预设值，需用引号包裹，否则会当成 URI 来解析。这里的 CSP 规则表示页面中脚本只能从同域及 https://unpkg.com 加载。假如我们把后者去掉，同样会像上图截图那样 React 库会加载失败，同时控制台中会有加载失败的日志及被触发的规则列出来。 改成 none 之后表示页面不加载任何脚本，即使自己站点上的脚本都无法被加载执行。这里不妨试一下在 csp_test.html 旁边创建一个脚本文件 test.js: test.js alert(‘来自 test.js 的问候！’) 同时在页面中引用它： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;none&#39;&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; + &lt;script src=&quot;./test.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 页面执行结果： script-src none 时页面将不加载任何脚本 是的，哪怕是自己的脚本也无法被加载执行。CSP 就是这样严格和明确，不存在模棱两可的情况。所以在指定来源时，我们需要确认 URI 是否正确。 指令可接受的值 指令后面跟的来源，有两种写法 预设值 URI 通配符 预设值 其中预设值有以下这些： none 不匹配任何东西。 self 匹配当前域，但不包括子域。比如 example.com 可以，api.example.com 则会匹配失败。 unsafe-inline 允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。 unsafe-eval 允许通过字符串动态创建的脚本执行，比如 eval，setTimeout 等。 特别地，在 CSP 的严格控制下，页面中内联脚本及样式也会受影响，在没有明确指定的情况下，其不能被浏览器执行。 考虑下面的代码： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;style&gt; body{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;script&gt; window.onload=function(){ alert(&#39;hi jack!&#39;) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ￼ 未指定 CSP 的情况 根据 MDN 上的描述，如果站点未指定 CSP 无则，浏览器默认不会开启相应检查，所以上面一切运行正常，只受正常的同域限制 。 If the site doesn’t offer the CSP header, browsers likewise use the standard same-origin policy. — 来自 MDN 关于 Content Security Policy (CSP) 的描述 我们加上 CSP 限制： csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; + &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;style&gt; body{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;script&gt; window.onload=function(){ alert(&#39;hi jack!&#39;) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 配置站点默认只信息同域的资源，但注意，这个设置并不包含内联的情况，所以结果会如下图。 内联代码被禁止 如何修复它呢。如果我们想要允许页面内的内联脚本或样式，则需要明确地通过 script-src 和 style-src 指出来。 csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; ! &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39; ‘unsafe-inline’”&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;style&gt; body{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;script&gt; window.onload=function(){ alert(&#39;hi jack!&#39;) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这里 default-src &#39;self&#39; ‘unsave-inline’ 配置默认可信的来源有这些： 和页面同域的，以及内联的。 刷新页面，样式及脚本又可以正常执行了。 通常是不建议使用 unsafe-inline 的（同样也不推荐使用 unsafe-eval），因为内联的脚本和样式维护不便，也不利用良好地组织代码。最佳实践是样式抽离到样式文件，脚本放到单独的 js 文件中加载，让 HTML 文件纯粹一点才是好的做法。即使是 onclick=“myHandler” 或 href=“javascript:;” 这种平时常见的写法，也属于内联的脚本，是需要改造的。 如果页面中非得用内联的写法，还有种方式。即页面中这些内联的脚本或样式标签，赋值一个加密串，这个加密串由服务器生成，同时这个加密串被添加到页面的响应头里面。 &lt;script nonce=EDNnf03nceIOfn39fn3e9h3sdfa&gt;   // 这里放置内联在 HTML 中的代码 &lt;/script&gt; 页面 HTTP 响应头的 Content-Security-Policy 配置中包含相同的加密串： Content-Security-Policy: script-src &#39;nonce-EDNnf03nceIOfn39fn3e9h3sdfa&#39; 注意这里的 nonce- 前缀。 这也就是文章开头看到的方式，到这里明白了。 &lt;style&gt; 标签也是类似的处理。 这里的加密串一定是随机不可预测的，否则达不到安全效果，且每次页面被访问时重新生成。 除了使用 noce 指定加密串，还可以通过混淆的 hash 值来达到目的。这种做法不需要在标签上加 nonce 而是将需要内嵌的代码本身使用加密算法生成 hash 后放入 CSP 指令中作为值使用，这里的加密算法支持 sha256, sha384 和 sha512。此时 CSP 中使用的前缀为相应的算法名。 hash 方式的示例： &lt;script&gt;alert(&#39;Hello, world.&#39;);&lt;/script&gt; Content-Security-Policy: script-src &#39;sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng=&#39; eval js 中好些地方是可以以字符串方式动态创建代码并执行，这被认为是不安全的，所以不推荐使用，一般最佳实践里都会提。 setTimeout/setInterval 可接收一段字符串作为代码执行。setTimout(‘alert(1)’,1000)。 eval 。eval(‘alert(1)’)。 Function 构造函数。 new Function(‘alert(1)’)。 和内联一样，有专门的指令 unsafe-eval 以允许类似代码的执行。但建议的做法是对于 eval 和 Function 构造器，杜绝使用，而 setTimeout/setInterval 可改造为非字符串形式。 setTimout(function(){ alert(1); }, 1000) URI 除了上面的预设值，还可通过提供完整的 URI 或带通配符 * 的地址来匹配，以指定资源的合法来源。这里 URI 的规则和配置服务器的跨域响应头是一样的，参考 Same-origin policy。 *://*.example.com:* 会匹配所有 example.com 的子域名，但不包括 example.com。 http://example.com 和 http://www.example.com 是两个不同的 URI。 http://example.com:80 和 http://example.com 也是是两个不同的 URI，虽然网站默认端口就是 80 根据维基百科 Uniform Resource Identifier 页面 给出的解释，一个完整的 URI 由以下部分组成： URI = scheme:[//authority]path[?query][#fragment] 其中 authority 又包含： authority = [userinfo@]host[:port] 所以你可以认为其中某一项不同，那都是两个 URI。了解这点很重要，一如上面列出的第一条例子 *.example.com， 我们很容易先入为主地认为既然已经允许了该域名的所有子域名，那必然 example.com 也是合法的。 因为 URI 是进行动态匹配的，所以解释了上面提到的预设值缘何要加引号。因为如果不加引号的话， self 会表示 host 是 self 的资源地址，而不会表示原有的意思。 优先级 CSP 的配置是很灵活的。每条指令可指定多个来源，空格分开。而一条 CSP 规则可由多条指令组成，指令间用分号隔开。各指令间没有顺序的要求，因为每条指令都是各司其职。甚至一次响应中， Content-Security-Policy 响应头都可以重复设置。 我们来看这些情形下 CSP 的表现。 对于设置了多次响应头的情况，最严格的规则会生效。比如下面两条响应头中，虽然 第二条中设置 connect-src 允许 http://example.com/，但第一条里面设置了 connect-src 为 none，所以更加严格的 none 会生效。参见 Multiple content security policies。 Content-Security-Policy: default-src &#39;self&#39; http://example.com; connect-src &#39;none&#39;; Content-Security-Policy: connect-src http://example.com/; script-src http://example.com/ 同一指令多次指定，以第一个为准，后续的会被忽略。 csp_test.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;;default-src &#39;unsafe-inline&#39;;&quot;&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;style&gt; body{ color:red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;script&gt; window.onload=function(){ alert(&#39;hi jack!&#39;) } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 重复配置同一指令时效果展示 很智能地， 浏览器不仅会将检测不过的资源及指令打印出来，重复配置时被忽略的指令也会提示出来。 指定 default-src 的情况下，它会充当 Fetch 类指令 的默认值。即 default-src 并不对所有指令生效，其他指令默认值仍是 *。 发送报告 当检测到非法资源时，除了控制台看到的报错信息，也可以让浏览器将日志发送到服务器以供后续分析使用。接收报告的地址可在 Content-Security-Policy 响应头中通过 report-uri 指令来配置。当然，服务端需要编写相应的服务来接收该数据。 Content-Security-Policy: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser; 服务端拿到的是以 JSON 形式传来的数据。 {   &quot;csp-report&quot;: {     &quot;document-uri&quot;: &quot;http://example.org/page.html&quot;,     &quot;referrer&quot;: &quot;http://evil.example.com/&quot;,     &quot;blocked-uri&quot;: &quot;http://evil.example.com/evil.js&quot;,     &quot;violated-directive&quot;: &quot;script-src &#39;self&#39; https://apis.google.com&quot;,     &quot;original-policy&quot;: &quot;script-src &#39;self&#39; https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser&quot;   } } 报告模式 CSP 提供了一种报告模式，该模式下资源不会真的被限制加载，只会对检测到的问题进行上报 ，以 JSON 数据的形式发送到 report-uri 指定的地方。 通过指定 Content-Security-Policy-Report-Only 而不是 Content-Security-Policy，则开启了报告模式。 Content-Security-Policy-Report-Only: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser; 当然，你也可以同时指定两种响应头，各自里的规则还会正常执行，不会互相影响。比如： Content-Security-Policy: img-src *; Content-Security-Policy-Report-Only: img-src ‘none’; report-uri http://reportcollector.example.com/collector.cgi 这里图片还是会正常加载，但是 img-src ‘none’ 也会检测到并且发送报告。 报告模式对于测试非常有用。在开启 CSP 之前肯定需要对整站做全面的测试，将发现的问题及时修复后再真正开启，比如上面提到的对内联代码的改造。 推荐的做法 这样的安全措施当然是能尽快启用就尽快。以下是推荐的做法： 先只开启报告模式，看影响范围，修改问题。 添加指令时从 default-src ‘none’ 开始，查看报错，逐步添加规则直至满足要求。 上线后观察一段时间，稳定后再由报告模式转到强制执行。 浏览器兼容性 目前发布的 Level 3 规范 中大部分还未被浏览器实现，通过 Can I Use 的数据 来看，除 IE 外，Level 2 的功能已经得到了很好的支持。这里还有一分来自 W3C 跟踪的各浏览器实现情况的统计：Implementation Report for Content Security Policy Level 2。 对于浏览器不支持的情况，也不必担心，会回退到同源策略的限制上。 相关资源 Why is the same origin policy so important? Content Security Policy (CSP) Content Security Policy from Web Fundamentals Improving Browser Security with CSP","@type":"BlogPosting","headline":"Content Security Policy (CSP) 介绍","dateModified":"2018-08-13T01:08:00+08:00","datePublished":"2018-08-13T01:08:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Content Security Policy (CSP) 介绍</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-08-13T01:08:00+08:00" itemprop="datePublished">Aug 13, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="content-security-policy-csp-介绍">Content Security Policy (CSP) 介绍</h1>

<p>当我不经意间在 Twitter 页面 <code class="language-plaintext highlighter-rouge">view source</code> 后，发现了惊喜。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;title&gt;</span>Twitter<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;style&gt;</span>
  <span class="nt">body</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span> <span class="m">#ffffff</span><span class="p">;</span>
    <span class="nl">font-family</span><span class="p">:</span> <span class="nb">sans-serif</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nt">a</span> <span class="p">{</span>
    <span class="nl">color</span><span class="p">:</span> <span class="m">#1da1f2</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nt">svg</span> <span class="p">{</span>
    <span class="nl">color</span><span class="p">:</span> <span class="m">#1da1f2</span><span class="p">;</span>
    <span class="nl">display</span><span class="p">:</span> <span class="nb">block</span><span class="p">;</span>
    <span class="py">fill</span><span class="p">:</span> <span class="n">currentcolor</span><span class="p">;</span>
    <span class="nl">height</span><span class="p">:</span> <span class="m">21px</span><span class="p">;</span>
    <span class="nl">margin</span><span class="p">:</span> <span class="m">13px</span> <span class="nb">auto</span><span class="p">;</span>
    <span class="nl">width</span><span class="p">:</span> <span class="m">24px</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nt">&lt;/style&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;noscript&gt;</span>
      
      <span class="nt">&lt;center&gt;</span>If you’re not redirected soon, please <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/"</span><span class="nt">&gt;</span>use this link<span class="nt">&lt;/a&gt;</span>.<span class="nt">&lt;/center&gt;</span>
    <span class="nt">&lt;/noscript&gt;</span>
    <span class="nt">&lt;script </span><span class="na">nonce=</span><span class="s">"SG0bV9rOanQfzG0ccU8WQw=="</span><span class="nt">&gt;</span>
      
      <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">app_shell_visited=1;path=/;max-age=5</span><span class="dl">"</span><span class="p">;</span>
      
      <span class="nx">location</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">#</span><span class="dl">"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>相比平时看到的其他站点的源码，可以说是很清爽了。没有乱七八糟的标签，功能却一样不少。特别有迷惑性，以为这便是页面所有的源码，但查看 DevTools 的 Source 面板后很容易知道这并不是真实的 HTML 代码。但为何页面源码给出的是如此清爽的版本，这里先不研究。</p>

<p>把目光移向 script 标签时，发现一个不认识的 <code class="language-plaintext highlighter-rouge">nonce</code> 属性。它以及它后面的神秘字符串成功引起了我的好奇。再去看 Google 首页的源码，也有好些 <code class="language-plaintext highlighter-rouge">nonce</code> 的运用。是时候去了解一下这里的 <code class="language-plaintext highlighter-rouge">nonce</code> 是什么了。</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gs">! &lt;script nonce="SG0bV9rOanQfzG0ccU8WQw=="&gt;
</span>      
      document.cookie = "app_shell_visited=1;path=/;max-age=5";
      
      location.replace(location.href.split("#")[0]);
    &lt;/script&gt;
</code></pre></div></div>

<h3 id="content-security-policy-csp">Content Security Policy (CSP)</h3>

<p>要了解  <code class="language-plaintext highlighter-rouge">nonce</code>， 先了解 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">Content-Security-Policy(CSP)</a>。</p>

<p>我们都知道浏览器有同源策略（<a href="https://en.wikipedia.org/wiki/Same-origin_policy">same-origin policy</a>）的安全限制，即每个站点只允许加载来自和自身同域（origin）的数据，<code class="language-plaintext highlighter-rouge">https://a.com</code> 是无法从 <code class="language-plaintext highlighter-rouge">https://b.com</code> 加载到资源的。每个站点被严格限制在了自已的孤岛上，自己就是一个沙盒，这样很安全，整个网络不会杂乱无章。主要地，它能解决大部分安全问题。假若没有同源策略，恶意代码能够轻松在浏览器端执行然后获取各种隐私信息：银行帐号，社交数据等。</p>

<blockquote>
  <p>那网站间如何进行数据共享，当然是有办法的，了解下 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS</a>。</p>
</blockquote>

<p>现实中，问题是同源策略也并不是万无一失，跨域攻击 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">Cross-site scripting (XSS)</a> 便包含五花八门绕开限制的手段，形式上通过向页面注入恶意代码完成信息的窃取或攻击。比如 UGC 类型的站点，因为内容依赖用户创建，这就开了很大一个口子，允许用户输入的内容运行在页面上。当然，因为我们都知道会有注入攻击，所以对用户输入的内容进行防 XSS 过滤也成了标配。</p>

<p>Content-Security-Policy 从另一方面给浏览器加了层防护，能极大地减少这种攻击的发生。</p>

<h3 id="原理">原理</h3>

<p>CSP 通过告诉浏览器一系列规则，严格规定页面中哪些资源允许有哪些来源， 不在指定范围内的统统拒绝。相比同源策略，CSP 可以说是很严格了。</p>

<p>其实施有两种途径：</p>
<ul>
  <li>服务器添加  <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code> 响应头来指定规则</li>
  <li>HTML 中添加 <code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 标签来指定  <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code> 规则</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/3783096/44004494-f3c9bdf2-9e95-11e8-8793-e2966d79ecae.png" alt="mobile.twitter.com header 中的 CSP 规则" />￼
<em>mobile.twitter.com header 中的 CSP 规则</em></p>

<p>为了测试方便，以下示例均使用 <code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 标签来开启 CSP 规则。但 <code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 中有些指令是不能使用的，后面会了解到。只有响应头中才能使用全部的限制指令。</p>

<h4 id="一个简单示例">一个简单示例</h4>

<p>创建一个 HTML 文件放入以下内容：</p>

<p><em>csp_test.html</em></p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Content-Security-Policy"</span> <span class="na">content=</span><span class="s">"script-src 'self' https://unpkg.com"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>CSP Test<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://unpkg.com/react@16/umd/react.development.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>在该测试文件所在目录开启一个本地 server 以访问，这里使用 Python 自带的 server:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python <span class="nt">-m</span> SimpleHTTPServer 8000
</code></pre></div></div>

<p>然后访问 <a href="localhost:8000">localhost:8000</a> 以观察结果：</p>

<p><img src="https://user-images.githubusercontent.com/3783096/44004498-fdd37004-9e95-11e8-895d-53797ae105c1.png" alt="符合 CSP 规则情况下的正常访问" />￼
<em>符合 CSP 规则情况下的正常访问</em></p>

<p>然后我们将  <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code> 改成不允许任何资源再试一下：</p>

<p><em>csp_test.html</em></p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
-     &lt;meta http-equiv="Content-Security-Policy" content="script-src 'self' https://unpkg.com"&gt;
</span><span class="gi">+     &lt;meta http-equiv="Content-Security-Policy" content="script-src ‘none’"&gt;
</span>    &lt;title&gt;CSP Test&lt;/title&gt;
<span class="gd">&lt;/head&gt;
&lt;body&gt;
</span>    &lt;script src="https://unpkg.com/react@16/umd/react.development.js"&gt;&lt;/script&gt;
<span class="gd">&lt;/body&gt;
&lt;/html&gt;
</span></code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/3783096/44004501-0fac3a18-9e96-11e8-98bf-01e77f4a5e6a.png" alt="触发 CSP 规则资源被 block 的情况" />
<em>触发 CSP 规则资源被 block 的情况</em></p>

<p>下面我们来解释这里设置的 CSP 规则及理解为何资源加载失败。</p>

<h4 id="csp-规则">CSP 规则</h4>

<p>无论是 header 中还是 <code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 标签中指定，其值的格式都是统一的，由一系列 CSP 指令（directive）组合而成。</p>

<p>示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: &lt;policy-directive&gt;; &lt;policy-directive&gt;…
</code></pre></div></div>

<p>这里 directive，即指令，是 CSP 规范中规定用以详细详述某种资源的来源，比如前面示例中使用的 <code class="language-plaintext highlighter-rouge">script-src</code>，指定脚本可以有哪些合法来源，<code class="language-plaintext highlighter-rouge">img-src</code> 则指定图片，以下是常用指令：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">base-uri</code> 限制可出现在页面 <code class="language-plaintext highlighter-rouge">&lt;base&gt;</code> 标签中的链接。</li>
  <li><code class="language-plaintext highlighter-rouge">child-src</code> 列出可用于 worker 及以 frame 形式嵌入的链接。 譬如: <code class="language-plaintext highlighter-rouge">child-src https://youtube.com</code> 表示只能从 Youtube 嵌入视频资源。</li>
  <li><code class="language-plaintext highlighter-rouge">connect-src</code> 可发起连接的地址 (通过 XHR, WebSockets 或 EventSource)。</li>
  <li><code class="language-plaintext highlighter-rouge">font-src</code> 字体来源。譬如，要使用 Google web fonts 则需要添加 <code class="language-plaintext highlighter-rouge">font-src https://themes.googleusercontent.com</code> 规则。</li>
  <li><code class="language-plaintext highlighter-rouge">form-action</code> <code class="language-plaintext highlighter-rouge">&lt;form&gt;</code> 标签可提交的地址。</li>
  <li><code class="language-plaintext highlighter-rouge">frame-ancestors</code> 当前页面可被哪些来源所嵌入（与 <code class="language-plaintext highlighter-rouge">child-src</code> 正好相反）。作用于 <code class="language-plaintext highlighter-rouge">&lt;frame&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;embed&gt;</code> 及 <code class="language-plaintext highlighter-rouge">&lt;applet&gt;</code>。 该指令不能通过 <code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 指定且只对非 HTML文档类型的资源生效。</li>
  <li><code class="language-plaintext highlighter-rouge">frame-src</code> 该指令已在 level 2 中废弃但会在 level 3 中恢复使用。未指定的情况下回退到 <code class="language-plaintext highlighter-rouge">tochild-src</code> 指令。</li>
  <li><code class="language-plaintext highlighter-rouge">img-src</code> 指定图片来源。</li>
  <li><code class="language-plaintext highlighter-rouge">media-src</code> 限制音视频资源的来源。</li>
  <li><code class="language-plaintext highlighter-rouge">object-src</code> Flash 及其他插件的来源。</li>
  <li><code class="language-plaintext highlighter-rouge">plugin-types</code> 限制页面中可加载的插件类型。</li>
  <li><code class="language-plaintext highlighter-rouge">report-uri</code> 指定一个可接收 CSP 报告的地址，浏览器会在相应指令不通过时发送报告。不能通过 <code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 标签来指定。</li>
  <li><code class="language-plaintext highlighter-rouge">style-src</code> 限制样式文件的来源。</li>
  <li><code class="language-plaintext highlighter-rouge">upgrade-insecure-requests</code> 指导客户端将页面地址重写，HTTP 转 HTTPS。用于站点中有大量旧地址需要重定向的情形。</li>
  <li><code class="language-plaintext highlighter-rouge">worker-src</code> CSP Level 3 中的指令，规定可用于 worker, shared worker, 或 service worker 中的地址。</li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">child-src</code>  与 <code class="language-plaintext highlighter-rouge">frame-ancestors</code>  看起来比较像。前者规定的是页面中可加载哪些 iframe，后者规定谁可以以 iframe 加载本页。 比如来自不同站点的两个网页 A 与 B，B 中有 iframe 加载了 A。那么</p>
  <ul>
    <li>A 的 <code class="language-plaintext highlighter-rouge">frame-ancestors</code> 需要包含 B</li>
    <li>B 的 <code class="language-plaintext highlighter-rouge">child-src</code> 需要包含 A</li>
  </ul>
</blockquote>

<p>默认情况下，这些指令都是最大条件开放的，可以理解为其默认值为 <code class="language-plaintext highlighter-rouge">*</code>。比如 <code class="language-plaintext highlighter-rouge">img-src</code>，如果不明确指定，则可以从所有地方加载图片资源。</p>

<p>还有种特殊的指令 <code class="language-plaintext highlighter-rouge">default-src</code>，如果指定了它的值，则相当于改变了这些未指定的指令的默认值。可以理解为，上面 <code class="language-plaintext highlighter-rouge">img-src</code> 如果没指定，本来其默认值是 <code class="language-plaintext highlighter-rouge">*</code>，可以加载所有来源的图片，但设置 <code class="language-plaintext highlighter-rouge">default-src</code> 后，默认值就成了 <code class="language-plaintext highlighter-rouge">default-src</code> 指定的值。</p>

<p>常见的做法会设置 <code class="language-plaintext highlighter-rouge">default-src ‘self’</code>，这样所有资源都被限制在了和页面同域下。如果此时想要加载从 CDN 来的图片，将图片来源单独添加上即可。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: default-src ‘self’; img-src https://cdn.example.com
</code></pre></div></div>

<p>现在来看开头那个示例，也许现在就能看明白了。因为页面中需要从 CDN 加载 React 库，所以我们<code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 标签指定了如下 CSP 规则：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>script-src 'self' https://unpkg.com
</code></pre></div></div>

<p>这里的 <code class="language-plaintext highlighter-rouge">self</code> 及后来改成的 <code class="language-plaintext highlighter-rouge">none</code> 是预设值，需用引号包裹，否则会当成 URI 来解析。这里的 CSP 规则表示页面中脚本只能从同域及 <code class="language-plaintext highlighter-rouge">https://unpkg.com</code> 加载。假如我们把后者去掉，同样会像上图截图那样 React 库会加载失败，同时控制台中会有加载失败的日志及被触发的规则列出来。</p>

<p>改成 <code class="language-plaintext highlighter-rouge">none</code> 之后表示页面不加载任何脚本，即使自己站点上的脚本都无法被加载执行。这里不妨试一下在 <code class="language-plaintext highlighter-rouge">csp_test.html</code> 旁边创建一个脚本文件 <code class="language-plaintext highlighter-rouge">test.js</code>:</p>

<p><em>test.js</em></p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">alert</span><span class="p">(</span><span class="err">‘</span><span class="nx">来自</span> <span class="nx">test</span><span class="p">.</span><span class="nx">js</span> <span class="nx">的问候</span><span class="err">！’</span><span class="p">)</span>
</code></pre></div></div>

<p>同时在页面中引用它：</p>

<p><em>csp_test.html</em></p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
</span>    &lt;meta http-equiv="Content-Security-Policy" content="script-src 'none'"&gt;
    &lt;title&gt;CSP Test&lt;/title&gt;
<span class="gd">&lt;/head&gt;
&lt;body&gt;
</span>    &lt;script src="https://unpkg.com/react@16/umd/react.development.js"&gt;&lt;/script&gt;
<span class="gi">+    &lt;script src="./test.js"&gt;&lt;/script&gt;
</span><span class="gd">&lt;/body&gt;
&lt;/html&gt;
</span></code></pre></div></div>

<p>页面执行结果：</p>

<p><img src="https://user-images.githubusercontent.com/3783096/44004512-262c4df0-9e96-11e8-88e9-df4e08cb98f1.png" alt="script-src none 时页面将不加载任何脚本" />
<em>script-src none 时页面将不加载任何脚本</em></p>

<p>是的，哪怕是自己的脚本也无法被加载执行。CSP 就是这样严格和明确，不存在模棱两可的情况。所以在指定来源时，我们需要确认 URI 是否正确。</p>

<h3 id="指令可接受的值">指令可接受的值</h3>

<p>指令后面跟的来源，有两种写法</p>
<ul>
  <li>预设值</li>
  <li>URI 通配符</li>
</ul>

<h4 id="预设值">预设值</h4>

<p>其中预设值有以下这些：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">none</code> 不匹配任何东西。</li>
  <li><code class="language-plaintext highlighter-rouge">self</code> 匹配当前域，但不包括子域。比如 <code class="language-plaintext highlighter-rouge">example.com</code> 可以，<code class="language-plaintext highlighter-rouge">api.example.com</code> 则会匹配失败。</li>
  <li><code class="language-plaintext highlighter-rouge">unsafe-inline</code> 允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。</li>
  <li><code class="language-plaintext highlighter-rouge">unsafe-eval</code> 允许通过字符串动态创建的脚本执行，比如 <code class="language-plaintext highlighter-rouge">eval</code>，<code class="language-plaintext highlighter-rouge">setTimeout</code> 等。</li>
</ul>

<p>特别地，在 CSP 的严格控制下，页面中内联脚本及样式也会受影响，在没有明确指定的情况下，其不能被浏览器执行。</p>

<p>考虑下面的代码：</p>

<p><em>csp_test.html</em></p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>CSP Test<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;style&gt;</span>
        <span class="nt">body</span><span class="p">{</span>
            <span class="nl">color</span><span class="p">:</span><span class="no">red</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="nt">&lt;/style&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Hello, World!<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span><span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
            <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">hi jack!</span><span class="dl">'</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>
<p>￼
<img src="https://user-images.githubusercontent.com/3783096/44004521-427e59bc-9e96-11e8-9608-743f4e3bfefe.png" alt="未指定 CSP 的情况" />
<em>未指定 CSP 的情况</em></p>

<p>根据 MDN 上的描述，如果站点未指定 CSP 无则，浏览器默认不会开启相应检查，所以上面一切运行正常，只受正常的同域限制 。</p>

<blockquote>
  <p>If the site doesn’t offer the CSP header, browsers likewise use the standard same-origin policy.
<em>— 来自 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP"> MDN 关于 Content Security Policy (CSP) 的描述</a></em></p>
</blockquote>

<p>我们加上 CSP 限制：</p>

<p><em>csp_test.html</em></p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
</span><span class="gi">+    &lt;meta http-equiv="Content-Security-Policy" content="default-src 'self'"&gt;
</span>    &lt;title&gt;CSP Test&lt;/title&gt;
    &lt;style&gt;
        body{
            color:red;
        }
    &lt;/style&gt;
<span class="gd">&lt;/head&gt;
&lt;body&gt;
</span>    &lt;h1&gt;Hello, World!&lt;/h1&gt;
    &lt;script&gt;
        window.onload=function(){
            alert('hi jack!')
        }
    &lt;/script&gt;
<span class="gd">&lt;/body&gt;
&lt;/html&gt;
</span></code></pre></div></div>

<p>配置站点默认只信息同域的资源，但注意，这个设置并不包含内联的情况，所以结果会如下图。</p>

<p><img src="https://user-images.githubusercontent.com/3783096/44004526-54cf1a5c-9e96-11e8-8bca-c980e51a82ae.png" alt="内联代码被禁止" />
<em>内联代码被禁止</em></p>

<p>如何修复它呢。如果我们想要允许页面内的内联脚本或样式，则需要明确地通过 <code class="language-plaintext highlighter-rouge">script-src</code> 和 <code class="language-plaintext highlighter-rouge">style-src</code> 指出来。</p>

<p><em>csp_test.html</em></p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
</span><span class="gs">!    &lt;meta http-equiv="Content-Security-Policy" content="default-src 'self' ‘unsafe-inline’”&gt;
</span>    &lt;title&gt;CSP Test&lt;/title&gt;
    &lt;style&gt;
        body{
            color:red;
        }
    &lt;/style&gt;
<span class="gd">&lt;/head&gt;
&lt;body&gt;
</span>    &lt;h1&gt;Hello, World!&lt;/h1&gt;
    &lt;script&gt;
        window.onload=function(){
            alert('hi jack!')
        }
    &lt;/script&gt;
<span class="gd">&lt;/body&gt;
&lt;/html&gt;
</span></code></pre></div></div>

<p>这里 <code class="language-plaintext highlighter-rouge">default-src 'self' ‘unsave-inline’</code> 配置默认可信的来源有这些： 和页面同域的，以及内联的。</p>

<p>刷新页面，样式及脚本又可以正常执行了。</p>

<p>通常是不建议使用 <code class="language-plaintext highlighter-rouge">unsafe-inline</code> 的（同样也不推荐使用 <code class="language-plaintext highlighter-rouge">unsafe-eval</code>），因为内联的脚本和样式维护不便，也不利用良好地组织代码。最佳实践是样式抽离到样式文件，脚本放到单独的 js 文件中加载，让 HTML 文件纯粹一点才是好的做法。即使是 <code class="language-plaintext highlighter-rouge">onclick=“myHandler”</code> 或 <code class="language-plaintext highlighter-rouge">href=“javascript:;”</code> 这种平时常见的写法，也属于内联的脚本，是需要改造的。</p>

<p>如果页面中非得用内联的写法，还有种方式。即页面中这些内联的脚本或样式标签，赋值一个加密串，这个加密串由服务器生成，同时这个加密串被添加到页面的响应头里面。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">nonce=</span><span class="s">EDNnf03nceIOfn39fn3e9h3sdfa</span><span class="nt">&gt;</span>
<span class="err"> </span> <span class="c1">// 这里放置内联在 HTML 中的代码</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>页面 HTTP 响应头的 <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code> 配置中包含相同的加密串：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: script-src 'nonce-EDNnf03nceIOfn39fn3e9h3sdfa'
</code></pre></div></div>

<p>注意这里的 <code class="language-plaintext highlighter-rouge">nonce-</code> 前缀。</p>

<p>这也就是文章开头看到的方式，到这里明白了。</p>

<p><code class="language-plaintext highlighter-rouge">&lt;style&gt;</code> 标签也是类似的处理。</p>

<p>这里的加密串一定是随机不可预测的，否则达不到安全效果，且每次页面被访问时重新生成。</p>

<p>除了使用 <code class="language-plaintext highlighter-rouge">noce</code> 指定加密串，还可以通过混淆的 hash 值来达到目的。这种做法不需要在标签上加 <code class="language-plaintext highlighter-rouge">nonce</code> 而是将需要内嵌的代码本身使用加密算法生成 hash 后放入 CSP 指令中作为值使用，这里的加密算法支持 sha256, sha384 和 sha512。此时 CSP 中使用的前缀为相应的算法名。</p>

<p>hash 方式的示例：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span><span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello, world.</span><span class="dl">'</span><span class="p">);</span><span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: script-src 'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng='
</code></pre></div></div>

<h3 id="eval">eval</h3>

<p>js 中好些地方是可以以字符串方式动态创建代码并执行，这被认为是不安全的，所以不推荐使用，一般最佳实践里都会提。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">setTimeout/setInterval</code> 可接收一段字符串作为代码执行。<code class="language-plaintext highlighter-rouge">setTimout(‘alert(1)’,1000)</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">eval</code> 。<code class="language-plaintext highlighter-rouge">eval(‘alert(1)’)</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">Function</code> 构造函数。 <code class="language-plaintext highlighter-rouge">new Function(‘alert(1)’)</code>。</li>
</ul>

<p>和内联一样，有专门的指令 <code class="language-plaintext highlighter-rouge">unsafe-eval </code> 以允许类似代码的执行。但建议的做法是对于 <code class="language-plaintext highlighter-rouge">eval</code> 和 <code class="language-plaintext highlighter-rouge">Function</code> 构造器，杜绝使用，而 <code class="language-plaintext highlighter-rouge">setTimeout/setInterval</code> 可改造为非字符串形式。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="nx">alert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="uri">URI</h3>

<p>除了上面的预设值，还可通过提供完整的 URI 或带通配符 <code class="language-plaintext highlighter-rouge">*</code> 的地址来匹配，以指定资源的合法来源。这里 URI 的规则和配置服务器的跨域响应头是一样的，参考 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">Same-origin policy</a>。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">*://*.example.com:*</code> 会匹配所有 <code class="language-plaintext highlighter-rouge">example.com</code> 的子域名，但不包括 <code class="language-plaintext highlighter-rouge">example.com</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">http://example.com</code> 和 <code class="language-plaintext highlighter-rouge">http://www.example.com</code> 是两个不同的 URI。</li>
  <li><code class="language-plaintext highlighter-rouge">http://example.com:80</code> 和 <code class="language-plaintext highlighter-rouge">http://example.com</code> 也是是两个不同的 URI，虽然网站默认端口就是 80</li>
</ul>

<blockquote>
  <p>根据维基百科 <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">Uniform Resource Identifier 页面</a> 给出的解释，一个完整的 URI 由以下部分组成：
<code class="language-plaintext highlighter-rouge">URI = scheme:[//authority]path[?query][#fragment]</code></p>

  <p>其中 <code class="language-plaintext highlighter-rouge">authority</code> 又包含：
<code class="language-plaintext highlighter-rouge">authority = [userinfo@]host[:port]</code></p>

  <p>所以你可以认为其中某一项不同，那都是两个 URI。了解这点很重要，一如上面列出的第一条例子 <code class="language-plaintext highlighter-rouge">*.example.com</code>， 我们很容易先入为主地认为既然已经允许了该域名的所有子域名，那必然 <code class="language-plaintext highlighter-rouge">example.com</code> 也是合法的。</p>
</blockquote>

<p>因为 URI 是进行动态匹配的，所以解释了上面提到的预设值缘何要加引号。因为如果不加引号的话， <code class="language-plaintext highlighter-rouge">self</code> 会表示 host 是 <code class="language-plaintext highlighter-rouge">self</code> 的资源地址，而不会表示原有的意思。</p>

<h4 id="优先级">优先级</h4>

<p>CSP 的配置是很灵活的。每条指令可指定多个来源，空格分开。而一条 CSP 规则可由多条指令组成，指令间用分号隔开。各指令间没有顺序的要求，因为每条指令都是各司其职。甚至一次响应中， <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code> 响应头都可以重复设置。</p>

<p>我们来看这些情形下 CSP 的表现。</p>

<ul>
  <li>对于设置了多次响应头的情况，最严格的规则会生效。比如下面两条响应头中，虽然 第二条中设置 <code class="language-plaintext highlighter-rouge">connect-src</code> 允许 <code class="language-plaintext highlighter-rouge">http://example.com/</code>，但第一条里面设置了 <code class="language-plaintext highlighter-rouge">connect-src</code> 为 <code class="language-plaintext highlighter-rouge">none</code>，所以更加严格的 <code class="language-plaintext highlighter-rouge">none</code> 会生效。参见 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy#Multiple_content_security_policies">Multiple content security policies</a>。</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: default-src 'self' http://example.com;
                         connect-src 'none';
Content-Security-Policy: connect-src http://example.com/;
                         script-src http://example.com/
</code></pre></div></div>

<ul>
  <li>同一指令多次指定，以第一个为准，后续的会被忽略。</li>
</ul>

<p><em>csp_test.html</em></p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Content-Security-Policy"</span> <span class="na">content=</span><span class="s">"default-src 'self';default-src 'unsafe-inline';"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>CSP Test<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;style&gt;</span>
        <span class="nt">body</span><span class="p">{</span>
            <span class="nl">color</span><span class="p">:</span><span class="no">red</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="nt">&lt;/style&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Hello, World!<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span><span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
            <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">hi jack!</span><span class="dl">'</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/3783096/44004528-6a4a9f5a-9e96-11e8-88b6-6aee3342ed08.png" alt="重复配置同一指令时效果展示" />
<em>重复配置同一指令时效果展示</em></p>

<p>很智能地， 浏览器不仅会将检测不过的资源及指令打印出来，重复配置时被忽略的指令也会提示出来。</p>

<ul>
  <li>指定 <code class="language-plaintext highlighter-rouge">default-src</code> 的情况下，它会充当 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy#Fetch_directives">Fetch 类指令</a> 的默认值。即  <code class="language-plaintext highlighter-rouge">default-src</code> 并不对所有指令生效，其他指令默认值仍是 <code class="language-plaintext highlighter-rouge">*</code>。</li>
</ul>

<h3 id="发送报告">发送报告</h3>

<p>当检测到非法资源时，除了控制台看到的报错信息，也可以让浏览器将日志发送到服务器以供后续分析使用。接收报告的地址可在 <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code> 响应头中通过 <code class="language-plaintext highlighter-rouge">report-uri</code> 指令来配置。当然，服务端需要编写相应的服务来接收该数据。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;
</code></pre></div></div>

<p>服务端拿到的是以 JSON 形式传来的数据。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
<span class="err"> </span> <span class="dl">"</span><span class="s2">csp-report</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="dl">"</span><span class="s2">document-uri</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://example.org/page.html</span><span class="dl">"</span><span class="p">,</span>
<span class="err"> </span> <span class="err"> </span> <span class="dl">"</span><span class="s2">referrer</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://evil.example.com/</span><span class="dl">"</span><span class="p">,</span>
<span class="err"> </span> <span class="err"> </span> <span class="dl">"</span><span class="s2">blocked-uri</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://evil.example.com/evil.js</span><span class="dl">"</span><span class="p">,</span>
<span class="err"> </span> <span class="err"> </span> <span class="dl">"</span><span class="s2">violated-directive</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">script-src 'self' https://apis.google.com</span><span class="dl">"</span><span class="p">,</span>
<span class="err"> </span> <span class="err"> </span> <span class="dl">"</span><span class="s2">original-policy</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">script-src 'self' https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser</span><span class="dl">"</span>
<span class="err"> </span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="报告模式">报告模式</h3>

<p>CSP 提供了一种报告模式，该模式下资源不会真的被限制加载，只会对检测到的问题进行上报 ，以 JSON 数据的形式发送到 <code class="language-plaintext highlighter-rouge">report-uri</code> 指定的地方。</p>

<p>通过指定 <code class="language-plaintext highlighter-rouge">Content-Security-Policy-Report-Only</code> 而不是 <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code>，则开启了报告模式。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy-Report-Only: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;
</code></pre></div></div>

<p>当然，你也可以同时指定两种响应头，各自里的规则还会正常执行，不会互相影响。比如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: img-src *;
Content-Security-Policy-Report-Only: img-src ‘none’; report-uri http://reportcollector.example.com/collector.cgi
</code></pre></div></div>

<p>这里图片还是会正常加载，但是 <code class="language-plaintext highlighter-rouge">img-src ‘none’</code> 也会检测到并且发送报告。</p>

<p>报告模式对于测试非常有用。在开启 CSP 之前肯定需要对整站做全面的测试，将发现的问题及时修复后再真正开启，比如上面提到的对内联代码的改造。</p>

<h3 id="推荐的做法">推荐的做法</h3>

<p>这样的安全措施当然是能尽快启用就尽快。以下是推荐的做法：</p>
<ul>
  <li>先只开启报告模式，看影响范围，修改问题。</li>
  <li>添加指令时从 default-src ‘none’ 开始，查看报错，逐步添加规则直至满足要求。</li>
  <li>上线后观察一段时间，稳定后再由报告模式转到强制执行。</li>
</ul>

<h3 id="浏览器兼容性">浏览器兼容性</h3>

<p>目前发布的<a href="https://www.w3.org/TR/CSP3/"> Level 3 规范</a> 中大部分还未被浏览器实现，通过  <a href="https://caniuse.com/#search=CSP">Can I Use 的数据</a> 来看，除 IE 外，Level 2 的功能已经得到了很好的支持。这里还有一分来自 W3C 跟踪的各浏览器实现情况的统计：<a href="https://w3c.github.io/webappsec/implementation_reports/CSP2_implementation_report.html">Implementation Report for Content Security Policy Level 2</a>。</p>

<p>对于浏览器不支持的情况，也不必担心，会回退到同源策略的限制上。</p>

<h3 id="相关资源">相关资源</h3>

<ul>
  <li><a href="https://security.stackexchange.com/questions/8264/why-is-the-same-origin-policy-so-important">Why is the same origin policy so important?</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">Content Security Policy (CSP)</a></li>
  <li><a href="https://developers.google.com/web/fundamentals/security/csp/">Content Security Policy from Web Fundamentals</a></li>
  <li><a href="https://blog.twitter.com/engineering/en_us/a/2011/improving-browser-security-with-csp.html">Improving Browser Security with CSP</a></li>
</ul>


  </div><a class="u-url" href="/2018/08/13/Content-Security-Policy-(CSP)-%E4%BB%8B%E7%BB%8D.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
