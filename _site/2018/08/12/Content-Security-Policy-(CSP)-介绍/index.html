<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="google-site-verification"
    content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI"
  />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <meta name="description" content="notes about the coding life" />
  <meta name="keywords" content="牛哇勇, 博客, 互联网, Web, JavaScript, 前端, 设计" />
  <meta name="theme-color" content="#000000" />

  <!-- Open Graph -->
  <meta
    property="og:title"
    content="Content Security Policy (CSP) 介绍 - 牛さんの部落格|刘哇勇的部落格"
  />
  
  <meta property="og:type" content="article" />
  <meta
    property="og:description"
    content="Content Security Policy (CSP) 介绍

当我不经意间在 Twitter 页面 view source 后，发现了惊喜。

&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Twitter&lt..."
  />
   <meta property="article:published_time" content="2018-08-12T17:08:00Z">   
  <meta property="article:tag" content="security" />
   
  <meta property="og:image" content="http://0.0.0.0:4000" />
  <meta property="og:url" content="http://0.0.0.0:4000/2018/08/12/Content-Security-Policy-(CSP)-%E4%BB%8B%E7%BB%8D/" />
  <meta property="og:site_name" content="牛さんの部落格|刘哇勇的部落格" />

  <title>
    Content Security Policy (CSP) 介绍 - 牛さんの部落格|刘哇勇的部落格
  </title>

  <!-- Favicon -->
  <link rel="shortcut icon" href="/favicon.ico" />

  <!-- Canonical URL -->
  <link
    rel="canonical"
    href="http://0.0.0.0:4000/2018/08/12/Content-Security-Policy-(CSP)-%E4%BB%8B%E7%BB%8D/"
  />

  <!-- Bootstrap Core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/blog.min.css">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->

  <!-- ga & ba script hoook -->
  <script></script>
</head>


  <!-- hack iOS CSS :active style -->
  <body ontouchstart="">
    <!-- Navigation -->

  <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    
    <div class="container-fluid">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header page-scroll">
        <button type="button" class="navbar-toggle">
          <span class="sr-only">❌</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">牛さんの部落格</a>
      </div>

      <!-- Collect the nav links, forms, and other content for toggling -->
      <div id="huxblog_navbar">
        <div class="navbar-collapse">
          <ul class="nav navbar-nav navbar-right">
            <li>
              <a href="/">主页</a>
            </li>
               
            <li>
              <a href="/about/"
                >关于</a
              >
            </li>
              
            <li>
              <a href="/archive"
                >Archive</a
              >
            </li>
                                                                   
          </ul>
        </div>
      </div>
      <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
  </nav>

  <script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body = document.body;
    var $toggle = document.querySelector(".navbar-toggle");
    var $navbar = document.querySelector("#huxblog_navbar");
    var $collapse = document.querySelector(".navbar-collapse");

    var __HuxNav__ = {
      close: function () {
        $navbar.className = " ";
        // wait until animation end.
        setTimeout(function () {
          // prevent frequently toggle
          if ($navbar.className.indexOf("in") < 0) {
            $collapse.style.height = "0px";
          }
        }, 400);
      },
      open: function () {
        $collapse.style.height = "auto";
        $navbar.className += " in";
      },
    };

    // Bind Event
    $toggle.addEventListener("click", function (e) {
      if ($navbar.className.indexOf("in") > 0) {
        __HuxNav__.close();
      } else {
        __HuxNav__.open();
      }
    });

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from
     * $toggle/$collapse will break global delegation.
     *
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener("click", function (e) {
      if (e.target == $toggle) return;
      if (e.target.className == "icon-bar") return;
      __HuxNav__.close();
    });
  </script>
</nav>
 <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=security" title="security">security</a>
                        
                    </div>
                    <h1>Content Security Policy (CSP) 介绍</h1>
                    
                    <h2 class="subheading"></h2>
                    <span class="meta">August 12, 2018</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div
        class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"
      >
        <!-- Multi-Lingual -->
         <h1 id="content-security-policy-csp-介绍">Content Security Policy (CSP) 介绍</h1>

<p>当我不经意间在 Twitter 页面 <code class="language-plaintext highlighter-rouge">view source</code> 后，发现了惊喜。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;title&gt;</span>Twitter<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;style&gt;</span>
      <span class="nt">body</span> <span class="p">{</span>
        <span class="nl">background-color</span><span class="p">:</span> <span class="m">#ffffff</span><span class="p">;</span>
        <span class="nl">font-family</span><span class="p">:</span> <span class="nb">sans-serif</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nt">a</span> <span class="p">{</span>
        <span class="nl">color</span><span class="p">:</span> <span class="m">#1da1f2</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nt">svg</span> <span class="p">{</span>
        <span class="nl">color</span><span class="p">:</span> <span class="m">#1da1f2</span><span class="p">;</span>
        <span class="nl">display</span><span class="p">:</span> <span class="nb">block</span><span class="p">;</span>
        <span class="py">fill</span><span class="p">:</span> <span class="n">currentcolor</span><span class="p">;</span>
        <span class="nl">height</span><span class="p">:</span> <span class="m">21px</span><span class="p">;</span>
        <span class="nl">margin</span><span class="p">:</span> <span class="m">13px</span> <span class="nb">auto</span><span class="p">;</span>
        <span class="nl">width</span><span class="p">:</span> <span class="m">24px</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="nt">&lt;/style&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;noscript&gt;</span>
      <span class="nt">&lt;center&gt;</span>
        If you’re not redirected soon, please <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"/"</span><span class="nt">&gt;</span>use this link<span class="nt">&lt;/a&gt;</span>.
      <span class="nt">&lt;/center&gt;</span>
    <span class="nt">&lt;/noscript&gt;</span>
    <span class="nt">&lt;script </span><span class="na">nonce=</span><span class="s">"SG0bV9rOanQfzG0ccU8WQw=="</span><span class="nt">&gt;</span>
      <span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">app_shell_visited=1;path=/;max-age=5</span><span class="dl">"</span><span class="p">;</span>

      <span class="nx">location</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2">#</span><span class="dl">"</span><span class="p">)[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="nt">&lt;/script&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>相比平时看到的其他站点的源码，可以说是很清爽了。没有乱七八糟的标签，功能却一样不少。特别有迷惑性，以为这便是页面所有的源码，但查看 DevTools 的 Source 面板后很容易知道这并不是真实的 HTML 代码。但为何页面源码给出的是如此清爽的版本，这里先不研究。</p>

<p>把目光移向 script 标签时，发现一个不认识的 <code class="language-plaintext highlighter-rouge">nonce</code> 属性。它以及它后面的神秘字符串成功引起了我的好奇。再去看 Google 首页的源码，也有好些 <code class="language-plaintext highlighter-rouge">nonce</code> 的运用。是时候去了解一下这里的 <code class="language-plaintext highlighter-rouge">nonce</code> 是什么了。</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gs">! &lt;script nonce="SG0bV9rOanQfzG0ccU8WQw=="&gt;
</span>
      document.cookie = "app_shell_visited=1;path=/;max-age=5";

      location.replace(location.href.split("#")[0]);
    &lt;/script&gt;
</code></pre></div></div>

<h3 id="content-security-policy-csp">Content Security Policy (CSP)</h3>

<p>要了解 <code class="language-plaintext highlighter-rouge">nonce</code>， 先了解 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">Content-Security-Policy(CSP)</a>。</p>

<p>我们都知道浏览器有同源策略（<a href="https://en.wikipedia.org/wiki/Same-origin_policy">same-origin policy</a>）的安全限制，即每个站点只允许加载来自和自身同域（origin）的数据，<code class="language-plaintext highlighter-rouge">https://a.com</code> 是无法从 <code class="language-plaintext highlighter-rouge">https://b.com</code> 加载到资源的。每个站点被严格限制在了自已的孤岛上，自己就是一个沙盒，这样很安全，整个网络不会杂乱无章。主要地，它能解决大部分安全问题。假若没有同源策略，恶意代码能够轻松在浏览器端执行然后获取各种隐私信息：银行帐号，社交数据等。</p>

<blockquote>
  <p>那网站间如何进行数据共享，当然是有办法的，了解下 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS</a>。</p>
</blockquote>

<p>现实中，问题是同源策略也并不是万无一失，跨域攻击 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">Cross-site scripting (XSS)</a> 便包含五花八门绕开限制的手段，形式上通过向页面注入恶意代码完成信息的窃取或攻击。比如 UGC 类型的站点，因为内容依赖用户创建，这就开了很大一个口子，允许用户输入的内容运行在页面上。当然，因为我们都知道会有注入攻击，所以对用户输入的内容进行防 XSS 过滤也成了标配。</p>

<p>Content-Security-Policy 从另一方面给浏览器加了层防护，能极大地减少这种攻击的发生。</p>

<h3 id="原理">原理</h3>

<p>CSP 通过告诉浏览器一系列规则，严格规定页面中哪些资源允许有哪些来源， 不在指定范围内的统统拒绝。相比同源策略，CSP 可以说是很严格了。</p>

<p>其实施有两种途径：</p>

<ul>
  <li>服务器添加 <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code> 响应头来指定规则</li>
  <li>HTML 中添加 <code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 标签来指定 <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code> 规则</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/3783096/44004494-f3c9bdf2-9e95-11e8-8793-e2966d79ecae.png" alt="mobile.twitter.com header 中的 CSP 规则" />
<em>mobile.twitter.com header 中的 CSP 规则</em></p>

<p>为了测试方便，以下示例均使用 <code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 标签来开启 CSP 规则。但 <code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 中有些指令是不能使用的，后面会了解到。只有响应头中才能使用全部的限制指令。</p>

<h4 id="一个简单示例">一个简单示例</h4>

<p>创建一个 HTML 文件放入以下内容：</p>

<p><em>csp_test.html</em></p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span>
      <span class="na">http-equiv=</span><span class="s">"Content-Security-Policy"</span>
      <span class="na">content=</span><span class="s">"script-src 'self' https://unpkg.com"</span>
    <span class="nt">/&gt;</span>
    <span class="nt">&lt;title&gt;</span>CSP Test<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://unpkg.com/react@16/umd/react.development.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>在该测试文件所在目录开启一个本地 server 以访问，这里使用 Python 自带的 server:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python <span class="nt">-m</span> SimpleHTTPServer 8000
</code></pre></div></div>

<p>然后访问 <a href="localhost:8000">localhost:8000</a> 以观察结果：</p>

<p><img src="https://user-images.githubusercontent.com/3783096/44004498-fdd37004-9e95-11e8-895d-53797ae105c1.png" alt="符合 CSP 规则情况下的正常访问" />
<em>符合 CSP 规则情况下的正常访问</em></p>

<p>然后我们将 <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code> 改成不允许任何资源再试一下：</p>

<p><em>csp_test.html</em></p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
-     &lt;meta http-equiv="Content-Security-Policy" content="script-src 'self' https://unpkg.com"&gt;
</span><span class="gi">+     &lt;meta http-equiv="Content-Security-Policy" content="script-src ‘none’"&gt;
</span>    &lt;title&gt;CSP Test&lt;/title&gt;
<span class="gd">&lt;/head&gt;
&lt;body&gt;
</span>    &lt;script src="https://unpkg.com/react@16/umd/react.development.js"&gt;&lt;/script&gt;
<span class="gd">&lt;/body&gt;
&lt;/html&gt;
</span></code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/3783096/44004501-0fac3a18-9e96-11e8-98bf-01e77f4a5e6a.png" alt="触发 CSP 规则资源被 block 的情况" />
<em>触发 CSP 规则资源被 block 的情况</em></p>

<p>下面我们来解释这里设置的 CSP 规则及理解为何资源加载失败。</p>

<h4 id="csp-规则">CSP 规则</h4>

<p>无论是 header 中还是 <code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 标签中指定，其值的格式都是统一的，由一系列 CSP 指令（directive）组合而成。</p>

<p>示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: &lt;policy-directive&gt;; &lt;policy-directive&gt;…
</code></pre></div></div>

<p>这里 directive，即指令，是 CSP 规范中规定用以详细详述某种资源的来源，比如前面示例中使用的 <code class="language-plaintext highlighter-rouge">script-src</code>，指定脚本可以有哪些合法来源，<code class="language-plaintext highlighter-rouge">img-src</code> 则指定图片，以下是常用指令：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">base-uri</code>  限制可出现在页面 <code class="language-plaintext highlighter-rouge">&lt;base&gt;</code> 标签中的链接。</li>
  <li><code class="language-plaintext highlighter-rouge">child-src</code>  列出可用于 worker 及以 frame 形式嵌入的链接。 譬如: <code class="language-plaintext highlighter-rouge">child-src https://youtube.com</code>  表示只能从 Youtube 嵌入视频资源。</li>
  <li><code class="language-plaintext highlighter-rouge">connect-src</code>  可发起连接的地址 (通过 XHR, WebSockets 或 EventSource)。</li>
  <li><code class="language-plaintext highlighter-rouge">font-src</code>  字体来源。譬如，要使用 Google web fonts 则需要添加  <code class="language-plaintext highlighter-rouge">font-src https://themes.googleusercontent.com</code> 规则。</li>
  <li><code class="language-plaintext highlighter-rouge">form-action</code> <code class="language-plaintext highlighter-rouge">&lt;form&gt;</code> 标签可提交的地址。</li>
  <li><code class="language-plaintext highlighter-rouge">frame-ancestors</code>  当前页面可被哪些来源所嵌入（与 <code class="language-plaintext highlighter-rouge">child-src</code> 正好相反）。作用于  <code class="language-plaintext highlighter-rouge">&lt;frame&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;iframe&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;embed&gt;</code> 及  <code class="language-plaintext highlighter-rouge">&lt;applet&gt;</code>。 该指令不能通过 <code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 指定且只对非 HTML 文档类型的资源生效。</li>
  <li><code class="language-plaintext highlighter-rouge">frame-src</code>  该指令已在 level 2 中废弃但会在 level 3 中恢复使用。未指定的情况下回退到 <code class="language-plaintext highlighter-rouge">tochild-src</code> 指令。</li>
  <li><code class="language-plaintext highlighter-rouge">img-src</code>  指定图片来源。</li>
  <li><code class="language-plaintext highlighter-rouge">media-src</code>  限制音视频资源的来源。</li>
  <li><code class="language-plaintext highlighter-rouge">object-src</code> Flash 及其他插件的来源。</li>
  <li><code class="language-plaintext highlighter-rouge">plugin-types</code>  限制页面中可加载的插件类型。</li>
  <li><code class="language-plaintext highlighter-rouge">report-uri</code> 指定一个可接收 CSP 报告的地址，浏览器会在相应指令不通过时发送报告。不能通过 <code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 标签来指定。</li>
  <li><code class="language-plaintext highlighter-rouge">style-src</code>  限制样式文件的来源。</li>
  <li><code class="language-plaintext highlighter-rouge">upgrade-insecure-requests</code>  指导客户端将页面地址重写，HTTP 转 HTTPS。用于站点中有大量旧地址需要重定向的情形。</li>
  <li><code class="language-plaintext highlighter-rouge">worker-src</code> CSP Level 3 中的指令，规定可用于 worker, shared worker, 或 service worker 中的地址。</li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">child-src</code>  与 <code class="language-plaintext highlighter-rouge">frame-ancestors</code>  看起来比较像。前者规定的是页面中可加载哪些 iframe，后者规定谁可以以 iframe 加载本页。 比如来自不同站点的两个网页 A 与 B，B 中有 iframe 加载了 A。那么</p>

  <ul>
    <li>A 的 <code class="language-plaintext highlighter-rouge">frame-ancestors</code> 需要包含 B</li>
    <li>B 的 <code class="language-plaintext highlighter-rouge">child-src</code> 需要包含 A</li>
  </ul>
</blockquote>

<p>默认情况下，这些指令都是最大条件开放的，可以理解为其默认值为 <code class="language-plaintext highlighter-rouge">*</code>。比如 <code class="language-plaintext highlighter-rouge">img-src</code>，如果不明确指定，则可以从所有地方加载图片资源。</p>

<p>还有种特殊的指令 <code class="language-plaintext highlighter-rouge">default-src</code>，如果指定了它的值，则相当于改变了这些未指定的指令的默认值。可以理解为，上面 <code class="language-plaintext highlighter-rouge">img-src</code> 如果没指定，本来其默认值是 <code class="language-plaintext highlighter-rouge">*</code>，可以加载所有来源的图片，但设置 <code class="language-plaintext highlighter-rouge">default-src</code> 后，默认值就成了 <code class="language-plaintext highlighter-rouge">default-src</code> 指定的值。</p>

<p>常见的做法会设置 <code class="language-plaintext highlighter-rouge">default-src ‘self’</code>，这样所有资源都被限制在了和页面同域下。如果此时想要加载从 CDN 来的图片，将图片来源单独添加上即可。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: default-src ‘self’; img-src https://cdn.example.com
</code></pre></div></div>

<p>现在来看开头那个示例，也许现在就能看明白了。因为页面中需要从 CDN 加载 React 库，所以我们<code class="language-plaintext highlighter-rouge">&lt;meta&gt;</code> 标签指定了如下 CSP 规则：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>script-src 'self' https://unpkg.com
</code></pre></div></div>

<p>这里的 <code class="language-plaintext highlighter-rouge">self</code> 及后来改成的 <code class="language-plaintext highlighter-rouge">none</code> 是预设值，需用引号包裹，否则会当成 URI 来解析。这里的 CSP 规则表示页面中脚本只能从同域及 <code class="language-plaintext highlighter-rouge">https://unpkg.com</code> 加载。假如我们把后者去掉，同样会像上图截图那样 React 库会加载失败，同时控制台中会有加载失败的日志及被触发的规则列出来。</p>

<p>改成 <code class="language-plaintext highlighter-rouge">none</code> 之后表示页面不加载任何脚本，即使自己站点上的脚本都无法被加载执行。这里不妨试一下在 <code class="language-plaintext highlighter-rouge">csp_test.html</code> 旁边创建一个脚本文件 <code class="language-plaintext highlighter-rouge">test.js</code>:</p>

<p><em>test.js</em></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">alert</span><span class="p">(</span><span class="err">‘</span><span class="nx">来自</span> <span class="nx">test</span><span class="p">.</span><span class="nx">js</span> <span class="nx">的问候</span><span class="err">！’</span><span class="p">)</span>
</code></pre></div></div>

<p>同时在页面中引用它：</p>

<p><em>csp_test.html</em></p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
</span>    &lt;meta http-equiv="Content-Security-Policy" content="script-src 'none'"&gt;
    &lt;title&gt;CSP Test&lt;/title&gt;
<span class="gd">&lt;/head&gt;
&lt;body&gt;
</span>    &lt;script src="https://unpkg.com/react@16/umd/react.development.js"&gt;&lt;/script&gt;
<span class="gi">+    &lt;script src="./test.js"&gt;&lt;/script&gt;
</span><span class="gd">&lt;/body&gt;
&lt;/html&gt;
</span></code></pre></div></div>

<p>页面执行结果：</p>

<p><img src="https://user-images.githubusercontent.com/3783096/44004512-262c4df0-9e96-11e8-88e9-df4e08cb98f1.png" alt="script-src none 时页面将不加载任何脚本" />
<em>script-src none 时页面将不加载任何脚本</em></p>

<p>是的，哪怕是自己的脚本也无法被加载执行。CSP 就是这样严格和明确，不存在模棱两可的情况。所以在指定来源时，我们需要确认 URI 是否正确。</p>

<h3 id="指令可接受的值">指令可接受的值</h3>

<p>指令后面跟的来源，有两种写法</p>

<ul>
  <li>预设值</li>
  <li>URI 通配符</li>
</ul>

<h4 id="预设值">预设值</h4>

<p>其中预设值有以下这些：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">none</code> 不匹配任何东西。</li>
  <li><code class="language-plaintext highlighter-rouge">self</code> 匹配当前域，但不包括子域。比如 <code class="language-plaintext highlighter-rouge">example.com</code> 可以，<code class="language-plaintext highlighter-rouge">api.example.com</code> 则会匹配失败。</li>
  <li><code class="language-plaintext highlighter-rouge">unsafe-inline</code>  允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。</li>
  <li><code class="language-plaintext highlighter-rouge">unsafe-eval</code>  允许通过字符串动态创建的脚本执行，比如 <code class="language-plaintext highlighter-rouge">eval</code>，<code class="language-plaintext highlighter-rouge">setTimeout</code> 等。</li>
</ul>

<p>特别地，在 CSP 的严格控制下，页面中内联脚本及样式也会受影响，在没有明确指定的情况下，其不能被浏览器执行。</p>

<p>考虑下面的代码：</p>

<p><em>csp_test.html</em></p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>CSP Test<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;style&gt;</span>
      <span class="nt">body</span> <span class="p">{</span>
        <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="nt">&lt;/style&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Hello, World!<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;script&gt;</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">hi jack!</span><span class="dl">"</span><span class="p">);</span>
      <span class="p">};</span>
    <span class="nt">&lt;/script&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/3783096/44004521-427e59bc-9e96-11e8-9608-743f4e3bfefe.png" alt="未指定 CSP 的情况" />
<em>未指定 CSP 的情况</em></p>

<p>根据 MDN 上的描述，如果站点未指定 CSP 无则，浏览器默认不会开启相应检查，所以上面一切运行正常，只受正常的同域限制 。</p>

<blockquote>
  <p>If the site doesn’t offer the CSP header, browsers likewise use the standard same-origin policy.
<em>— 来自 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP"> MDN 关于 Content Security Policy (CSP) 的描述</a></em></p>
</blockquote>

<p>我们加上 CSP 限制：</p>

<p><em>csp_test.html</em></p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
</span><span class="gi">+    &lt;meta http-equiv="Content-Security-Policy" content="default-src 'self'"&gt;
</span>    &lt;title&gt;CSP Test&lt;/title&gt;
    &lt;style&gt;
        body{
            color:red;
        }
    &lt;/style&gt;
<span class="gd">&lt;/head&gt;
&lt;body&gt;
</span>    &lt;h1&gt;Hello, World!&lt;/h1&gt;
    &lt;script&gt;
        window.onload=function(){
            alert('hi jack!')
        }
    &lt;/script&gt;
<span class="gd">&lt;/body&gt;
&lt;/html&gt;
</span></code></pre></div></div>

<p>配置站点默认只信息同域的资源，但注意，这个设置并不包含内联的情况，所以结果会如下图。</p>

<p><img src="https://user-images.githubusercontent.com/3783096/44004526-54cf1a5c-9e96-11e8-8bca-c980e51a82ae.png" alt="内联代码被禁止" />
<em>内联代码被禁止</em></p>

<p>如何修复它呢。如果我们想要允许页面内的内联脚本或样式，则需要明确地通过 <code class="language-plaintext highlighter-rouge">script-src</code> 和 <code class="language-plaintext highlighter-rouge">style-src</code> 指出来。</p>

<p><em>csp_test.html</em></p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
</span><span class="gs">!    &lt;meta http-equiv="Content-Security-Policy" content="default-src 'self' ‘unsafe-inline’”&gt;
</span>    &lt;title&gt;CSP Test&lt;/title&gt;
    &lt;style&gt;
        body{
            color:red;
        }
    &lt;/style&gt;
<span class="gd">&lt;/head&gt;
&lt;body&gt;
</span>    &lt;h1&gt;Hello, World!&lt;/h1&gt;
    &lt;script&gt;
        window.onload=function(){
            alert('hi jack!')
        }
    &lt;/script&gt;
<span class="gd">&lt;/body&gt;
&lt;/html&gt;
</span></code></pre></div></div>

<p>这里 <code class="language-plaintext highlighter-rouge">default-src 'self' ‘unsave-inline’</code> 配置默认可信的来源有这些： 和页面同域的，以及内联的。</p>

<p>刷新页面，样式及脚本又可以正常执行了。</p>

<p>通常是不建议使用 <code class="language-plaintext highlighter-rouge">unsafe-inline</code> 的（同样也不推荐使用 <code class="language-plaintext highlighter-rouge">unsafe-eval</code>），因为内联的脚本和样式维护不便，也不利用良好地组织代码。最佳实践是样式抽离到样式文件，脚本放到单独的 js 文件中加载，让 HTML 文件纯粹一点才是好的做法。即使是 <code class="language-plaintext highlighter-rouge">onclick=“myHandler”</code> 或 <code class="language-plaintext highlighter-rouge">href=“javascript:;”</code> 这种平时常见的写法，也属于内联的脚本，是需要改造的。</p>

<p>如果页面中非得用内联的写法，还有种方式。即页面中这些内联的脚本或样式标签，赋值一个加密串，这个加密串由服务器生成，同时这个加密串被添加到页面的响应头里面。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">nonce=</span><span class="s">"EDNnf03nceIOfn39fn3e9h3sdfa"</span><span class="nt">&gt;</span>
  <span class="c1">// 这里放置内联在 HTML 中的代码</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>页面 HTTP 响应头的 <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code> 配置中包含相同的加密串：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: script-src 'nonce-EDNnf03nceIOfn39fn3e9h3sdfa'
</code></pre></div></div>

<p>注意这里的 <code class="language-plaintext highlighter-rouge">nonce-</code> 前缀。</p>

<p>这也就是文章开头看到的方式，到这里明白了。</p>

<p><code class="language-plaintext highlighter-rouge">&lt;style&gt;</code> 标签也是类似的处理。</p>

<p>这里的加密串一定是随机不可预测的，否则达不到安全效果，且每次页面被访问时重新生成。</p>

<p>除了使用 <code class="language-plaintext highlighter-rouge">noce</code> 指定加密串，还可以通过混淆的 hash 值来达到目的。这种做法不需要在标签上加 <code class="language-plaintext highlighter-rouge">nonce</code> 而是将需要内嵌的代码本身使用加密算法生成 hash 后放入 CSP 指令中作为值使用，这里的加密算法支持 sha256, sha384 和 sha512。此时 CSP 中使用的前缀为相应的算法名。</p>

<p>hash 方式的示例：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span>
  <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, world.</span><span class="dl">"</span><span class="p">);</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: script-src 'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng='
</code></pre></div></div>

<h3 id="eval">eval</h3>

<p>js 中好些地方是可以以字符串方式动态创建代码并执行，这被认为是不安全的，所以不推荐使用，一般最佳实践里都会提。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">setTimeout/setInterval</code> 可接收一段字符串作为代码执行。<code class="language-plaintext highlighter-rouge">setTimout(‘alert(1)’,1000)</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">eval</code> 。<code class="language-plaintext highlighter-rouge">eval(‘alert(1)’)</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">Function</code> 构造函数。 <code class="language-plaintext highlighter-rouge">new Function(‘alert(1)’)</code>。</li>
</ul>

<p>和内联一样，有专门的指令 <code class="language-plaintext highlighter-rouge">unsafe-eval </code> 以允许类似代码的执行。但建议的做法是对于 <code class="language-plaintext highlighter-rouge">eval</code> 和 <code class="language-plaintext highlighter-rouge">Function</code> 构造器，杜绝使用，而 <code class="language-plaintext highlighter-rouge">setTimeout/setInterval</code> 可改造为非字符串形式。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="uri">URI</h3>

<p>除了上面的预设值，还可通过提供完整的 URI 或带通配符 <code class="language-plaintext highlighter-rouge">*</code> 的地址来匹配，以指定资源的合法来源。这里 URI 的规则和配置服务器的跨域响应头是一样的，参考 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">Same-origin policy</a>。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">*://*.example.com:*</code> 会匹配所有 <code class="language-plaintext highlighter-rouge">example.com</code> 的子域名，但不包括 <code class="language-plaintext highlighter-rouge">example.com</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">http://example.com</code> 和 <code class="language-plaintext highlighter-rouge">http://www.example.com</code> 是两个不同的 URI。</li>
  <li><code class="language-plaintext highlighter-rouge">http://example.com:80</code> 和 <code class="language-plaintext highlighter-rouge">http://example.com</code> 也是是两个不同的 URI，虽然网站默认端口就是 80</li>
</ul>

<blockquote>
  <p>根据维基百科 <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">Uniform Resource Identifier 页面</a> 给出的解释，一个完整的 URI 由以下部分组成：
<code class="language-plaintext highlighter-rouge">URI = scheme:[//authority]path[?query][#fragment]</code></p>

  <p>其中 <code class="language-plaintext highlighter-rouge">authority</code> 又包含：
<code class="language-plaintext highlighter-rouge">authority = [userinfo@]host[:port]</code></p>

  <p>所以你可以认为其中某一项不同，那都是两个 URI。了解这点很重要，一如上面列出的第一条例子 <code class="language-plaintext highlighter-rouge">*.example.com</code>， 我们很容易先入为主地认为既然已经允许了该域名的所有子域名，那必然 <code class="language-plaintext highlighter-rouge">example.com</code> 也是合法的。</p>
</blockquote>

<p>因为 URI 是进行动态匹配的，所以解释了上面提到的预设值缘何要加引号。因为如果不加引号的话， <code class="language-plaintext highlighter-rouge">self</code> 会表示 host 是 <code class="language-plaintext highlighter-rouge">self</code> 的资源地址，而不会表示原有的意思。</p>

<h4 id="优先级">优先级</h4>

<p>CSP 的配置是很灵活的。每条指令可指定多个来源，空格分开。而一条 CSP 规则可由多条指令组成，指令间用分号隔开。各指令间没有顺序的要求，因为每条指令都是各司其职。甚至一次响应中， <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code> 响应头都可以重复设置。</p>

<p>我们来看这些情形下 CSP 的表现。</p>

<ul>
  <li>对于设置了多次响应头的情况，最严格的规则会生效。比如下面两条响应头中，虽然 第二条中设置 <code class="language-plaintext highlighter-rouge">connect-src</code> 允许 <code class="language-plaintext highlighter-rouge">http://example.com/</code>，但第一条里面设置了 <code class="language-plaintext highlighter-rouge">connect-src</code> 为 <code class="language-plaintext highlighter-rouge">none</code>，所以更加严格的 <code class="language-plaintext highlighter-rouge">none</code> 会生效。参见 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy#Multiple_content_security_policies">Multiple content security policies</a>。</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: default-src 'self' http://example.com;
                         connect-src 'none';
Content-Security-Policy: connect-src http://example.com/;
                         script-src http://example.com/
</code></pre></div></div>

<ul>
  <li>同一指令多次指定，以第一个为准，后续的会被忽略。</li>
</ul>

<p><em>csp_test.html</em></p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span>
      <span class="na">http-equiv=</span><span class="s">"Content-Security-Policy"</span>
      <span class="na">content=</span><span class="s">"default-src 'self';default-src 'unsafe-inline';"</span>
    <span class="nt">/&gt;</span>
    <span class="nt">&lt;title&gt;</span>CSP Test<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;style&gt;</span>
      <span class="nt">body</span> <span class="p">{</span>
        <span class="nl">color</span><span class="p">:</span> <span class="no">red</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="nt">&lt;/style&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Hello, World!<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;script&gt;</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">hi jack!</span><span class="dl">"</span><span class="p">);</span>
      <span class="p">};</span>
    <span class="nt">&lt;/script&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/3783096/44004528-6a4a9f5a-9e96-11e8-88b6-6aee3342ed08.png" alt="重复配置同一指令时效果展示" />
<em>重复配置同一指令时效果展示</em></p>

<p>很智能地， 浏览器不仅会将检测不过的资源及指令打印出来，重复配置时被忽略的指令也会提示出来。</p>

<ul>
  <li>指定 <code class="language-plaintext highlighter-rouge">default-src</code> 的情况下，它会充当 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy#Fetch_directives">Fetch 类指令</a> 的默认值。即 <code class="language-plaintext highlighter-rouge">default-src</code> 并不对所有指令生效，其他指令默认值仍是 <code class="language-plaintext highlighter-rouge">*</code>。</li>
</ul>

<h3 id="发送报告">发送报告</h3>

<p>当检测到非法资源时，除了控制台看到的报错信息，也可以让浏览器将日志发送到服务器以供后续分析使用。接收报告的地址可在 <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code> 响应头中通过 <code class="language-plaintext highlighter-rouge">report-uri</code> 指令来配置。当然，服务端需要编写相应的服务来接收该数据。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;
</code></pre></div></div>

<p>服务端拿到的是以 JSON 形式传来的数据。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
<span class="err"> </span> <span class="dl">"</span><span class="s2">csp-report</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="dl">"</span><span class="s2">document-uri</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://example.org/page.html</span><span class="dl">"</span><span class="p">,</span>
<span class="err"> </span> <span class="err"> </span> <span class="dl">"</span><span class="s2">referrer</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://evil.example.com/</span><span class="dl">"</span><span class="p">,</span>
<span class="err"> </span> <span class="err"> </span> <span class="dl">"</span><span class="s2">blocked-uri</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://evil.example.com/evil.js</span><span class="dl">"</span><span class="p">,</span>
<span class="err"> </span> <span class="err"> </span> <span class="dl">"</span><span class="s2">violated-directive</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">script-src 'self' https://apis.google.com</span><span class="dl">"</span><span class="p">,</span>
<span class="err"> </span> <span class="err"> </span> <span class="dl">"</span><span class="s2">original-policy</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">script-src 'self' https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser</span><span class="dl">"</span>
<span class="err"> </span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="报告模式">报告模式</h3>

<p>CSP 提供了一种报告模式，该模式下资源不会真的被限制加载，只会对检测到的问题进行上报 ，以 JSON 数据的形式发送到 <code class="language-plaintext highlighter-rouge">report-uri</code> 指定的地方。</p>

<p>通过指定 <code class="language-plaintext highlighter-rouge">Content-Security-Policy-Report-Only</code> 而不是 <code class="language-plaintext highlighter-rouge">Content-Security-Policy</code>，则开启了报告模式。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy-Report-Only: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;
</code></pre></div></div>

<p>当然，你也可以同时指定两种响应头，各自里的规则还会正常执行，不会互相影响。比如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Content-Security-Policy: img-src *;
Content-Security-Policy-Report-Only: img-src ‘none’; report-uri http://reportcollector.example.com/collector.cgi
</code></pre></div></div>

<p>这里图片还是会正常加载，但是 <code class="language-plaintext highlighter-rouge">img-src ‘none’</code> 也会检测到并且发送报告。</p>

<p>报告模式对于测试非常有用。在开启 CSP 之前肯定需要对整站做全面的测试，将发现的问题及时修复后再真正开启，比如上面提到的对内联代码的改造。</p>

<h3 id="推荐的做法">推荐的做法</h3>

<p>这样的安全措施当然是能尽快启用就尽快。以下是推荐的做法：</p>

<ul>
  <li>先只开启报告模式，看影响范围，修改问题。</li>
  <li>添加指令时从 default-src ‘none’ 开始，查看报错，逐步添加规则直至满足要求。</li>
  <li>上线后观察一段时间，稳定后再由报告模式转到强制执行。</li>
</ul>

<h3 id="浏览器兼容性">浏览器兼容性</h3>

<p>目前发布的<a href="https://www.w3.org/TR/CSP3/"> Level 3 规范</a> 中大部分还未被浏览器实现，通过 <a href="https://caniuse.com/#search=CSP">Can I Use 的数据</a> 来看，除 IE 外，Level 2 的功能已经得到了很好的支持。这里还有一分来自 W3C 跟踪的各浏览器实现情况的统计：<a href="https://w3c.github.io/webappsec/implementation_reports/CSP2_implementation_report.html">Implementation Report for Content Security Policy Level 2</a>。</p>

<p>对于浏览器不支持的情况，也不必担心，会回退到同源策略的限制上。</p>

<h3 id="相关资源">相关资源</h3>

<ul>
  <li><a href="https://security.stackexchange.com/questions/8264/why-is-the-same-origin-policy-so-important">Why is the same origin policy so important?</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">Content Security Policy (CSP)</a></li>
  <li><a href="https://developers.google.com/web/fundamentals/security/csp/">Content Security Policy from Web Fundamentals</a></li>
  <li><a href="https://blog.twitter.com/engineering/en_us/a/2011/improving-browser-security-with-csp.html">Improving Browser Security with CSP</a></li>
</ul>


        <hr style="visibility: hidden" />
        <ul class="pager">
          
          <li class="previous">
            <a
              href="/2018/08/11/SLA-%E4%B8%8E-SLO/"
              data-toggle="tooltip"
              data-placement="top"
              title="SLA 与 SLO"
            >
              Previous<br />
              <span>SLA 与 SLO</span>
            </a>
          </li>
           
          <li class="next">
            <a
              href="/2018/08/26/sth.-101/"
              data-toggle="tooltip"
              data-placement="top"
              title="sth. 101"
            >
              Next<br />
              <span>sth. 101</span>
            </a>
          </li>
          
        </ul>
        <hr style="visibility: hidden" />

         
      </div>

      <!-- Side Catalog Container -->
      
      <div
        class="col-lg-2 col-lg-offset-0 visible-lg-block sidebar-container catalog-container"
      >
        <div class="side-catalog">
          <hr class="hidden-sm hidden-xs" />
          <ul class="catalog-body"></ul>
        </div>
      </div>
      

      <!-- Sidebar Container -->
      <div
        class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"
      >
        <!-- Featured Tags -->
        



        <!-- Friends Blog -->
        
      </div>
    </div>
  </div>
</article>

<!-- add support for mathjax by voleking-->
   
<!-- async load function -->
<script>
  function async(u, c) {
    var d = document,
      t = "script",
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener(
        "load",
        function (e) {
          c(null, e);
        },
        false
      );
    }
    s.parentNode.insertBefore(o, s);
  }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
  async(
    "//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",
    function () {
      anchors.options = {
        visible: "hover",
        placement: "right",
        // icon: '#'
      };
      anchors
        .add()
        .remove(".intro-header h1")
        .remove(".subheading")
        .remove(".sidebar-container h5");
    }
  );
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

 <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  <li>
    <a href="/feed.xml">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a href="https://twitter.com/liuwayong">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  
  
  <li>
    <a target="_blank" href="https://github.com/wayou">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
</ul>

                <p class="copyright text-muted">
                   已经到底了😝
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->



<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function () {
        var $nav = document.querySelector("nav");
        if ($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog(selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");
  
    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->


  </body>
</html>
