<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>正确地使用 Angular Directive 中的 compile，controller 与 link | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="正确地使用 Angular Directive 中的 compile，controller 与 link" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Angular Directive 中正确使用 compile，controller 与 link 编写 Angular Directive 时，到底该用 link 还是 controller，或者 compile。 看官方文档的示例代码时，也是一会儿用 link, 一会儿又用 controller。网上搜问题时遇到的代码也都是用每个的都有。 那么问题来了，这三者有何区别，什么情况下用哪个最合适。 重新认识 从官方文档 Comprehensive Directive API，可以找到一段 directive 完整定义的示例代码，其中，directiveDefinitionObject 就是完整定义一个 directive 的配置对象。是它告诉 Angular 的 $compile 如何去解析生成这个 directive。 var myModule = angular.module(...); myModule.directive(&#39;directiveName&#39;, function factory(injectables) { var directiveDefinitionObject = { priority: 0, template: &#39;&lt;div&gt;&lt;/div&gt;&#39;, // or // function(tElement, tAttrs) { ... }, // or // templateUrl: &#39;directive.html&#39;, // or // function(tElement, tAttrs) { ... }, transclude: false, restrict: &#39;A&#39;, templateNamespace: &#39;html&#39;, scope: false, controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... }, controllerAs: &#39;stringIdentifier&#39;, bindToController: false, require: &#39;siblingDirectiveName&#39;, // or // [&#39;^parentDirectiveName&#39;, &#39;?optionalDirectiveName&#39;, &#39;?^optionalParent&#39;], multiElement: false, compile: function compile(tElement, tAttrs, transclude) { return { pre: function preLink(scope, iElement, iAttrs, controller) { ... }, post: function postLink(scope, iElement, iAttrs, controller) { ... } } // or // return function postLink( ... ) { ... } }, // or // link: { // pre: function preLink(scope, iElement, iAttrs, controller) { ... }, // post: function postLink(scope, iElement, iAttrs, controller) { ... } // } // or // link: function postLink( ... ) { ... } }; return directiveDefinitionObject; }); 从上面示例代码可以看到本文要讨论的三个函数的关系。三者可以并列，但 compile 和 link 的关系有点微妙。这里，link 严格意义上是分为 preLink 及 postLink 的。默认情况下 link 指的是 postLink。两者之所以微妙，是因为有 compile 定义的情况下，配置对象中的 link 属性会被忽略。此时如果想使用 link 方法的话，需要在 compile 里进行返回。 平时只注重使用，也没细看。现在根据三者执行的顺序，来仔细认识一下他们，以看看三者的区别。 从 Stackoverflow 扒来的神图展示了 Angular 启动时都发生了些什么 从图中可看出，Anuglar 启动后，主要两部分， $compile 阶段 这里面包含了 Directive 的 compile 方法。 DOM 模板被加载后则开始了编译。遍历所有节点，找出 directive 然后调用每个 directive 的 cmopile 方法。这里使用的 DOM 模板代码为原始的 DOM 模板。 Angular directive compile 阶段 nodeLinkFn 阶段 这里面包含了 Directive 的 controller 以及 link (preLink 和 postLink)。 将原始的 DOM 模板代码生成到页面后，就认为实例化了该模板，因为该模板和一个实例 directive 进行了绑定，有确定的作用域 scope。所以这一阶段使用的 DOM 区别于前面，是实例化的 DOM。 实例化的 DOM 除了从原始 DOM 直接编译而来，还有的是通过 ngRepeat 等在代码中动态生成的。无论哪种形式而来，一旦 DOM 被渲染到页面，则开始的 link 阶段的工作。 Angular directive link 阶段 详细看看各步骤 为了更好理解各执行步骤，考察下面的示例代码： &lt;div ng-repeat=&quot;i in [0,1,2]&quot;&gt; &lt;my-element&gt; &lt;div&gt;Inner content&lt;/div&gt; &lt;/my-element&gt; &lt;/div&gt; 其中用到的 directive 代码为： myApp.directive( &#39;myElement&#39;, function() { return { restrict: &#39;EA&#39;, transclude: true, template: &#39;&lt;div&gt;&lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;&#39; } }); compile compile 主要用来对模板代码进行转换，大部分的 directive 用不到。 link 阶段的 DOM 是这一阶段产出的克隆版本。 首先来到的是 $compile 阶段。这里面包含了 directive 的 compile 方法。从上面示例代码中可以看出，它的签名是 compile: function compile( tElement, tAttributes ) { ... } 这里参数命名值得提一下，tElement 实际上指 template element，指的是直接从模板拿到的原始代码，以区别于实例的 element iElement (instance element)，后者指 directive 实例化之后的 DOM 代码，用在 link 方法中。 tAttributes 同理。 在 compile 执行之前，通过 ng-transclude 嵌入的代码会先被移除，然后模板代码被放入 directive 标签内。所以传给 compile 的 DOM 成了这样： &lt;my-element&gt; &lt;div&gt; &quot;&quot; &lt;div ng-transclude&gt;&lt;/div&gt; &lt;/div&gt; &lt;/my-element&gt; 然后就是调用 compile 方法。完了之后会将这个 directive 下所有子组件再走一遍这个流程。 组件的实例化 compile 可以理解为是对原始模板的编译处理。针对一个 directive 只进行一次。之后便是将编译好的代码实例出一个组件来。 上面参数命名的地方也提到过实例。指的也就是页面中一个 direcitve 的生成。这里，我们测试用的代码中，ng-repeat=&quot;i in [0,1,2]&quot; 会生成三个 myElement 的实例。也就是说，下面的步骤会进行三次，每实例化一个 directive 都会走一遍下面的流程。 Controller 从上面示例代码中，可以看到 controller 方法的签名是这样的： controller: function( $scope, $element, $attrs, $transclude ) { ... } controller 的执行表示 directive 进入了上图中标识的 nodeLinkFn 阶段。这里的 nodeLinkFn 方法来自上一阶段 $compile 的返回，并且在返回时提供了 scope 入参。 这里，根据配置属性上 scope 的不同设置，传递给 controller 的 $scope 会有不同，具体见官方文档 scope 部分。 scope: false 默认值。不会有新的 scope 被创建，将使用父级 scope。 scope: true 会创建一个继承于父scope 的新 scope 给 directive 使用。 scope: {...} 创建一个独立的 scope 给 directive 使用。 然后 controller 则以上面的 scope 和实例化之后的 DOM 元素开始运行。 preLink 签名： function preLink(scope, iElement, iAttrs, controller) { ... }, 发生在所有子组件被 link 前。事实上这一阶段从视觉上看不出发生了什么。之后便是遍历所有子组件，将正确的 scope 传播下去。 可以理解为主要是遍历和组装各子组件使之 ready。 postLink 我们通常的说的 link 指的是 postLink，大部分逻辑是在这里面的。并且，无论是从 compile 方法返回的 link，还是配置对象中的 link, 默认指的都是 postLink。 它的签名是同 preLink 一样，入参上没有什么区别。 function postLink(scope, iElement, iAttrs, controller) { ... } 这个方法执行的时候，其所有子组件的 postLink 方法也都执行完毕。也就是说，所以子组件都已经完成了初始化，包括 数据绑定 模板嵌入 scope 传入 所以此刻模板的样子已经变成了： &lt;my-element&gt; &lt;div class=&quot;ng-binding&quot;&gt; &quot;&quot; &lt;div ng-transclude&gt; &lt;div class=&quot;ng-scope&quot;&gt;Inner content&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/my-element&gt; 执行顺序 上面理解了各步骤干的事情，这里通过代码看看他们的执行顺序，特别是在组件嵌套的情况下。 考察下面的示例代码： &lt;body&gt; &lt;div log=&#39;some-div&#39;&gt;&lt;/div&gt; &lt;/body&gt; 其中使用的 directive 代码为： myApp.directive(&#39;log&#39;, function() { return { controller: function( $scope, $element, $attrs, $transclude ) { console.log( $attrs.log + &#39; (controller)&#39; ); }, compile: function compile( tElement, tAttributes ) { console.log( tAttributes.log + &#39; (compile)&#39; ); return { pre: function preLink( scope, element, attributes ) { console.log( attributes.log + &#39; (pre-link)&#39; ); }, post: function postLink( scope, element, attributes ) { console.log( attributes.log + &#39; (post-link)&#39; ); } }; } }; }); 在每一个阶段里都进行了日志输出，以查看其执行顺序。 对于单个 directive 而言，无疑很简单，通过最前端的图都可以猜到 log 的顺序。 some-div (compile) some-div (controller) some-div (pre-link) some-div (post-link) 对于多个组件嵌套的情况，正常的 directive 是按照上面的顺序执行的，但一些 directive 譬如 ngIf，ngRepeat 或者其他使用 transclude 嵌套的组件，link 先于 compile 运行，因为这些组件是在 link 内渲染子组件的。 考察下面嵌套的示例代码: &lt;body&gt; &lt;div log=&#39;parent&#39;&gt; &lt;div log=&#39;..first-child&#39;&gt;&lt;/div&gt; &lt;div log=&#39;..second-child&#39;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 输出则是： // The compile phase parent (compile) ..first-child (compile) ..second-child (compile) // The link phase parent (controller) parent (pre-link) ..first-child (controller) ..first-child (pre-link) ..first-child (post-link) ..second-child (controller) ..second-child (pre-link) ..second-child (post-link) parent (post-link) 这里，可以明显体现出之前讨论过的两个阶段，compile 阶段和 link 阶段。 所以结论是 上面解释了各方法的顺序及作用。但并没有给出建议，写 directive 时用哪个比较合理。 还是出自同一个来自 stackoverflow 提问下的回答，@Izhaki 这位 Bro 的回答可以说是相当到位，分段落每个部分回答成一个答案。 compile 每个directive 的 compile 方法只执行一次，这里主要用来对 DOM 进行操作，前提是不影响 scope 及数据绑定的 DOM 操作。 考虑下面的示例代码： &lt;tr ng-repeat=&quot;raw in raws&quot;&gt; &lt;my-raw&gt;&lt;/my-raw&gt; &lt;/tr&gt; 假如说我们希望操作 my-raw 的 DOM 比如加个 span 进去。可以在 compile 中进行，然后让 ng-repeat 复制出许多克隆来，也可以在 ng-repeat 复制后（link 阶段），去操作每个复制出来的版本。 在数据量大的情况下，前者性能会好一些。 所以，在 compile 里面， 推荐 修改 DOM 模板 不推荐 绑定事件，因为这是复制之前，事件应该绑定到对应实例上 操作子元素 设置对属性的监听 设置对 scope 的监听 controller 实例化之后 controller 便开始执行。 在 controller 里，通常 定义一些可以与其他组件的 controller 共享的代码逻辑 初始化 scope 变量 需要注意的一点是，如果该组件使用独立的 scope，那么是没法使用从父级 scope 继承而来的那些变量的。 在 controller 里面， 推荐 书写 controller 逻辑 初始化 scope 变量 不推荐 操作子元素（因为有可能还没被渲染出来） preLink 也是在实例之后开始执行。根据前文的分析，preLink 的顺序是先父组件后子组件，刚好与 postLink 相反，后者先子组件最后回溯到父组件。 一般组件很少用到 compile 方法，preLink 则更加少的情况会被用到。只某些特殊情况下会很有用，譬如： ngModelController 不推荐 操作子元素（因为有可能还没被渲染出来） postLink postLink 执行的时候，上面的步骤都已经完成了：数据绑定，模板代码嵌入等。所以这里是对生成好的 DOM 进行再次操作的最好时机。 推荐 操作DOM（此时操作的是实例化 DOM） 绑定事件 与子元素进行交互 设置属性的监听 设置 scope 上的 监听 原始模板代码与实例模板代码 前面有提到过，这里不妨再细究一下。 原始模板代码 - 用来进行复制的原始模板，如果进行了复制操作，则原始模板是不会展示在界面上的 实例模板代码 - 从原始模板代码复制而来，绑定到对应组件实例，也就是每个组件实例会对应一分，它是真正被渲染到界面上的模板 譬如： &lt;div ng-repeat=&quot;i in [0,1,2]&quot;&gt; &lt;my-directive&gt;&lt;/my-directive&gt; &lt;/div&gt; 上面代码中，原始模板代码为： &lt;my-directive&gt;&lt;/my-directive&gt; 通过ng-repeat=&quot;i in [0,1,2]&quot;指令，这段模板会被复制成三分，复制出来的模板代码为实例模板代码，第一个都被绑定了各自的 scope，并且都会渲染到界面。 相关资源 Comprehensive Directive API Angular directives - when and how to use compile, controller, pre-link and post-link Difference between the ‘controller’, ‘link’ and ‘compile’ functions when defining a directive" />
<meta property="og:description" content="Angular Directive 中正确使用 compile，controller 与 link 编写 Angular Directive 时，到底该用 link 还是 controller，或者 compile。 看官方文档的示例代码时，也是一会儿用 link, 一会儿又用 controller。网上搜问题时遇到的代码也都是用每个的都有。 那么问题来了，这三者有何区别，什么情况下用哪个最合适。 重新认识 从官方文档 Comprehensive Directive API，可以找到一段 directive 完整定义的示例代码，其中，directiveDefinitionObject 就是完整定义一个 directive 的配置对象。是它告诉 Angular 的 $compile 如何去解析生成这个 directive。 var myModule = angular.module(...); myModule.directive(&#39;directiveName&#39;, function factory(injectables) { var directiveDefinitionObject = { priority: 0, template: &#39;&lt;div&gt;&lt;/div&gt;&#39;, // or // function(tElement, tAttrs) { ... }, // or // templateUrl: &#39;directive.html&#39;, // or // function(tElement, tAttrs) { ... }, transclude: false, restrict: &#39;A&#39;, templateNamespace: &#39;html&#39;, scope: false, controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... }, controllerAs: &#39;stringIdentifier&#39;, bindToController: false, require: &#39;siblingDirectiveName&#39;, // or // [&#39;^parentDirectiveName&#39;, &#39;?optionalDirectiveName&#39;, &#39;?^optionalParent&#39;], multiElement: false, compile: function compile(tElement, tAttrs, transclude) { return { pre: function preLink(scope, iElement, iAttrs, controller) { ... }, post: function postLink(scope, iElement, iAttrs, controller) { ... } } // or // return function postLink( ... ) { ... } }, // or // link: { // pre: function preLink(scope, iElement, iAttrs, controller) { ... }, // post: function postLink(scope, iElement, iAttrs, controller) { ... } // } // or // link: function postLink( ... ) { ... } }; return directiveDefinitionObject; }); 从上面示例代码可以看到本文要讨论的三个函数的关系。三者可以并列，但 compile 和 link 的关系有点微妙。这里，link 严格意义上是分为 preLink 及 postLink 的。默认情况下 link 指的是 postLink。两者之所以微妙，是因为有 compile 定义的情况下，配置对象中的 link 属性会被忽略。此时如果想使用 link 方法的话，需要在 compile 里进行返回。 平时只注重使用，也没细看。现在根据三者执行的顺序，来仔细认识一下他们，以看看三者的区别。 从 Stackoverflow 扒来的神图展示了 Angular 启动时都发生了些什么 从图中可看出，Anuglar 启动后，主要两部分， $compile 阶段 这里面包含了 Directive 的 compile 方法。 DOM 模板被加载后则开始了编译。遍历所有节点，找出 directive 然后调用每个 directive 的 cmopile 方法。这里使用的 DOM 模板代码为原始的 DOM 模板。 Angular directive compile 阶段 nodeLinkFn 阶段 这里面包含了 Directive 的 controller 以及 link (preLink 和 postLink)。 将原始的 DOM 模板代码生成到页面后，就认为实例化了该模板，因为该模板和一个实例 directive 进行了绑定，有确定的作用域 scope。所以这一阶段使用的 DOM 区别于前面，是实例化的 DOM。 实例化的 DOM 除了从原始 DOM 直接编译而来，还有的是通过 ngRepeat 等在代码中动态生成的。无论哪种形式而来，一旦 DOM 被渲染到页面，则开始的 link 阶段的工作。 Angular directive link 阶段 详细看看各步骤 为了更好理解各执行步骤，考察下面的示例代码： &lt;div ng-repeat=&quot;i in [0,1,2]&quot;&gt; &lt;my-element&gt; &lt;div&gt;Inner content&lt;/div&gt; &lt;/my-element&gt; &lt;/div&gt; 其中用到的 directive 代码为： myApp.directive( &#39;myElement&#39;, function() { return { restrict: &#39;EA&#39;, transclude: true, template: &#39;&lt;div&gt;&lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;&#39; } }); compile compile 主要用来对模板代码进行转换，大部分的 directive 用不到。 link 阶段的 DOM 是这一阶段产出的克隆版本。 首先来到的是 $compile 阶段。这里面包含了 directive 的 compile 方法。从上面示例代码中可以看出，它的签名是 compile: function compile( tElement, tAttributes ) { ... } 这里参数命名值得提一下，tElement 实际上指 template element，指的是直接从模板拿到的原始代码，以区别于实例的 element iElement (instance element)，后者指 directive 实例化之后的 DOM 代码，用在 link 方法中。 tAttributes 同理。 在 compile 执行之前，通过 ng-transclude 嵌入的代码会先被移除，然后模板代码被放入 directive 标签内。所以传给 compile 的 DOM 成了这样： &lt;my-element&gt; &lt;div&gt; &quot;&quot; &lt;div ng-transclude&gt;&lt;/div&gt; &lt;/div&gt; &lt;/my-element&gt; 然后就是调用 compile 方法。完了之后会将这个 directive 下所有子组件再走一遍这个流程。 组件的实例化 compile 可以理解为是对原始模板的编译处理。针对一个 directive 只进行一次。之后便是将编译好的代码实例出一个组件来。 上面参数命名的地方也提到过实例。指的也就是页面中一个 direcitve 的生成。这里，我们测试用的代码中，ng-repeat=&quot;i in [0,1,2]&quot; 会生成三个 myElement 的实例。也就是说，下面的步骤会进行三次，每实例化一个 directive 都会走一遍下面的流程。 Controller 从上面示例代码中，可以看到 controller 方法的签名是这样的： controller: function( $scope, $element, $attrs, $transclude ) { ... } controller 的执行表示 directive 进入了上图中标识的 nodeLinkFn 阶段。这里的 nodeLinkFn 方法来自上一阶段 $compile 的返回，并且在返回时提供了 scope 入参。 这里，根据配置属性上 scope 的不同设置，传递给 controller 的 $scope 会有不同，具体见官方文档 scope 部分。 scope: false 默认值。不会有新的 scope 被创建，将使用父级 scope。 scope: true 会创建一个继承于父scope 的新 scope 给 directive 使用。 scope: {...} 创建一个独立的 scope 给 directive 使用。 然后 controller 则以上面的 scope 和实例化之后的 DOM 元素开始运行。 preLink 签名： function preLink(scope, iElement, iAttrs, controller) { ... }, 发生在所有子组件被 link 前。事实上这一阶段从视觉上看不出发生了什么。之后便是遍历所有子组件，将正确的 scope 传播下去。 可以理解为主要是遍历和组装各子组件使之 ready。 postLink 我们通常的说的 link 指的是 postLink，大部分逻辑是在这里面的。并且，无论是从 compile 方法返回的 link，还是配置对象中的 link, 默认指的都是 postLink。 它的签名是同 preLink 一样，入参上没有什么区别。 function postLink(scope, iElement, iAttrs, controller) { ... } 这个方法执行的时候，其所有子组件的 postLink 方法也都执行完毕。也就是说，所以子组件都已经完成了初始化，包括 数据绑定 模板嵌入 scope 传入 所以此刻模板的样子已经变成了： &lt;my-element&gt; &lt;div class=&quot;ng-binding&quot;&gt; &quot;&quot; &lt;div ng-transclude&gt; &lt;div class=&quot;ng-scope&quot;&gt;Inner content&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/my-element&gt; 执行顺序 上面理解了各步骤干的事情，这里通过代码看看他们的执行顺序，特别是在组件嵌套的情况下。 考察下面的示例代码： &lt;body&gt; &lt;div log=&#39;some-div&#39;&gt;&lt;/div&gt; &lt;/body&gt; 其中使用的 directive 代码为： myApp.directive(&#39;log&#39;, function() { return { controller: function( $scope, $element, $attrs, $transclude ) { console.log( $attrs.log + &#39; (controller)&#39; ); }, compile: function compile( tElement, tAttributes ) { console.log( tAttributes.log + &#39; (compile)&#39; ); return { pre: function preLink( scope, element, attributes ) { console.log( attributes.log + &#39; (pre-link)&#39; ); }, post: function postLink( scope, element, attributes ) { console.log( attributes.log + &#39; (post-link)&#39; ); } }; } }; }); 在每一个阶段里都进行了日志输出，以查看其执行顺序。 对于单个 directive 而言，无疑很简单，通过最前端的图都可以猜到 log 的顺序。 some-div (compile) some-div (controller) some-div (pre-link) some-div (post-link) 对于多个组件嵌套的情况，正常的 directive 是按照上面的顺序执行的，但一些 directive 譬如 ngIf，ngRepeat 或者其他使用 transclude 嵌套的组件，link 先于 compile 运行，因为这些组件是在 link 内渲染子组件的。 考察下面嵌套的示例代码: &lt;body&gt; &lt;div log=&#39;parent&#39;&gt; &lt;div log=&#39;..first-child&#39;&gt;&lt;/div&gt; &lt;div log=&#39;..second-child&#39;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 输出则是： // The compile phase parent (compile) ..first-child (compile) ..second-child (compile) // The link phase parent (controller) parent (pre-link) ..first-child (controller) ..first-child (pre-link) ..first-child (post-link) ..second-child (controller) ..second-child (pre-link) ..second-child (post-link) parent (post-link) 这里，可以明显体现出之前讨论过的两个阶段，compile 阶段和 link 阶段。 所以结论是 上面解释了各方法的顺序及作用。但并没有给出建议，写 directive 时用哪个比较合理。 还是出自同一个来自 stackoverflow 提问下的回答，@Izhaki 这位 Bro 的回答可以说是相当到位，分段落每个部分回答成一个答案。 compile 每个directive 的 compile 方法只执行一次，这里主要用来对 DOM 进行操作，前提是不影响 scope 及数据绑定的 DOM 操作。 考虑下面的示例代码： &lt;tr ng-repeat=&quot;raw in raws&quot;&gt; &lt;my-raw&gt;&lt;/my-raw&gt; &lt;/tr&gt; 假如说我们希望操作 my-raw 的 DOM 比如加个 span 进去。可以在 compile 中进行，然后让 ng-repeat 复制出许多克隆来，也可以在 ng-repeat 复制后（link 阶段），去操作每个复制出来的版本。 在数据量大的情况下，前者性能会好一些。 所以，在 compile 里面， 推荐 修改 DOM 模板 不推荐 绑定事件，因为这是复制之前，事件应该绑定到对应实例上 操作子元素 设置对属性的监听 设置对 scope 的监听 controller 实例化之后 controller 便开始执行。 在 controller 里，通常 定义一些可以与其他组件的 controller 共享的代码逻辑 初始化 scope 变量 需要注意的一点是，如果该组件使用独立的 scope，那么是没法使用从父级 scope 继承而来的那些变量的。 在 controller 里面， 推荐 书写 controller 逻辑 初始化 scope 变量 不推荐 操作子元素（因为有可能还没被渲染出来） preLink 也是在实例之后开始执行。根据前文的分析，preLink 的顺序是先父组件后子组件，刚好与 postLink 相反，后者先子组件最后回溯到父组件。 一般组件很少用到 compile 方法，preLink 则更加少的情况会被用到。只某些特殊情况下会很有用，譬如： ngModelController 不推荐 操作子元素（因为有可能还没被渲染出来） postLink postLink 执行的时候，上面的步骤都已经完成了：数据绑定，模板代码嵌入等。所以这里是对生成好的 DOM 进行再次操作的最好时机。 推荐 操作DOM（此时操作的是实例化 DOM） 绑定事件 与子元素进行交互 设置属性的监听 设置 scope 上的 监听 原始模板代码与实例模板代码 前面有提到过，这里不妨再细究一下。 原始模板代码 - 用来进行复制的原始模板，如果进行了复制操作，则原始模板是不会展示在界面上的 实例模板代码 - 从原始模板代码复制而来，绑定到对应组件实例，也就是每个组件实例会对应一分，它是真正被渲染到界面上的模板 譬如： &lt;div ng-repeat=&quot;i in [0,1,2]&quot;&gt; &lt;my-directive&gt;&lt;/my-directive&gt; &lt;/div&gt; 上面代码中，原始模板代码为： &lt;my-directive&gt;&lt;/my-directive&gt; 通过ng-repeat=&quot;i in [0,1,2]&quot;指令，这段模板会被复制成三分，复制出来的模板代码为实例模板代码，第一个都被绑定了各自的 scope，并且都会渲染到界面。 相关资源 Comprehensive Directive API Angular directives - when and how to use compile, controller, pre-link and post-link Difference between the ‘controller’, ‘link’ and ‘compile’ functions when defining a directive" />
<link rel="canonical" href="http://localhost:4000/2017/11/28/%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8-Angular-Directive-%E4%B8%AD%E7%9A%84-compile-controller-%E4%B8%8E-link.html" />
<meta property="og:url" content="http://localhost:4000/2017/11/28/%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8-Angular-Directive-%E4%B8%AD%E7%9A%84-compile-controller-%E4%B8%8E-link.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-28T23:11:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2017/11/28/%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8-Angular-Directive-%E4%B8%AD%E7%9A%84-compile-controller-%E4%B8%8E-link.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2017/11/28/%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8-Angular-Directive-%E4%B8%AD%E7%9A%84-compile-controller-%E4%B8%8E-link.html"},"description":"Angular Directive 中正确使用 compile，controller 与 link 编写 Angular Directive 时，到底该用 link 还是 controller，或者 compile。 看官方文档的示例代码时，也是一会儿用 link, 一会儿又用 controller。网上搜问题时遇到的代码也都是用每个的都有。 那么问题来了，这三者有何区别，什么情况下用哪个最合适。 重新认识 从官方文档 Comprehensive Directive API，可以找到一段 directive 完整定义的示例代码，其中，directiveDefinitionObject 就是完整定义一个 directive 的配置对象。是它告诉 Angular 的 $compile 如何去解析生成这个 directive。 var myModule = angular.module(...); myModule.directive(&#39;directiveName&#39;, function factory(injectables) { var directiveDefinitionObject = { priority: 0, template: &#39;&lt;div&gt;&lt;/div&gt;&#39;, // or // function(tElement, tAttrs) { ... }, // or // templateUrl: &#39;directive.html&#39;, // or // function(tElement, tAttrs) { ... }, transclude: false, restrict: &#39;A&#39;, templateNamespace: &#39;html&#39;, scope: false, controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... }, controllerAs: &#39;stringIdentifier&#39;, bindToController: false, require: &#39;siblingDirectiveName&#39;, // or // [&#39;^parentDirectiveName&#39;, &#39;?optionalDirectiveName&#39;, &#39;?^optionalParent&#39;], multiElement: false, compile: function compile(tElement, tAttrs, transclude) { return { pre: function preLink(scope, iElement, iAttrs, controller) { ... }, post: function postLink(scope, iElement, iAttrs, controller) { ... } } // or // return function postLink( ... ) { ... } }, // or // link: { // pre: function preLink(scope, iElement, iAttrs, controller) { ... }, // post: function postLink(scope, iElement, iAttrs, controller) { ... } // } // or // link: function postLink( ... ) { ... } }; return directiveDefinitionObject; }); 从上面示例代码可以看到本文要讨论的三个函数的关系。三者可以并列，但 compile 和 link 的关系有点微妙。这里，link 严格意义上是分为 preLink 及 postLink 的。默认情况下 link 指的是 postLink。两者之所以微妙，是因为有 compile 定义的情况下，配置对象中的 link 属性会被忽略。此时如果想使用 link 方法的话，需要在 compile 里进行返回。 平时只注重使用，也没细看。现在根据三者执行的顺序，来仔细认识一下他们，以看看三者的区别。 从 Stackoverflow 扒来的神图展示了 Angular 启动时都发生了些什么 从图中可看出，Anuglar 启动后，主要两部分， $compile 阶段 这里面包含了 Directive 的 compile 方法。 DOM 模板被加载后则开始了编译。遍历所有节点，找出 directive 然后调用每个 directive 的 cmopile 方法。这里使用的 DOM 模板代码为原始的 DOM 模板。 Angular directive compile 阶段 nodeLinkFn 阶段 这里面包含了 Directive 的 controller 以及 link (preLink 和 postLink)。 将原始的 DOM 模板代码生成到页面后，就认为实例化了该模板，因为该模板和一个实例 directive 进行了绑定，有确定的作用域 scope。所以这一阶段使用的 DOM 区别于前面，是实例化的 DOM。 实例化的 DOM 除了从原始 DOM 直接编译而来，还有的是通过 ngRepeat 等在代码中动态生成的。无论哪种形式而来，一旦 DOM 被渲染到页面，则开始的 link 阶段的工作。 Angular directive link 阶段 详细看看各步骤 为了更好理解各执行步骤，考察下面的示例代码： &lt;div ng-repeat=&quot;i in [0,1,2]&quot;&gt; &lt;my-element&gt; &lt;div&gt;Inner content&lt;/div&gt; &lt;/my-element&gt; &lt;/div&gt; 其中用到的 directive 代码为： myApp.directive( &#39;myElement&#39;, function() { return { restrict: &#39;EA&#39;, transclude: true, template: &#39;&lt;div&gt;&lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;&#39; } }); compile compile 主要用来对模板代码进行转换，大部分的 directive 用不到。 link 阶段的 DOM 是这一阶段产出的克隆版本。 首先来到的是 $compile 阶段。这里面包含了 directive 的 compile 方法。从上面示例代码中可以看出，它的签名是 compile: function compile( tElement, tAttributes ) { ... } 这里参数命名值得提一下，tElement 实际上指 template element，指的是直接从模板拿到的原始代码，以区别于实例的 element iElement (instance element)，后者指 directive 实例化之后的 DOM 代码，用在 link 方法中。 tAttributes 同理。 在 compile 执行之前，通过 ng-transclude 嵌入的代码会先被移除，然后模板代码被放入 directive 标签内。所以传给 compile 的 DOM 成了这样： &lt;my-element&gt; &lt;div&gt; &quot;&quot; &lt;div ng-transclude&gt;&lt;/div&gt; &lt;/div&gt; &lt;/my-element&gt; 然后就是调用 compile 方法。完了之后会将这个 directive 下所有子组件再走一遍这个流程。 组件的实例化 compile 可以理解为是对原始模板的编译处理。针对一个 directive 只进行一次。之后便是将编译好的代码实例出一个组件来。 上面参数命名的地方也提到过实例。指的也就是页面中一个 direcitve 的生成。这里，我们测试用的代码中，ng-repeat=&quot;i in [0,1,2]&quot; 会生成三个 myElement 的实例。也就是说，下面的步骤会进行三次，每实例化一个 directive 都会走一遍下面的流程。 Controller 从上面示例代码中，可以看到 controller 方法的签名是这样的： controller: function( $scope, $element, $attrs, $transclude ) { ... } controller 的执行表示 directive 进入了上图中标识的 nodeLinkFn 阶段。这里的 nodeLinkFn 方法来自上一阶段 $compile 的返回，并且在返回时提供了 scope 入参。 这里，根据配置属性上 scope 的不同设置，传递给 controller 的 $scope 会有不同，具体见官方文档 scope 部分。 scope: false 默认值。不会有新的 scope 被创建，将使用父级 scope。 scope: true 会创建一个继承于父scope 的新 scope 给 directive 使用。 scope: {...} 创建一个独立的 scope 给 directive 使用。 然后 controller 则以上面的 scope 和实例化之后的 DOM 元素开始运行。 preLink 签名： function preLink(scope, iElement, iAttrs, controller) { ... }, 发生在所有子组件被 link 前。事实上这一阶段从视觉上看不出发生了什么。之后便是遍历所有子组件，将正确的 scope 传播下去。 可以理解为主要是遍历和组装各子组件使之 ready。 postLink 我们通常的说的 link 指的是 postLink，大部分逻辑是在这里面的。并且，无论是从 compile 方法返回的 link，还是配置对象中的 link, 默认指的都是 postLink。 它的签名是同 preLink 一样，入参上没有什么区别。 function postLink(scope, iElement, iAttrs, controller) { ... } 这个方法执行的时候，其所有子组件的 postLink 方法也都执行完毕。也就是说，所以子组件都已经完成了初始化，包括 数据绑定 模板嵌入 scope 传入 所以此刻模板的样子已经变成了： &lt;my-element&gt; &lt;div class=&quot;ng-binding&quot;&gt; &quot;&quot; &lt;div ng-transclude&gt; &lt;div class=&quot;ng-scope&quot;&gt;Inner content&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/my-element&gt; 执行顺序 上面理解了各步骤干的事情，这里通过代码看看他们的执行顺序，特别是在组件嵌套的情况下。 考察下面的示例代码： &lt;body&gt; &lt;div log=&#39;some-div&#39;&gt;&lt;/div&gt; &lt;/body&gt; 其中使用的 directive 代码为： myApp.directive(&#39;log&#39;, function() { return { controller: function( $scope, $element, $attrs, $transclude ) { console.log( $attrs.log + &#39; (controller)&#39; ); }, compile: function compile( tElement, tAttributes ) { console.log( tAttributes.log + &#39; (compile)&#39; ); return { pre: function preLink( scope, element, attributes ) { console.log( attributes.log + &#39; (pre-link)&#39; ); }, post: function postLink( scope, element, attributes ) { console.log( attributes.log + &#39; (post-link)&#39; ); } }; } }; }); 在每一个阶段里都进行了日志输出，以查看其执行顺序。 对于单个 directive 而言，无疑很简单，通过最前端的图都可以猜到 log 的顺序。 some-div (compile) some-div (controller) some-div (pre-link) some-div (post-link) 对于多个组件嵌套的情况，正常的 directive 是按照上面的顺序执行的，但一些 directive 譬如 ngIf，ngRepeat 或者其他使用 transclude 嵌套的组件，link 先于 compile 运行，因为这些组件是在 link 内渲染子组件的。 考察下面嵌套的示例代码: &lt;body&gt; &lt;div log=&#39;parent&#39;&gt; &lt;div log=&#39;..first-child&#39;&gt;&lt;/div&gt; &lt;div log=&#39;..second-child&#39;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 输出则是： // The compile phase parent (compile) ..first-child (compile) ..second-child (compile) // The link phase parent (controller) parent (pre-link) ..first-child (controller) ..first-child (pre-link) ..first-child (post-link) ..second-child (controller) ..second-child (pre-link) ..second-child (post-link) parent (post-link) 这里，可以明显体现出之前讨论过的两个阶段，compile 阶段和 link 阶段。 所以结论是 上面解释了各方法的顺序及作用。但并没有给出建议，写 directive 时用哪个比较合理。 还是出自同一个来自 stackoverflow 提问下的回答，@Izhaki 这位 Bro 的回答可以说是相当到位，分段落每个部分回答成一个答案。 compile 每个directive 的 compile 方法只执行一次，这里主要用来对 DOM 进行操作，前提是不影响 scope 及数据绑定的 DOM 操作。 考虑下面的示例代码： &lt;tr ng-repeat=&quot;raw in raws&quot;&gt; &lt;my-raw&gt;&lt;/my-raw&gt; &lt;/tr&gt; 假如说我们希望操作 my-raw 的 DOM 比如加个 span 进去。可以在 compile 中进行，然后让 ng-repeat 复制出许多克隆来，也可以在 ng-repeat 复制后（link 阶段），去操作每个复制出来的版本。 在数据量大的情况下，前者性能会好一些。 所以，在 compile 里面， 推荐 修改 DOM 模板 不推荐 绑定事件，因为这是复制之前，事件应该绑定到对应实例上 操作子元素 设置对属性的监听 设置对 scope 的监听 controller 实例化之后 controller 便开始执行。 在 controller 里，通常 定义一些可以与其他组件的 controller 共享的代码逻辑 初始化 scope 变量 需要注意的一点是，如果该组件使用独立的 scope，那么是没法使用从父级 scope 继承而来的那些变量的。 在 controller 里面， 推荐 书写 controller 逻辑 初始化 scope 变量 不推荐 操作子元素（因为有可能还没被渲染出来） preLink 也是在实例之后开始执行。根据前文的分析，preLink 的顺序是先父组件后子组件，刚好与 postLink 相反，后者先子组件最后回溯到父组件。 一般组件很少用到 compile 方法，preLink 则更加少的情况会被用到。只某些特殊情况下会很有用，譬如： ngModelController 不推荐 操作子元素（因为有可能还没被渲染出来） postLink postLink 执行的时候，上面的步骤都已经完成了：数据绑定，模板代码嵌入等。所以这里是对生成好的 DOM 进行再次操作的最好时机。 推荐 操作DOM（此时操作的是实例化 DOM） 绑定事件 与子元素进行交互 设置属性的监听 设置 scope 上的 监听 原始模板代码与实例模板代码 前面有提到过，这里不妨再细究一下。 原始模板代码 - 用来进行复制的原始模板，如果进行了复制操作，则原始模板是不会展示在界面上的 实例模板代码 - 从原始模板代码复制而来，绑定到对应组件实例，也就是每个组件实例会对应一分，它是真正被渲染到界面上的模板 譬如： &lt;div ng-repeat=&quot;i in [0,1,2]&quot;&gt; &lt;my-directive&gt;&lt;/my-directive&gt; &lt;/div&gt; 上面代码中，原始模板代码为： &lt;my-directive&gt;&lt;/my-directive&gt; 通过ng-repeat=&quot;i in [0,1,2]&quot;指令，这段模板会被复制成三分，复制出来的模板代码为实例模板代码，第一个都被绑定了各自的 scope，并且都会渲染到界面。 相关资源 Comprehensive Directive API Angular directives - when and how to use compile, controller, pre-link and post-link Difference between the ‘controller’, ‘link’ and ‘compile’ functions when defining a directive","@type":"BlogPosting","headline":"正确地使用 Angular Directive 中的 compile，controller 与 link","dateModified":"2017-11-28T23:11:00+08:00","datePublished":"2017-11-28T23:11:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">正确地使用 Angular Directive 中的 compile，controller 与 link</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-11-28T23:11:00+08:00" itemprop="datePublished">Nov 28, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="angular-directive-中正确使用-compilecontroller-与-link">Angular Directive 中正确使用 compile，controller 与 link</h2>

<p>编写 Angular Directive 时，到底该用 <code class="language-plaintext highlighter-rouge">link</code> 还是 <code class="language-plaintext highlighter-rouge">controller</code>，或者 <code class="language-plaintext highlighter-rouge">compile</code>。 看官方文档的示例代码时，也是一会儿用 <code class="language-plaintext highlighter-rouge">link</code>, 一会儿又用 <code class="language-plaintext highlighter-rouge">controller</code>。网上搜问题时遇到的代码也都是用每个的都有。</p>

<p>那么问题来了，这三者有何区别，什么情况下用哪个最合适。</p>

<h3 id="重新认识">重新认识</h3>

<p>从官方文档 <a href="https://docs.angularjs.org/api/ng/service/$compile#comprehensive-directive-api">Comprehensive Directive API</a>，可以找到一段 directive 完整定义的示例代码，其中，<code class="language-plaintext highlighter-rouge">directiveDefinitionObject</code> 就是完整定义一个 directive 的配置对象。是它告诉 Angular 的 <code class="language-plaintext highlighter-rouge">$compile</code> 如何去解析生成这个 directive。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">myModule</span> <span class="o">=</span> <span class="nx">angular</span><span class="p">.</span><span class="nx">module</span><span class="p">(...);</span>

<span class="nx">myModule</span><span class="p">.</span><span class="nx">directive</span><span class="p">(</span><span class="dl">'</span><span class="s1">directiveName</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">factory</span><span class="p">(</span><span class="nx">injectables</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">directiveDefinitionObject</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">priority</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="na">template</span><span class="p">:</span> <span class="dl">'</span><span class="s1">&lt;div&gt;&lt;/div&gt;</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// or // function(tElement, tAttrs) { ... },</span>
    <span class="c1">// or</span>
    <span class="c1">// templateUrl: 'directive.html', // or // function(tElement, tAttrs) { ... },</span>
    <span class="na">transclude</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="na">restrict</span><span class="p">:</span> <span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">templateNamespace</span><span class="p">:</span> <span class="dl">'</span><span class="s1">html</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">scope</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="na">controller</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$scope</span><span class="p">,</span> <span class="nx">$element</span><span class="p">,</span> <span class="nx">$attrs</span><span class="p">,</span> <span class="nx">$transclude</span><span class="p">,</span> <span class="nx">otherInjectables</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
    <span class="na">controllerAs</span><span class="p">:</span> <span class="dl">'</span><span class="s1">stringIdentifier</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">bindToController</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="na">require</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siblingDirectiveName</span><span class="dl">'</span><span class="p">,</span> <span class="c1">// or // ['^parentDirectiveName', '?optionalDirectiveName', '?^optionalParent'],</span>
    <span class="na">multiElement</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="na">compile</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">compile</span><span class="p">(</span><span class="nx">tElement</span><span class="p">,</span> <span class="nx">tAttrs</span><span class="p">,</span> <span class="nx">transclude</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
         <span class="na">pre</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">preLink</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">iElement</span><span class="p">,</span> <span class="nx">iAttrs</span><span class="p">,</span> <span class="nx">controller</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
         <span class="na">post</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">postLink</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">iElement</span><span class="p">,</span> <span class="nx">iAttrs</span><span class="p">,</span> <span class="nx">controller</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
      <span class="p">}</span>
      <span class="c1">// or</span>
      <span class="c1">// return function postLink( ... ) { ... }</span>
    <span class="p">},</span>
    <span class="c1">// or</span>
    <span class="c1">// link: {</span>
    <span class="c1">//  pre: function preLink(scope, iElement, iAttrs, controller) { ... },</span>
    <span class="c1">//  post: function postLink(scope, iElement, iAttrs, controller) { ... }</span>
    <span class="c1">// }</span>
    <span class="c1">// or</span>
    <span class="c1">// link: function postLink( ... ) { ... }</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="nx">directiveDefinitionObject</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>从上面示例代码可以看到本文要讨论的三个函数的关系。三者可以并列，但 compile 和 link 的关系有点微妙。这里，link 严格意义上是分为 preLink 及 postLink 的。默认情况下 link 指的是 postLink。两者之所以微妙，是因为有 compile 定义的情况下，配置对象中的 link 属性会被忽略。此时如果想使用 link 方法的话，需要在 compile 里进行返回。</p>

<p>平时只注重使用，也没细看。现在根据三者执行的顺序，来仔细认识一下他们，以看看三者的区别。</p>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/understanding-angular-directive-hooks/assets/angular-bootstrap-steps.png" alt="从 Stackoverflow 扒来的神图展示了 Angular 启动时都发生了些什么" /></p>

<p><em>从 Stackoverflow 扒来的神图展示了 Angular 启动时都发生了些什么</em></p>

<p>从图中可看出，Anuglar 启动后，主要两部分，</p>

<h4 id="compile-阶段">$compile 阶段</h4>

<p>这里面包含了 Directive 的 <code class="language-plaintext highlighter-rouge">compile</code> 方法。</p>

<p>DOM 模板被加载后则开始了编译。遍历所有节点，找出 directive 然后调用每个 directive 的 <code class="language-plaintext highlighter-rouge">cmopile</code> 方法。这里使用的 DOM 模板代码为原始的 DOM 模板。</p>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/understanding-angular-directive-hooks/assets/compile-phase.png" alt="Angular directive compile 阶段" /></p>

<p><em>Angular directive compile 阶段</em></p>

<h4 id="nodelinkfn-阶段">nodeLinkFn 阶段</h4>

<p>这里面包含了 Directive 的 <code class="language-plaintext highlighter-rouge">controller</code> 以及 <code class="language-plaintext highlighter-rouge">link</code> (<code class="language-plaintext highlighter-rouge">preLink</code> 和 <code class="language-plaintext highlighter-rouge">postLink</code>)。</p>

<p>将原始的 DOM 模板代码生成到页面后，就认为实例化了该模板，因为该模板和一个实例 directive 进行了绑定，有确定的作用域 scope。所以这一阶段使用的 DOM 区别于前面，是实例化的 DOM。</p>

<p>实例化的 DOM 除了从原始 DOM 直接编译而来，还有的是通过 <code class="language-plaintext highlighter-rouge">ngRepeat</code> 等在代码中动态生成的。无论哪种形式而来，一旦 DOM 被渲染到页面，则开始的 link 阶段的工作。</p>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/understanding-angular-directive-hooks/assets/link-phase.png" alt="Angular directive link 阶段" /></p>

<p><em>Angular directive link 阶段</em></p>

<h3 id="详细看看各步骤">详细看看各步骤</h3>

<p>为了更好理解各执行步骤，考察下面的示例代码：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">ng-repeat=</span><span class="s">"i in [0,1,2]"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;my-element&gt;</span>
        <span class="nt">&lt;div&gt;</span>Inner content<span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;/my-element&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>其中用到的 directive 代码为：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">myApp</span><span class="p">.</span><span class="nx">directive</span><span class="p">(</span> <span class="dl">'</span><span class="s1">myElement</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">restrict</span><span class="p">:</span>   <span class="dl">'</span><span class="s1">EA</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">transclude</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">template</span><span class="p">:</span>   <span class="dl">'</span><span class="s1">&lt;div&gt;&lt;div ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;</span><span class="dl">'</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<h4 id="compile">compile</h4>

<p>compile 主要用来对模板代码进行转换，大部分的 directive 用不到。 <code class="language-plaintext highlighter-rouge">link</code> 阶段的 DOM 是这一阶段产出的克隆版本。</p>

<p>首先来到的是 $compile 阶段。这里面包含了 directive 的 compile 方法。从上面示例代码中可以看出，它的签名是</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">compile</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">compile</span><span class="p">(</span> <span class="nx">tElement</span><span class="p">,</span> <span class="nx">tAttributes</span> <span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>这里参数命名值得提一下，<code class="language-plaintext highlighter-rouge">tElement</code> 实际上指 <code class="language-plaintext highlighter-rouge">template element</code>，指的是直接从模板拿到的原始代码，以区别于实例的 <code class="language-plaintext highlighter-rouge">element</code> <code class="language-plaintext highlighter-rouge">iElement</code> (instance element)，后者指 directive 实例化之后的 DOM 代码，用在 link 方法中。 <code class="language-plaintext highlighter-rouge">tAttributes</code> 同理。</p>

<p>在 compile 执行之前，通过 <code class="language-plaintext highlighter-rouge">ng-transclude</code> 嵌入的代码会先被移除，然后模板代码被放入 directive 标签内。所以传给 compile 的 DOM 成了这样：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-element&gt;</span>
    <span class="nt">&lt;div&gt;</span>
        ""
        <span class="nt">&lt;div</span> <span class="na">ng-transclude</span><span class="nt">&gt;&lt;/div&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/my-element&gt;</span>
</code></pre></div></div>
<p>然后就是调用 compile 方法。完了之后会将这个 directive 下所有子组件再走一遍这个流程。</p>

<h3 id="组件的实例化">组件的实例化</h3>

<p>compile 可以理解为是对原始模板的编译处理。针对一个 directive 只进行一次。之后便是将编译好的代码实例出一个组件来。</p>

<p>上面参数命名的地方也提到过实例。指的也就是页面中一个 direcitve 的生成。这里，我们测试用的代码中，<code class="language-plaintext highlighter-rouge">ng-repeat="i in [0,1,2]"</code> 会生成三个 <code class="language-plaintext highlighter-rouge">myElement</code> 的实例。也就是说，下面的步骤会进行三次，每实例化一个 directive 都会走一遍下面的流程。</p>

<h4 id="controller">Controller</h4>

<p>从上面示例代码中，可以看到 controller 方法的签名是这样的：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">controller</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">$scope</span><span class="p">,</span> <span class="nx">$element</span><span class="p">,</span> <span class="nx">$attrs</span><span class="p">,</span> <span class="nx">$transclude</span> <span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>controller 的执行表示 directive 进入了上图中标识的 nodeLinkFn 阶段。这里的 nodeLinkFn 方法来自上一阶段 $compile 的返回，并且在返回时提供了 <code class="language-plaintext highlighter-rouge">scope</code> 入参。</p>

<p>这里，根据配置属性上 <code class="language-plaintext highlighter-rouge">scope</code> 的不同设置，传递给 controller 的 <code class="language-plaintext highlighter-rouge">$scope</code> 会有不同，具体见<a href="https://docs.angularjs.org/api/ng/service/$compile#-scope-">官方文档 scope 部分</a>。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">scope: false</code> 默认值。不会有新的 scope 被创建，将使用父级 scope。</li>
  <li><code class="language-plaintext highlighter-rouge">scope: true</code> 会创建一个继承于父scope 的新 scope 给 directive 使用。</li>
  <li><code class="language-plaintext highlighter-rouge">scope: {...}</code> 创建一个独立的 scope 给 directive 使用。</li>
</ul>

<p>然后 controller 则以上面的 scope 和实例化之后的 DOM 元素开始运行。</p>

<h4 id="prelink">preLink</h4>

<p>签名：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">preLink</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">iElement</span><span class="p">,</span> <span class="nx">iAttrs</span><span class="p">,</span> <span class="nx">controller</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
</code></pre></div></div>

<p>发生在所有子组件被 link 前。事实上这一阶段从视觉上看不出发生了什么。之后便是遍历所有子组件，将正确的 scope 传播下去。</p>

<p>可以理解为主要是遍历和组装各子组件使之 ready。</p>

<h4 id="postlink">postLink</h4>

<p>我们通常的说的 link 指的是 postLink，大部分逻辑是在这里面的。并且，无论是从 compile 方法返回的 link，还是配置对象中的 link, 默认指的都是 postLink。</p>

<p>它的签名是同 preLink 一样，入参上没有什么区别。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">postLink</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">iElement</span><span class="p">,</span> <span class="nx">iAttrs</span><span class="p">,</span> <span class="nx">controller</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>这个方法执行的时候，其所有子组件的 postLink 方法也都执行完毕。也就是说，所以子组件都已经完成了初始化，包括</p>

<ul>
  <li>数据绑定</li>
  <li>模板嵌入</li>
  <li>scope 传入</li>
</ul>

<p>所以此刻模板的样子已经变成了：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;my-element&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"ng-binding"</span><span class="nt">&gt;</span>
        ""
        <span class="nt">&lt;div</span> <span class="na">ng-transclude</span><span class="nt">&gt;</span>                
            <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"ng-scope"</span><span class="nt">&gt;</span>Inner content<span class="nt">&lt;/div&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/my-element&gt;</span>
</code></pre></div></div>

<h3 id="执行顺序">执行顺序</h3>

<p>上面理解了各步骤干的事情，这里通过代码看看他们的执行顺序，特别是在组件嵌套的情况下。</p>

<p>考察下面的示例代码：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">log=</span><span class="s">'some-div'</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div>

<p>其中使用的 directive 代码为：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">myApp</span><span class="p">.</span><span class="nx">directive</span><span class="p">(</span><span class="dl">'</span><span class="s1">log</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="na">controller</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">$scope</span><span class="p">,</span> <span class="nx">$element</span><span class="p">,</span> <span class="nx">$attrs</span><span class="p">,</span> <span class="nx">$transclude</span> <span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">$attrs</span><span class="p">.</span><span class="nx">log</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> (controller)</span><span class="dl">'</span> <span class="p">);</span>
        <span class="p">},</span>
        <span class="na">compile</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">compile</span><span class="p">(</span> <span class="nx">tElement</span><span class="p">,</span> <span class="nx">tAttributes</span> <span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">tAttributes</span><span class="p">.</span><span class="nx">log</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> (compile)</span><span class="dl">'</span>  <span class="p">);</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="na">pre</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">preLink</span><span class="p">(</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">element</span><span class="p">,</span> <span class="nx">attributes</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">attributes</span><span class="p">.</span><span class="nx">log</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> (pre-link)</span><span class="dl">'</span>  <span class="p">);</span>
                <span class="p">},</span>
                <span class="na">post</span><span class="p">:</span> <span class="kd">function</span> <span class="nx">postLink</span><span class="p">(</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">element</span><span class="p">,</span> <span class="nx">attributes</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">attributes</span><span class="p">.</span><span class="nx">log</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> (post-link)</span><span class="dl">'</span>  <span class="p">);</span>
                <span class="p">}</span>
            <span class="p">};</span>
         <span class="p">}</span>
     <span class="p">};</span>  

<span class="p">});</span>
</code></pre></div></div>

<p>在每一个阶段里都进行了日志输出，以查看其执行顺序。</p>

<p>对于单个 <code class="language-plaintext highlighter-rouge">directive</code> 而言，无疑很简单，通过最前端的图都可以猜到 <code class="language-plaintext highlighter-rouge">log</code> 的顺序。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>some-div (compile)
some-div (controller)
some-div (pre-link)
some-div (post-link)
</code></pre></div></div>

<p>对于多个组件嵌套的情况，正常的 directive 是按照上面的顺序执行的，但一些 directive 譬如 ngIf，ngRepeat 或者其他使用 <code class="language-plaintext highlighter-rouge">transclude</code> 嵌套的组件，<code class="language-plaintext highlighter-rouge">link</code> 先于 <code class="language-plaintext highlighter-rouge">compile</code> 运行，因为这些组件是在 <code class="language-plaintext highlighter-rouge">link</code> 内渲染子组件的。</p>

<p>考察下面嵌套的示例代码:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">log=</span><span class="s">'parent'</span><span class="nt">&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">log=</span><span class="s">'..first-child'</span><span class="nt">&gt;&lt;/div&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">log=</span><span class="s">'..second-child'</span><span class="nt">&gt;&lt;/div&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div>

<p>输出则是：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// The compile phase
parent (compile)
..first-child (compile)
..second-child (compile)

// The link phase   
parent (controller)
parent (pre-link)
..first-child (controller)
..first-child (pre-link)
..first-child (post-link)
..second-child (controller)
..second-child (pre-link)
..second-child (post-link)
parent (post-link)
</code></pre></div></div>

<p>这里，可以明显体现出之前讨论过的两个阶段，compile 阶段和 link 阶段。</p>

<h3 id="所以结论是">所以结论是</h3>

<p>上面解释了各方法的顺序及作用。但并没有给出建议，写 directive 时用哪个比较合理。</p>

<p>还是出自同一个来自 stackoverflow 提问下的回答，<a href="https://stackoverflow.com/users/1179377/izhaki">@Izhaki</a> 这位 Bro 的回答可以说是相当到位，分段落每个部分回答成一个答案。</p>

<h4 id="compile-1">compile</h4>

<p>每个directive 的 compile 方法只执行一次，这里主要用来对 DOM 进行操作，前提是不影响 scope 及数据绑定的 DOM 操作。</p>

<p>考虑下面的示例代码：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;tr</span> <span class="na">ng-repeat=</span><span class="s">"raw in raws"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;my-raw&gt;&lt;/my-raw&gt;</span>
<span class="nt">&lt;/tr&gt;</span>
</code></pre></div></div>
<p>假如说我们希望操作 <code class="language-plaintext highlighter-rouge">my-raw</code> 的 DOM 比如加个 <code class="language-plaintext highlighter-rouge">span</code> 进去。可以在 compile 中进行，然后让 <code class="language-plaintext highlighter-rouge">ng-repeat</code> 复制出许多克隆来，也可以在 <code class="language-plaintext highlighter-rouge">ng-repeat</code> 复制后（link 阶段），去操作每个复制出来的版本。</p>

<p>在数据量大的情况下，前者性能会好一些。</p>

<p>所以，在 compile 里面，</p>

<p><strong>推荐</strong></p>
<ul>
  <li>修改 DOM 模板</li>
</ul>

<p><strong>不推荐</strong></p>
<ul>
  <li>绑定事件，因为这是复制之前，事件应该绑定到对应实例上</li>
  <li>操作子元素</li>
  <li>设置对属性的监听</li>
  <li>设置对 scope 的监听</li>
</ul>

<h4 id="controller-1">controller</h4>

<p>实例化之后 controller 便开始执行。</p>

<p>在 controller 里，通常</p>

<ul>
  <li>定义一些可以与其他组件的 controller 共享的代码逻辑</li>
  <li>初始化 scope 变量</li>
</ul>

<p>需要注意的一点是，如果该组件使用独立的 scope，那么是没法使用从父级 scope 继承而来的那些变量的。</p>

<p>在 controller 里面，</p>

<p><strong>推荐</strong></p>
<ul>
  <li>书写 controller 逻辑</li>
  <li>初始化 scope 变量</li>
</ul>

<p><strong>不推荐</strong></p>
<ul>
  <li>操作子元素（因为有可能还没被渲染出来）</li>
</ul>

<h4 id="prelink-1">preLink</h4>

<p>也是在实例之后开始执行。根据前文的分析，preLink 的顺序是先父组件后子组件，刚好与 postLink 相反，后者先子组件最后回溯到父组件。</p>

<p>一般组件很少用到 compile 方法，preLink 则更加少的情况会被用到。只某些特殊情况下会很有用，譬如：</p>

<p><code class="language-plaintext highlighter-rouge">ngModelController</code></p>

<p><strong>不推荐</strong></p>
<ul>
  <li>操作子元素（因为有可能还没被渲染出来）</li>
</ul>

<h4 id="postlink-1">postLink</h4>

<p>postLink 执行的时候，上面的步骤都已经完成了：数据绑定，模板代码嵌入等。所以这里是对生成好的 DOM 进行再次操作的最好时机。</p>

<p><strong>推荐</strong></p>
<ul>
  <li>操作DOM（此时操作的是实例化 DOM）</li>
  <li>绑定事件</li>
  <li>与子元素进行交互</li>
  <li>设置属性的监听</li>
  <li>设置 scope 上的 监听</li>
</ul>

<h3 id="原始模板代码与实例模板代码">原始模板代码与实例模板代码</h3>

<p>前面有提到过，这里不妨再细究一下。</p>

<ul>
  <li>原始模板代码 - 用来进行复制的原始模板，如果进行了复制操作，则原始模板是不会展示在界面上的</li>
  <li>实例模板代码 - 从原始模板代码复制而来，绑定到对应组件实例，也就是每个组件实例会对应一分，它是真正被渲染到界面上的模板</li>
</ul>

<p>譬如：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">ng-repeat=</span><span class="s">"i in [0,1,2]"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;my-directive&gt;&lt;/my-directive&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>
<p>上面代码中，原始模板代码为：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">&lt;my-directive&gt;&lt;/my-directive&gt;</span>
</code></pre></div></div>

<p>通过<code class="language-plaintext highlighter-rouge">ng-repeat="i in [0,1,2]"</code>指令，这段模板会被复制成三分，复制出来的模板代码为实例模板代码，第一个都被绑定了各自的 scope，并且都会渲染到界面。</p>

<h3 id="相关资源">相关资源</h3>

<ul>
  <li><a href="https://docs.angularjs.org/api/ng/service/$compile#comprehensive-directive-api">Comprehensive Directive API</a></li>
  <li><a href="https://stackoverflow.com/a/24615185/1553656">Angular directives - when and how to use compile, controller, pre-link and post-link</a></li>
  <li><a href="https://stackoverflow.com/a/12570008/1553656">Difference between the ‘controller’, ‘link’ and ‘compile’ functions when defining a directive</a></li>
</ul>


  </div><a class="u-url" href="/2017/11/28/%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8-Angular-Directive-%E4%B8%AD%E7%9A%84-compile-controller-%E4%B8%8E-link.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
