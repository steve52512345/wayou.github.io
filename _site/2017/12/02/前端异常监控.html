<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>前端异常监控 | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="前端异常监控" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="前端异常监控 如果说前端的异常监控有个救星的话，我想那就是 window.onerror 这个全局错误监听事件了。它给了我们统一处理前端全局错误的机会，使得错误上报有了一线生机。 window.onerror = function(messageOrEvent, source, lineno, colno, error) { ... } message: 错误信息，在 HTML 中的 onerror 属性中设置的回调可以传递事件 source: 出错文件的 url lineno: 出错位置的行数 colno: 出错时的列数 error: 出错时的 Error 对象。 实践中发现最后个参数 Error 对象中的值因浏览器的实现各有差异，比如 Chrome 中包含 message 和 stack，而 Safari 中则包含了前面四个参数的所有值。这在下面的示例代码的结果中可以看得出来。 牵出来溜一溜 注意 window.onerror 需要在有服务端的情况下才能正常工作，本地直接打开页面测试获取不到任何有用的错误信息。可以在命令行启动一个简单的服务端来进行测试。 因为 Mac 自带 Python，一般需要用到服务端的时候，我喜欢用 Python 自带的 SimpleHTTPServer： python -m SimpleHTTPServer or python3 -m http.server 以下代码我们对全局错误进行监听，然后将错误打印到页面： window.onerror = function (msg, source, line, col, error) { printError.apply(null, arguments); }; function printError(msg, source, line, col, error) { var detail = &#39;msg:&#39; + msg + &#39;\ncourse:&#39; + source + &#39;\nline:&#39; + line + &#39;\ncol:&#39; + col + &#39;\nerror:&#39; + JSON.stringify(error, Object.getOwnPropertyNames(error)); var div = document.createElement(&#39;pre&#39;); div.innerHTML = detail document.body.appendChild(div); } 然后在页面放上按钮以触发错误。这里测试了两种错误，一种运行时 JS 的抛错，另一种手动在代码中抛出的错误。 &lt;button onclick=&quot;excptionGenerate()&quot;&gt;点我执行出错代码&lt;/button&gt; &lt;button onclick=&quot;throwError()&quot;&gt;点我手动抛出异常&lt;/button&gt; Chrome 中异常的捕获与打印 Safari 中异常的捕获与打印 浏览器兼容性 要知道，最初版本的全局错误监听事件是这样的： window.onerror = function(messageOrEvent, source, lineno) { ... } 后来才增加了 colno 和 error。而后来加的这两个参数其实是非常有用的。 因为线上代码一般为压缩过的代码，所有内容都在一行，假如没有提供发生问题的列数，这样的错误日志要追查起来很不方便。 错误对象则直接提供了错误堆栈信息（通过 error.stack 访问），就像我们在浏览器控制台看到的一样，对于定位问题十分有帮助。 主流浏览器中， Chrome， Safari 已经完成了5个参数的支持。 Firefox 从 31 开始支持了完整的5个参数。 截止到目前， 微软的 Edge 浏览器还没有实现对新增两个参数的支持。其实现情况可以在这里查阅得到。 小贴士 * 过程中顺便发现了微软Edge这个API Catalog页面可以查到主流浏览器对名前端特性的实现情况，数据比 caniuse 全，譬如 window.onerror 在 caniuse 上则没有。 MS Edge 浏览器对 window.onerror 第五个参数的实现情况 从这里也可以看到，其他主流浏览器都已经有了完整的支持。 IE，（逃~） 垫片 对于不提供第5个参数的环境，我们是拿不到错误堆栈信息的。这种情况下对错误的追查帮助不大。 但是，手动在代码中捕获并抛出的错误，是带了堆栈信息的。这就有了补救的希望。我们可以将可能出错的地方，或者我们期望进行监控的地方，使用 try catch。 function tryCatchError() { try { a(); } catch (error) { printError(error) } } function printError(error) { var detail = &#39;error:&#39; + JSON.stringify(error, Object.getOwnPropertyNames(error)) + &#39;\n\n&#39;; } var div = document.createElement(&#39;code&#39;); div.innerHTML = detail document.body.appendChild(div); } 同时在页面中添加按钮来调用新的测试函数。 &lt;button onclick=&quot;tryCatchError()&quot;&gt;利用 try catch 捕获异常并打印错误堆栈&lt;/button&gt; try catch 中打印错误 我们看到，这种方式确实能得到详细的报错堆栈。 这一段其实无关紧要 因为最后两个参数是后面加的，有理由相信，在很老很老很老的 Chrome 版本中，也是不支持全部5个参数的。来自Ben Vinegar的这篇文章指出 Chrome 46 开始支持全部5个参数的。 为此我们不妨找一个老版本来验一下。我去 Chrome 的历史仓库中 下到了 Chromium 15 （Chrome 正式发布前的开发版）。 拥有历史厚重感的老版本 Chrome 打开它，仿佛打开了一个刚出土的文物，在 Retina 屏上，它的皮肤已经略出了清晰的锯齿，这是历史的厚重，这是岁月刻下的痕迹。 不过还好，它的功能依然完好，跑起来我们的示例代码来驾轻就熟。 老版本的 Chrome 果然是没有后两位参数的 全局无法捕获的情况 除了考虑上面的浏览器兼容性问题外，还有其他一些情况，也是无法通过这个全局的 onerror 获取到详细报错信息的。 跨域情况的错误捕获(CDN) window.onerror 有个限制，来自非同域的代码有报错，不会给出错误的详细信息，只能得到一个 Script error.。这是浏览器出于安全考虑，不向第三方泄露信息而做的一个措施。但往往线上代码大部分都部署在 CDN，所以这个限制的影响还挺常见。 不过还好，某些浏览器中可以通过配置来更改这一行为，让我们能正常拿到报错的详细信息。 还有一点，就是虽然在 window.onerror 中倒不到详细的报错信息，但在浏览器控制台是可以看到详细信息的。 如果是跨域脚本，则提示去控制台查看报错信息 window.onerror = function (msg, url, lineNo, columnNo, error) { var string = msg.toLowerCase(); var substring = &quot;script error&quot;; if (string.indexOf(substring) &gt; -1){ alert(&#39;Script Error: See Browser Console for Detail&#39;); } else { var message = [ &#39;Message: &#39; + msg, &#39;URL: &#39; + url, &#39;Line: &#39; + lineNo, &#39;Column: &#39; + columnNo, &#39;Error object: &#39; + JSON.stringify(error) ].join(&#39; - &#39;); alert(message); } return false; }; 控制台能看到对于线上的错误监控来说没多大用，还是得解决上报的问题。我们来看看如何设置跨域脚本让我们可以捕获时拿到错误堆栈信息。 下面看跨域脚本的配置。 CDN 上开启允许跨域 Access-Control-Allow-Origin:* 或者 Access-Control-Allow-Origin: domain of your site 然后 script 标签上设置跨域标识为匿名 &lt;script crossorigin=&quot;anonymous&quot; src=&quot;//url/for/your/cdn/scripts&quot;&gt;&lt;/script&gt; 唯一需要注意的是，一旦在前端设置了 crossorigin，要确保服务端相应设置了允许跨域的响应头，否则整个脚本文件会加载失败，影响页面正常功能。 目前来看，除了 Opera外，各主流浏览器都有支持此属性。 跨域脚本加载浏览器兼容性 iframe 中异常的捕获 iframe 中发生异常，外界的 onerror 是不会触发的。但如果 iframe 地址同域，那么我们就可以设置 iframe 的全局 onerror 进行监听。 document.getElementById(&quot;myiframe&quot;).contentWindow.onerror=function() { alert(&#39;error!!&#39;); return false; } 以上代码需要保证在 iframe 加载完成后进行。 非同域情况下，如果 ifame 内的内容不来自第三方，也就是你自己可以控制，那么可以通过与 iframe 内进行通信的方式，将异常信息抛出来。iframe 通信试有很多，譬如 postMessage。这里不展开了。 非同域且内容不受自己控制的情况下，除了在控制台查看错误详细信息，真的没其他办法可以捕获了。 代码压缩在错误捕获中的还原 线上代码一般是压缩过的，如何更友好地展示还原事件发生地，对于错误上报也是个挑战。因为在错误监听的回调里面提供了列数，所以对于压缩后的代码，定位起位置来也不是难事，再结合错误对象里的报错堆栈信息，能够很好地定位代码的位置及原因。 关于压缩后的代码，有 sourse map 可以映射到源码，如果我们在异常捕获时通过与 soruce map 文件结合起来，那么就有可能在还原错误时分析出其在未压缩源码中的位置。目前来看，已经有相关的服务实现了这一功能，sentry 的文档中有提到。 前面讨论了一下错误详细信息的获取，最终我们是想在客户端收集到这些信息，再加上 ua, 发生错误的时间，设备相关信息等上报到服务端。总之，能够获取到信息越全越好，方便我们后期定位处理问题。当然，这套体系，市面上是有现成库已经做了的，来自 GitHub的这个代码仓库cheeaun/javascript-error-logging收集了前端异常监控相关的资源，从 GitHub 这个专题页面也能找到许多。上面的坑库里面也都会覆盖到。 Happy troubleshooting :) 相关资料 GlobalEventHandlers.onerror How to catch JavaScript Errors with window.onerror (even on Chrome and Firefox) Cryptic “Script Error.” reported in Javascript in Chrome and Firefox Capture and report JavaScript errors with window.onerror MS Edge API Catalog Script Error: JavaScript Forensics CORS settings attributes can I catch exception of Iframe in parent window of Iframe 后记 后续可以开垦的点： 本地模拟跨域 自己实现异常上报的库" />
<meta property="og:description" content="前端异常监控 如果说前端的异常监控有个救星的话，我想那就是 window.onerror 这个全局错误监听事件了。它给了我们统一处理前端全局错误的机会，使得错误上报有了一线生机。 window.onerror = function(messageOrEvent, source, lineno, colno, error) { ... } message: 错误信息，在 HTML 中的 onerror 属性中设置的回调可以传递事件 source: 出错文件的 url lineno: 出错位置的行数 colno: 出错时的列数 error: 出错时的 Error 对象。 实践中发现最后个参数 Error 对象中的值因浏览器的实现各有差异，比如 Chrome 中包含 message 和 stack，而 Safari 中则包含了前面四个参数的所有值。这在下面的示例代码的结果中可以看得出来。 牵出来溜一溜 注意 window.onerror 需要在有服务端的情况下才能正常工作，本地直接打开页面测试获取不到任何有用的错误信息。可以在命令行启动一个简单的服务端来进行测试。 因为 Mac 自带 Python，一般需要用到服务端的时候，我喜欢用 Python 自带的 SimpleHTTPServer： python -m SimpleHTTPServer or python3 -m http.server 以下代码我们对全局错误进行监听，然后将错误打印到页面： window.onerror = function (msg, source, line, col, error) { printError.apply(null, arguments); }; function printError(msg, source, line, col, error) { var detail = &#39;msg:&#39; + msg + &#39;\ncourse:&#39; + source + &#39;\nline:&#39; + line + &#39;\ncol:&#39; + col + &#39;\nerror:&#39; + JSON.stringify(error, Object.getOwnPropertyNames(error)); var div = document.createElement(&#39;pre&#39;); div.innerHTML = detail document.body.appendChild(div); } 然后在页面放上按钮以触发错误。这里测试了两种错误，一种运行时 JS 的抛错，另一种手动在代码中抛出的错误。 &lt;button onclick=&quot;excptionGenerate()&quot;&gt;点我执行出错代码&lt;/button&gt; &lt;button onclick=&quot;throwError()&quot;&gt;点我手动抛出异常&lt;/button&gt; Chrome 中异常的捕获与打印 Safari 中异常的捕获与打印 浏览器兼容性 要知道，最初版本的全局错误监听事件是这样的： window.onerror = function(messageOrEvent, source, lineno) { ... } 后来才增加了 colno 和 error。而后来加的这两个参数其实是非常有用的。 因为线上代码一般为压缩过的代码，所有内容都在一行，假如没有提供发生问题的列数，这样的错误日志要追查起来很不方便。 错误对象则直接提供了错误堆栈信息（通过 error.stack 访问），就像我们在浏览器控制台看到的一样，对于定位问题十分有帮助。 主流浏览器中， Chrome， Safari 已经完成了5个参数的支持。 Firefox 从 31 开始支持了完整的5个参数。 截止到目前， 微软的 Edge 浏览器还没有实现对新增两个参数的支持。其实现情况可以在这里查阅得到。 小贴士 * 过程中顺便发现了微软Edge这个API Catalog页面可以查到主流浏览器对名前端特性的实现情况，数据比 caniuse 全，譬如 window.onerror 在 caniuse 上则没有。 MS Edge 浏览器对 window.onerror 第五个参数的实现情况 从这里也可以看到，其他主流浏览器都已经有了完整的支持。 IE，（逃~） 垫片 对于不提供第5个参数的环境，我们是拿不到错误堆栈信息的。这种情况下对错误的追查帮助不大。 但是，手动在代码中捕获并抛出的错误，是带了堆栈信息的。这就有了补救的希望。我们可以将可能出错的地方，或者我们期望进行监控的地方，使用 try catch。 function tryCatchError() { try { a(); } catch (error) { printError(error) } } function printError(error) { var detail = &#39;error:&#39; + JSON.stringify(error, Object.getOwnPropertyNames(error)) + &#39;\n\n&#39;; } var div = document.createElement(&#39;code&#39;); div.innerHTML = detail document.body.appendChild(div); } 同时在页面中添加按钮来调用新的测试函数。 &lt;button onclick=&quot;tryCatchError()&quot;&gt;利用 try catch 捕获异常并打印错误堆栈&lt;/button&gt; try catch 中打印错误 我们看到，这种方式确实能得到详细的报错堆栈。 这一段其实无关紧要 因为最后两个参数是后面加的，有理由相信，在很老很老很老的 Chrome 版本中，也是不支持全部5个参数的。来自Ben Vinegar的这篇文章指出 Chrome 46 开始支持全部5个参数的。 为此我们不妨找一个老版本来验一下。我去 Chrome 的历史仓库中 下到了 Chromium 15 （Chrome 正式发布前的开发版）。 拥有历史厚重感的老版本 Chrome 打开它，仿佛打开了一个刚出土的文物，在 Retina 屏上，它的皮肤已经略出了清晰的锯齿，这是历史的厚重，这是岁月刻下的痕迹。 不过还好，它的功能依然完好，跑起来我们的示例代码来驾轻就熟。 老版本的 Chrome 果然是没有后两位参数的 全局无法捕获的情况 除了考虑上面的浏览器兼容性问题外，还有其他一些情况，也是无法通过这个全局的 onerror 获取到详细报错信息的。 跨域情况的错误捕获(CDN) window.onerror 有个限制，来自非同域的代码有报错，不会给出错误的详细信息，只能得到一个 Script error.。这是浏览器出于安全考虑，不向第三方泄露信息而做的一个措施。但往往线上代码大部分都部署在 CDN，所以这个限制的影响还挺常见。 不过还好，某些浏览器中可以通过配置来更改这一行为，让我们能正常拿到报错的详细信息。 还有一点，就是虽然在 window.onerror 中倒不到详细的报错信息，但在浏览器控制台是可以看到详细信息的。 如果是跨域脚本，则提示去控制台查看报错信息 window.onerror = function (msg, url, lineNo, columnNo, error) { var string = msg.toLowerCase(); var substring = &quot;script error&quot;; if (string.indexOf(substring) &gt; -1){ alert(&#39;Script Error: See Browser Console for Detail&#39;); } else { var message = [ &#39;Message: &#39; + msg, &#39;URL: &#39; + url, &#39;Line: &#39; + lineNo, &#39;Column: &#39; + columnNo, &#39;Error object: &#39; + JSON.stringify(error) ].join(&#39; - &#39;); alert(message); } return false; }; 控制台能看到对于线上的错误监控来说没多大用，还是得解决上报的问题。我们来看看如何设置跨域脚本让我们可以捕获时拿到错误堆栈信息。 下面看跨域脚本的配置。 CDN 上开启允许跨域 Access-Control-Allow-Origin:* 或者 Access-Control-Allow-Origin: domain of your site 然后 script 标签上设置跨域标识为匿名 &lt;script crossorigin=&quot;anonymous&quot; src=&quot;//url/for/your/cdn/scripts&quot;&gt;&lt;/script&gt; 唯一需要注意的是，一旦在前端设置了 crossorigin，要确保服务端相应设置了允许跨域的响应头，否则整个脚本文件会加载失败，影响页面正常功能。 目前来看，除了 Opera外，各主流浏览器都有支持此属性。 跨域脚本加载浏览器兼容性 iframe 中异常的捕获 iframe 中发生异常，外界的 onerror 是不会触发的。但如果 iframe 地址同域，那么我们就可以设置 iframe 的全局 onerror 进行监听。 document.getElementById(&quot;myiframe&quot;).contentWindow.onerror=function() { alert(&#39;error!!&#39;); return false; } 以上代码需要保证在 iframe 加载完成后进行。 非同域情况下，如果 ifame 内的内容不来自第三方，也就是你自己可以控制，那么可以通过与 iframe 内进行通信的方式，将异常信息抛出来。iframe 通信试有很多，譬如 postMessage。这里不展开了。 非同域且内容不受自己控制的情况下，除了在控制台查看错误详细信息，真的没其他办法可以捕获了。 代码压缩在错误捕获中的还原 线上代码一般是压缩过的，如何更友好地展示还原事件发生地，对于错误上报也是个挑战。因为在错误监听的回调里面提供了列数，所以对于压缩后的代码，定位起位置来也不是难事，再结合错误对象里的报错堆栈信息，能够很好地定位代码的位置及原因。 关于压缩后的代码，有 sourse map 可以映射到源码，如果我们在异常捕获时通过与 soruce map 文件结合起来，那么就有可能在还原错误时分析出其在未压缩源码中的位置。目前来看，已经有相关的服务实现了这一功能，sentry 的文档中有提到。 前面讨论了一下错误详细信息的获取，最终我们是想在客户端收集到这些信息，再加上 ua, 发生错误的时间，设备相关信息等上报到服务端。总之，能够获取到信息越全越好，方便我们后期定位处理问题。当然，这套体系，市面上是有现成库已经做了的，来自 GitHub的这个代码仓库cheeaun/javascript-error-logging收集了前端异常监控相关的资源，从 GitHub 这个专题页面也能找到许多。上面的坑库里面也都会覆盖到。 Happy troubleshooting :) 相关资料 GlobalEventHandlers.onerror How to catch JavaScript Errors with window.onerror (even on Chrome and Firefox) Cryptic “Script Error.” reported in Javascript in Chrome and Firefox Capture and report JavaScript errors with window.onerror MS Edge API Catalog Script Error: JavaScript Forensics CORS settings attributes can I catch exception of Iframe in parent window of Iframe 后记 后续可以开垦的点： 本地模拟跨域 自己实现异常上报的库" />
<link rel="canonical" href="http://localhost:4000/2017/12/02/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7.html" />
<meta property="og:url" content="http://localhost:4000/2017/12/02/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-12-02T15:12:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2017/12/02/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2017/12/02/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7.html"},"description":"前端异常监控 如果说前端的异常监控有个救星的话，我想那就是 window.onerror 这个全局错误监听事件了。它给了我们统一处理前端全局错误的机会，使得错误上报有了一线生机。 window.onerror = function(messageOrEvent, source, lineno, colno, error) { ... } message: 错误信息，在 HTML 中的 onerror 属性中设置的回调可以传递事件 source: 出错文件的 url lineno: 出错位置的行数 colno: 出错时的列数 error: 出错时的 Error 对象。 实践中发现最后个参数 Error 对象中的值因浏览器的实现各有差异，比如 Chrome 中包含 message 和 stack，而 Safari 中则包含了前面四个参数的所有值。这在下面的示例代码的结果中可以看得出来。 牵出来溜一溜 注意 window.onerror 需要在有服务端的情况下才能正常工作，本地直接打开页面测试获取不到任何有用的错误信息。可以在命令行启动一个简单的服务端来进行测试。 因为 Mac 自带 Python，一般需要用到服务端的时候，我喜欢用 Python 自带的 SimpleHTTPServer： python -m SimpleHTTPServer or python3 -m http.server 以下代码我们对全局错误进行监听，然后将错误打印到页面： window.onerror = function (msg, source, line, col, error) { printError.apply(null, arguments); }; function printError(msg, source, line, col, error) { var detail = &#39;msg:&#39; + msg + &#39;\\ncourse:&#39; + source + &#39;\\nline:&#39; + line + &#39;\\ncol:&#39; + col + &#39;\\nerror:&#39; + JSON.stringify(error, Object.getOwnPropertyNames(error)); var div = document.createElement(&#39;pre&#39;); div.innerHTML = detail document.body.appendChild(div); } 然后在页面放上按钮以触发错误。这里测试了两种错误，一种运行时 JS 的抛错，另一种手动在代码中抛出的错误。 &lt;button onclick=&quot;excptionGenerate()&quot;&gt;点我执行出错代码&lt;/button&gt; &lt;button onclick=&quot;throwError()&quot;&gt;点我手动抛出异常&lt;/button&gt; Chrome 中异常的捕获与打印 Safari 中异常的捕获与打印 浏览器兼容性 要知道，最初版本的全局错误监听事件是这样的： window.onerror = function(messageOrEvent, source, lineno) { ... } 后来才增加了 colno 和 error。而后来加的这两个参数其实是非常有用的。 因为线上代码一般为压缩过的代码，所有内容都在一行，假如没有提供发生问题的列数，这样的错误日志要追查起来很不方便。 错误对象则直接提供了错误堆栈信息（通过 error.stack 访问），就像我们在浏览器控制台看到的一样，对于定位问题十分有帮助。 主流浏览器中， Chrome， Safari 已经完成了5个参数的支持。 Firefox 从 31 开始支持了完整的5个参数。 截止到目前， 微软的 Edge 浏览器还没有实现对新增两个参数的支持。其实现情况可以在这里查阅得到。 小贴士 * 过程中顺便发现了微软Edge这个API Catalog页面可以查到主流浏览器对名前端特性的实现情况，数据比 caniuse 全，譬如 window.onerror 在 caniuse 上则没有。 MS Edge 浏览器对 window.onerror 第五个参数的实现情况 从这里也可以看到，其他主流浏览器都已经有了完整的支持。 IE，（逃~） 垫片 对于不提供第5个参数的环境，我们是拿不到错误堆栈信息的。这种情况下对错误的追查帮助不大。 但是，手动在代码中捕获并抛出的错误，是带了堆栈信息的。这就有了补救的希望。我们可以将可能出错的地方，或者我们期望进行监控的地方，使用 try catch。 function tryCatchError() { try { a(); } catch (error) { printError(error) } } function printError(error) { var detail = &#39;error:&#39; + JSON.stringify(error, Object.getOwnPropertyNames(error)) + &#39;\\n\\n&#39;; } var div = document.createElement(&#39;code&#39;); div.innerHTML = detail document.body.appendChild(div); } 同时在页面中添加按钮来调用新的测试函数。 &lt;button onclick=&quot;tryCatchError()&quot;&gt;利用 try catch 捕获异常并打印错误堆栈&lt;/button&gt; try catch 中打印错误 我们看到，这种方式确实能得到详细的报错堆栈。 这一段其实无关紧要 因为最后两个参数是后面加的，有理由相信，在很老很老很老的 Chrome 版本中，也是不支持全部5个参数的。来自Ben Vinegar的这篇文章指出 Chrome 46 开始支持全部5个参数的。 为此我们不妨找一个老版本来验一下。我去 Chrome 的历史仓库中 下到了 Chromium 15 （Chrome 正式发布前的开发版）。 拥有历史厚重感的老版本 Chrome 打开它，仿佛打开了一个刚出土的文物，在 Retina 屏上，它的皮肤已经略出了清晰的锯齿，这是历史的厚重，这是岁月刻下的痕迹。 不过还好，它的功能依然完好，跑起来我们的示例代码来驾轻就熟。 老版本的 Chrome 果然是没有后两位参数的 全局无法捕获的情况 除了考虑上面的浏览器兼容性问题外，还有其他一些情况，也是无法通过这个全局的 onerror 获取到详细报错信息的。 跨域情况的错误捕获(CDN) window.onerror 有个限制，来自非同域的代码有报错，不会给出错误的详细信息，只能得到一个 Script error.。这是浏览器出于安全考虑，不向第三方泄露信息而做的一个措施。但往往线上代码大部分都部署在 CDN，所以这个限制的影响还挺常见。 不过还好，某些浏览器中可以通过配置来更改这一行为，让我们能正常拿到报错的详细信息。 还有一点，就是虽然在 window.onerror 中倒不到详细的报错信息，但在浏览器控制台是可以看到详细信息的。 如果是跨域脚本，则提示去控制台查看报错信息 window.onerror = function (msg, url, lineNo, columnNo, error) { var string = msg.toLowerCase(); var substring = &quot;script error&quot;; if (string.indexOf(substring) &gt; -1){ alert(&#39;Script Error: See Browser Console for Detail&#39;); } else { var message = [ &#39;Message: &#39; + msg, &#39;URL: &#39; + url, &#39;Line: &#39; + lineNo, &#39;Column: &#39; + columnNo, &#39;Error object: &#39; + JSON.stringify(error) ].join(&#39; - &#39;); alert(message); } return false; }; 控制台能看到对于线上的错误监控来说没多大用，还是得解决上报的问题。我们来看看如何设置跨域脚本让我们可以捕获时拿到错误堆栈信息。 下面看跨域脚本的配置。 CDN 上开启允许跨域 Access-Control-Allow-Origin:* 或者 Access-Control-Allow-Origin: domain of your site 然后 script 标签上设置跨域标识为匿名 &lt;script crossorigin=&quot;anonymous&quot; src=&quot;//url/for/your/cdn/scripts&quot;&gt;&lt;/script&gt; 唯一需要注意的是，一旦在前端设置了 crossorigin，要确保服务端相应设置了允许跨域的响应头，否则整个脚本文件会加载失败，影响页面正常功能。 目前来看，除了 Opera外，各主流浏览器都有支持此属性。 跨域脚本加载浏览器兼容性 iframe 中异常的捕获 iframe 中发生异常，外界的 onerror 是不会触发的。但如果 iframe 地址同域，那么我们就可以设置 iframe 的全局 onerror 进行监听。 document.getElementById(&quot;myiframe&quot;).contentWindow.onerror=function() { alert(&#39;error!!&#39;); return false; } 以上代码需要保证在 iframe 加载完成后进行。 非同域情况下，如果 ifame 内的内容不来自第三方，也就是你自己可以控制，那么可以通过与 iframe 内进行通信的方式，将异常信息抛出来。iframe 通信试有很多，譬如 postMessage。这里不展开了。 非同域且内容不受自己控制的情况下，除了在控制台查看错误详细信息，真的没其他办法可以捕获了。 代码压缩在错误捕获中的还原 线上代码一般是压缩过的，如何更友好地展示还原事件发生地，对于错误上报也是个挑战。因为在错误监听的回调里面提供了列数，所以对于压缩后的代码，定位起位置来也不是难事，再结合错误对象里的报错堆栈信息，能够很好地定位代码的位置及原因。 关于压缩后的代码，有 sourse map 可以映射到源码，如果我们在异常捕获时通过与 soruce map 文件结合起来，那么就有可能在还原错误时分析出其在未压缩源码中的位置。目前来看，已经有相关的服务实现了这一功能，sentry 的文档中有提到。 前面讨论了一下错误详细信息的获取，最终我们是想在客户端收集到这些信息，再加上 ua, 发生错误的时间，设备相关信息等上报到服务端。总之，能够获取到信息越全越好，方便我们后期定位处理问题。当然，这套体系，市面上是有现成库已经做了的，来自 GitHub的这个代码仓库cheeaun/javascript-error-logging收集了前端异常监控相关的资源，从 GitHub 这个专题页面也能找到许多。上面的坑库里面也都会覆盖到。 Happy troubleshooting :) 相关资料 GlobalEventHandlers.onerror How to catch JavaScript Errors with window.onerror (even on Chrome and Firefox) Cryptic “Script Error.” reported in Javascript in Chrome and Firefox Capture and report JavaScript errors with window.onerror MS Edge API Catalog Script Error: JavaScript Forensics CORS settings attributes can I catch exception of Iframe in parent window of Iframe 后记 后续可以开垦的点： 本地模拟跨域 自己实现异常上报的库","@type":"BlogPosting","headline":"前端异常监控","dateModified":"2017-12-02T15:12:00+08:00","datePublished":"2017-12-02T15:12:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">前端异常监控</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-12-02T15:12:00+08:00" itemprop="datePublished">Dec 2, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="前端异常监控">前端异常监控</h2>

<p>如果说前端的异常监控有个救星的话，我想那就是 <code class="language-plaintext highlighter-rouge">window.onerror</code> 这个全局错误监听事件了。它给了我们统一处理前端全局错误的机会，使得错误上报有了一线生机。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">messageOrEvent</span><span class="p">,</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">lineno</span><span class="p">,</span> <span class="nx">colno</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>message: 错误信息，在 HTML 中的 <code class="language-plaintext highlighter-rouge">onerror</code> 属性中设置的回调可以传递事件</li>
  <li>source: 出错文件的 url</li>
  <li>lineno: 出错位置的行数</li>
  <li>colno: 出错时的列数</li>
  <li>error: 出错时的 Error 对象。</li>
</ul>

<p>实践中发现最后个参数 Error 对象中的值因浏览器的实现各有差异，比如 Chrome 中包含 <code class="language-plaintext highlighter-rouge">message</code> 和 <code class="language-plaintext highlighter-rouge">stack</code>，而 Safari 中则包含了前面四个参数的所有值。这在下面的示例代码的结果中可以看得出来。</p>

<h3 id="牵出来溜一溜">牵出来溜一溜</h3>

<p><em>注意</em>
<code class="language-plaintext highlighter-rouge">window.onerror</code> 需要在有服务端的情况下才能正常工作，本地直接打开页面测试获取不到任何有用的错误信息。可以在命令行启动一个简单的服务端来进行测试。
因为 Mac 自带 Python，一般需要用到服务端的时候，我喜欢用 Python 自带的 <code class="language-plaintext highlighter-rouge">SimpleHTTPServer</code>：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-m</span> SimpleHTTPServer
or
python3 <span class="nt">-m</span> http.server
</code></pre></div></div>

<p>以下代码我们对全局错误进行监听，然后将错误打印到页面：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">col</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">printError</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">printError</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">line</span><span class="p">,</span> <span class="nx">col</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">detail</span> <span class="o">=</span>
        <span class="dl">'</span><span class="s1">msg:</span><span class="dl">'</span> <span class="o">+</span>
        <span class="nx">msg</span> <span class="o">+</span>
        <span class="dl">'</span><span class="se">\n</span><span class="s1">course:</span><span class="dl">'</span> <span class="o">+</span>
        <span class="nx">source</span> <span class="o">+</span>
        <span class="dl">'</span><span class="se">\n</span><span class="s1">line:</span><span class="dl">'</span> <span class="o">+</span>
        <span class="nx">line</span> <span class="o">+</span>
        <span class="dl">'</span><span class="se">\n</span><span class="s1">col:</span><span class="dl">'</span> <span class="o">+</span>
        <span class="nx">col</span> <span class="o">+</span>
        <span class="dl">'</span><span class="se">\n</span><span class="s1">error:</span><span class="dl">'</span> <span class="o">+</span>
        <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">error</span><span class="p">));</span>
    <span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">pre</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">detail</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">div</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然后在页面放上按钮以触发错误。这里测试了两种错误，一种运行时 JS 的抛错，另一种手动在代码中抛出的错误。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">"excptionGenerate()"</span><span class="nt">&gt;</span>点我执行出错代码<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">"throwError()"</span><span class="nt">&gt;</span>点我手动抛出异常<span class="nt">&lt;/button&gt;</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/chrome-error-print.png" alt="Chrome 中异常的捕获与打印" /></p>

<p><em>Chrome 中异常的捕获与打印</em></p>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/safari-error-print.png" alt="Safari 中异常的捕获与打印" /></p>

<p><em>Safari 中异常的捕获与打印</em></p>

<h3 id="浏览器兼容性">浏览器兼容性</h3>

<p>要知道，最初版本的全局错误监听事件是这样的：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">messageOrEvent</span><span class="p">,</span> <span class="nx">source</span><span class="p">,</span> <span class="nx">lineno</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>后来才增加了 <code class="language-plaintext highlighter-rouge">colno</code> 和 <code class="language-plaintext highlighter-rouge">error</code>。而后来加的这两个参数其实是非常有用的。</p>

<p>因为线上代码一般为压缩过的代码，所有内容都在一行，假如没有提供发生问题的列数，这样的错误日志要追查起来很不方便。
错误对象则直接提供了错误堆栈信息（通过 <code class="language-plaintext highlighter-rouge">error.stack</code> 访问），就像我们在浏览器控制台看到的一样，对于定位问题十分有帮助。</p>

<p>主流浏览器中， Chrome， Safari 已经完成了5个参数的支持。</p>

<p>Firefox 从 31 开始支持了完整的5个参数。</p>

<p>截止到目前， 微软的 Edge 浏览器还没有实现对新增两个参数的支持。其实现情况可以在<a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/runtimeerrorreportingerrorevent/?q=onerror">这里</a>查阅得到。</p>

<ul>
  <li>小贴士 *
    <blockquote>
      <p>过程中顺便发现了微软Edge<a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/catalog/?page=1&amp;q=queryselector">这个API Catalog页面</a>可以查到主流浏览器对名前端特性的实现情况，数据比 caniuse 全，譬如 <code class="language-plaintext highlighter-rouge">window.onerror</code> 在 caniuse 上则没有。</p>
    </blockquote>
  </li>
</ul>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/ms-edge-onerror-compatability.png" alt="MS Edge 浏览器对 `window.onerror` 第五个参数的实现情况" /></p>

<p><em>MS Edge 浏览器对 <code class="language-plaintext highlighter-rouge">window.onerror</code> 第五个参数的实现情况</em></p>

<p>从这里也可以看到，其他主流浏览器都已经有了完整的支持。</p>

<p>IE，（逃~）</p>

<h3 id="垫片">垫片</h3>

<p>对于不提供第5个参数的环境，我们是拿不到错误堆栈信息的。这种情况下对错误的追查帮助不大。</p>

<p>但是，手动在代码中捕获并抛出的错误，是带了堆栈信息的。这就有了补救的希望。我们可以将可能出错的地方，或者我们期望进行监控的地方，使用 try catch。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">tryCatchError</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="nx">a</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">printError</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">printError</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">detail</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">error:</span><span class="dl">'</span> <span class="o">+</span>
            <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">error</span><span class="p">))</span> <span class="o">+</span>
            <span class="dl">'</span><span class="se">\n\n</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">code</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">detail</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">div</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>同时在页面中添加按钮来调用新的测试函数。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">"tryCatchError()"</span><span class="nt">&gt;</span>利用 try catch 捕获异常并打印错误堆栈<span class="nt">&lt;/button&gt;</span>
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/try-catch-print.png" alt="try catch 中打印错误" /></p>

<p><em>try catch 中打印错误</em></p>

<p>我们看到，这种方式确实能得到详细的报错堆栈。</p>

<h4 id="这一段其实无关紧要">这一段其实无关紧要</h4>

<p>因为最后两个参数是后面加的，有理由相信，在很老很老很老的 Chrome 版本中，也是不支持全部5个参数的。来自Ben Vinegar的<a href="https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html">这篇文章</a>指出 Chrome 46 开始支持全部5个参数的。</p>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/chrome-onerr-compatability.png" alt="" /></p>

<p>为此我们不妨找一个老版本来验一下。我去 <a href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html">Chrome 的历史仓库中</a> 下到了 <a href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html?prefix=Mac/100293/">Chromium 15</a> （Chrome 正式发布前的开发版）。</p>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/chromium-15.png" alt="拥有历史厚重感的老版本 Chrome" /></p>

<p><em>拥有历史厚重感的老版本 Chrome</em></p>

<p>打开它，仿佛打开了一个刚出土的文物，在 Retina 屏上，它的皮肤已经略出了清晰的锯齿，这是历史的厚重，这是岁月刻下的痕迹。</p>

<p>不过还好，它的功能依然完好，跑起来我们的示例代码来驾轻就熟。</p>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/chrome-15-without-last-2-arguments.png" alt="老版本的 Chrome 果然是没有后两位参数的" /></p>

<p><em>老版本的 Chrome 果然是没有后两位参数的</em></p>

<h3 id="全局无法捕获的情况">全局无法捕获的情况</h3>

<p>除了考虑上面的浏览器兼容性问题外，还有其他一些情况，也是无法通过这个全局的 onerror 获取到详细报错信息的。</p>

<h4 id="跨域情况的错误捕获cdn">跨域情况的错误捕获(CDN)</h4>

<p><code class="language-plaintext highlighter-rouge">window.onerror</code> 有个限制，来自非同域的代码有报错，不会给出错误的详细信息，只能得到一个 <code class="language-plaintext highlighter-rouge">Script error.</code>。这是浏览器出于安全考虑，不向第三方泄露信息而做的一个措施。但往往线上代码大部分都部署在 CDN，所以这个限制的影响还挺常见。</p>

<p>不过还好，某些浏览器中可以通过配置来更改这一行为，让我们能正常拿到报错的详细信息。</p>

<p>还有一点，就是虽然在 <code class="language-plaintext highlighter-rouge">window.onerror</code> 中倒不到详细的报错信息，但在浏览器控制台是可以看到详细信息的。</p>

<p><em>如果是跨域脚本，则提示去控制台查看报错信息</em></p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">lineNo</span><span class="p">,</span> <span class="nx">columnNo</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">string</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">substring</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">script error</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">string</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">substring</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
        <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">Script Error: See Browser Console for Detail</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="p">[</span>
            <span class="dl">'</span><span class="s1">Message: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">msg</span><span class="p">,</span>
            <span class="dl">'</span><span class="s1">URL: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">url</span><span class="p">,</span>
            <span class="dl">'</span><span class="s1">Line: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">lineNo</span><span class="p">,</span>
            <span class="dl">'</span><span class="s1">Column: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">columnNo</span><span class="p">,</span>
            <span class="dl">'</span><span class="s1">Error object: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
        <span class="p">].</span><span class="nx">join</span><span class="p">(</span><span class="dl">'</span><span class="s1"> - </span><span class="dl">'</span><span class="p">);</span>

        <span class="nx">alert</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>控制台能看到对于线上的错误监控来说没多大用，还是得解决上报的问题。我们来看看如何设置跨域脚本让我们可以捕获时拿到错误堆栈信息。</p>

<p>下面看跨域脚本的配置。</p>

<ul>
  <li>CDN 上开启允许跨域
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Access-Control-Allow-Origin:*
或者
Access-Control-Allow-Origin: domain of your site
</code></pre></div>    </div>
  </li>
  <li>然后 script 标签上设置跨域标识为匿名</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">crossorigin=</span><span class="s">"anonymous"</span> <span class="na">src=</span><span class="s">"//url/for/your/cdn/scripts"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div>

<p>唯一需要注意的是，一旦在前端设置了 <code class="language-plaintext highlighter-rouge">crossorigin</code>，要确保服务端相应设置了允许跨域的响应头，否则整个脚本文件会加载失败，影响页面正常功能。</p>

<p>目前来看，除了 Opera外，各主流浏览器都有支持此属性。</p>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-exception-report/assets/cors-loading-browser-compatability.png" alt="跨域脚本加载浏览器兼容性" /></p>

<p><em>跨域脚本加载浏览器兼容性</em></p>

<h4 id="iframe-中异常的捕获">iframe 中异常的捕获</h4>

<p>iframe 中发生异常，外界的 <code class="language-plaintext highlighter-rouge">onerror</code> 是不会触发的。但如果 iframe 地址同域，那么我们就可以设置 iframe 的全局 <code class="language-plaintext highlighter-rouge">onerror</code> 进行监听。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">"</span><span class="s2">myiframe</span><span class="dl">"</span><span class="p">).</span><span class="nx">contentWindow</span><span class="p">.</span><span class="nx">onerror</span><span class="o">=</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">error!!</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>以上代码需要保证在 iframe 加载完成后进行。</p>

<p>非同域情况下，如果 ifame 内的内容不来自第三方，也就是你自己可以控制，那么可以通过与 iframe 内进行通信的方式，将异常信息抛出来。iframe 通信试有很多，譬如 <code class="language-plaintext highlighter-rouge">postMessage</code>。这里不展开了。</p>

<p>非同域且内容不受自己控制的情况下，除了在控制台查看错误详细信息，真的没其他办法可以捕获了。</p>

<h4 id="代码压缩在错误捕获中的还原">代码压缩在错误捕获中的还原</h4>

<p>线上代码一般是压缩过的，如何更友好地展示还原事件发生地，对于错误上报也是个挑战。因为在错误监听的回调里面提供了列数，所以对于压缩后的代码，定位起位置来也不是难事，再结合错误对象里的报错堆栈信息，能够很好地定位代码的位置及原因。</p>

<p>关于压缩后的代码，有 sourse map 可以映射到源码，如果我们在异常捕获时通过与 soruce map 文件结合起来，那么就有可能在还原错误时分析出其在未压缩源码中的位置。目前来看，已经有相关的服务实现了这一功能，<a href="https://docs.sentry.io/clients/javascript/sourcemaps/">sentry 的文档</a>中有提到。</p>

<p>前面讨论了一下错误详细信息的获取，最终我们是想在客户端收集到这些信息，再加上 ua, 发生错误的时间，设备相关信息等上报到服务端。总之，能够获取到信息越全越好，方便我们后期定位处理问题。当然，这套体系，市面上是有现成库已经做了的，来自 GitHub的这个代码仓库<a href="https://github.com/cheeaun/javascript-error-logging">cheeaun/javascript-error-logging</a>收集了前端异常监控相关的资源，从 <a href="https://github.com/topics/error-monitoring">GitHub 这个专题页面</a>也能找到许多。上面的坑库里面也都会覆盖到。</p>

<p>Happy troubleshooting :)</p>

<h3 id="相关资料">相关资料</h3>

<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror">GlobalEventHandlers.onerror</a></li>
  <li><a href="https://danlimerick.wordpress.com/2014/01/18/how-to-catch-javascript-errors-with-window-onerror-even-on-chrome-and-firefox/">How to catch JavaScript Errors with window.onerror (even on Chrome and Firefox)</a></li>
  <li><a href="https://stackoverflow.com/questions/5913978/cryptic-script-error-reported-in-javascript-in-chrome-and-firefox">Cryptic “Script Error.” reported in Javascript in Chrome and Firefox</a></li>
  <li><a href="https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html">Capture and report JavaScript errors with window.onerror</a></li>
  <li><a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/catalog/?page=1&amp;q=queryselector">MS Edge API Catalog</a></li>
  <li><a href="https://trackjs.com/blog/script-error-javascript-forensics/">Script Error: JavaScript Forensics</a></li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes">CORS settings attributes</a></li>
  <li><a href="https://stackoverflow.com/questions/6327128/can-i-catch-exception-of-iframe-in-parent-window-of-iframe">can I catch exception of Iframe in parent window of Iframe</a></li>
</ul>

<p><strong>后记</strong></p>

<p>后续可以开垦的点：</p>

<ul>
  <li>本地模拟跨域</li>
  <li>自己实现异常上报的库</li>
</ul>


  </div><a class="u-url" href="/2017/12/02/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
