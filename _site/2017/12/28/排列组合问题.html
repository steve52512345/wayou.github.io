<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>排列组合问题 | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="排列组合问题" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="排列组合问题 排列和组合是两个问题，因为有相似性，所以通常放一起。 所谓排列，是跟顺序有关的，比如从 1,2,3 中取三个数出来，序列 1,2,3 与 1,3,2 是两个不同的序列。这便是排列。 而组合则与顺序无关，比如从 1,2,3 这一序列中取两个数出来， 1,2 与 2,1 只能算一种取法，只关心元素不关心顺序。 先来看排列。 排列/Permutation 考察 LeetCode 上面这个排列题目： Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 转述一下：对于给定非重复序列[1,2,3]，找出其所有可能的排列。相当于从 n 个元素中取出 n 个，看有多少种排列。 这样说来，就和中学数学的公式可以联系起来了。 排列组合公式 通过上面的公式，我们可以算出 A3,3 = 3!/(3-3)! = 3!/1 = 3x2x1 = 6。 即一共有 6 种可能的排列，以此来验证我们后面实现的算法得到的结果是否准确。 接下来的任务是实现一个方法，找出所有排列。 /** * @param {number[]} nums * @return {number[][]} */ var permute = function (nums) { // 实现 }; 问题分析 假设让人脑来解决这个问题，我们屡一下思路： 取出第一个元素 1, 剩下的 [2,3] 中有两种取法 先取 2 再取 3， 得到 [1,2,3] 先取 3 再取 2， 得到 [1,3,2] 1 打头的取完了，考虑先取 2，从剩下的 [1,3] 中，也有两种取法 于是分别得到 [2,1,3]，[2,3,1] 最后先取 3，也能得到两种排列 [3,1,2]，[3,2,1] 最后得到完整的结果为 [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 将上面的步骤抽象到类似伪代码的表示方式，可以方便我们将问题细化，最后得到一个递归的实现思路。 假设我们已经写好这么一个方法 permute 了，它的功能是对于输入数组，输出其所有排列。 于是上面的思路可以描述成： permute([1,2,3]) = 1 + permute([2,3]) + 2 + permute([1,3]) + 3 + permute([1,2]) permute([2,3]) = 2 + permute([3]) + 3 + permute([2]) permute([3]) = 3 从整体数组中取出一个，剩下的数组中进行看成新的输入。如此重复，直到最后的输入变成一个元素，一个元素的排列就是其本身。第一步得到的结果都往下传递，到达到后一个元素时，我们便会得到一条完整的结果，最后所有的结果汇总便是总的结果。 所以，我们应该有一个变量来存放最后的总结果，然后对于每次递归的终点我们有对应的变量存放单个结果。 var permute = function (nums) { var result = []; function process(input/*上一次处理后剩下的元素*/, prevResult/*上一次处理后的结果*/) { var input = input.slice(); if (input.length &gt; 1) { for (var i = 0; i &lt; input.length; i++) { //遍历输入，将其中的每个元素都取出压入一次结果中，对于剩下的元素递归调用进行同样的操作 //... process(nextInput, currentResult); } } else { // 输入为1个元素了，表示我们寻找到了终点 result.push(/*这里我们会得到一条结果，压入总结果中*/) } } process(nums); return result; }; 每次操作，当输入长度不为 1 时，说明没有递归到最终，于是我们将输入中每个元素取出来放入一个临时结果中，将这个临时结果传递给下一次操作。每次操作都会往这个结果里增加一个元素。直到进行到输入还剩下一个元素的时候，我们便会得到一个完整的结果。将所有的结果合并，便得到了全部结果。 /** * @param {number[]} nums * @return {number[][]} */ var permute = function (nums) { var result = []; /** * @param {number[]} input 输入数组 * @param {number[]} prevResult 上一次得到的结果 * @return {number[]} */ function process(input, prevResult) { var input = input.slice(); if (input.length &gt; 1) { for (var i = 0; i &lt; input.length; i++) { var currentResult = prevResult || []; currentResult = currentResult.concat(input[i]); var nextInput = input.slice(); nextInput.splice(i, 1); process(nextInput, currentResult); } } else { var currentResult = prevResult || []; var row = currentResult.concat(input); result.push(row); } } process(nums); return result; }; console.log(permute([1, 2, 3])) 组合/Combination 同样地，来看这个来自 LeetCode 关于组合的题目： Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. For example, If n = 4 and k = 2, a solution is: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 即，对于给定正整数 n，从序列 1~n 中取出 k 个数，找出所有取法。 比如从 [1,2,3,4] 中取 2 个数，通过组合公式我们可以得出可能的取法一共有 C4,2 = 4!/2!(4-2)! = 4!/2!2! = (4x3x2x1)/(2x1)(2x1) = 6 6种取法。 下面我们来实现 combine 函数，找出所有的组合。 思路和排列的类似，也是先将问题进行拆分，直到不能再拆。 假设从 [1,2,3,4] 中取 2 个表示为 combine([1,2,3,4],2)。那么取出 1 后，我们接下来需要在剩下的 [2,3,4] 中 1 个元素，最后达到要求的 2 个元素。而从剩下的 [2,3,4] 取 1 个元素可类似地表示为 combine([2,3,4],1)。到这里又看到了递归的影子。当问题拆分到从数组中取一个元素时，就拆不动了，因为从 n 个元素中取 1 个元素，有 n 种取法，无需再拆分。 combine([1,2,3,4],2) = 1 + combine([2,3,4],1) + 2 + combine([3,4],1) + 3 + combine([4],1) combine([2,3,4],1) = 2 + 3 + 4 稍加调试将上面的思路转成代码我们得到： /** * @param {number} n * @param {number} k * @return {number[][]} */ var combine = function (n, k) { var result = []; /** * @param {*} i 序号 * @param {*} n 总数 * @param {*} k 要取的个数 * @param {*} a 上一次的结果 */ function process(i, n, k, a) { i = i || 1; a = a || []; if (k &gt; 1) { for (var i = i; i &lt; n + 1; i++) { var row = []; row = row.concat(a) row.push(i); process(i + 1, n, k - 1, row); } } else { for (var i = i; i &lt; n + 1; i++) { var row = a.slice(); row.push(i) result.push(row) } } } process(1, n, k); return result; }; console.log(combine(4, 2)) 相关资源 LeetCode Permutations LeetCode Combinations Permutation &amp; Combination - JSFiddle Implement All Permutations of a Set in JavaScript" />
<meta property="og:description" content="排列组合问题 排列和组合是两个问题，因为有相似性，所以通常放一起。 所谓排列，是跟顺序有关的，比如从 1,2,3 中取三个数出来，序列 1,2,3 与 1,3,2 是两个不同的序列。这便是排列。 而组合则与顺序无关，比如从 1,2,3 这一序列中取两个数出来， 1,2 与 2,1 只能算一种取法，只关心元素不关心顺序。 先来看排列。 排列/Permutation 考察 LeetCode 上面这个排列题目： Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 转述一下：对于给定非重复序列[1,2,3]，找出其所有可能的排列。相当于从 n 个元素中取出 n 个，看有多少种排列。 这样说来，就和中学数学的公式可以联系起来了。 排列组合公式 通过上面的公式，我们可以算出 A3,3 = 3!/(3-3)! = 3!/1 = 3x2x1 = 6。 即一共有 6 种可能的排列，以此来验证我们后面实现的算法得到的结果是否准确。 接下来的任务是实现一个方法，找出所有排列。 /** * @param {number[]} nums * @return {number[][]} */ var permute = function (nums) { // 实现 }; 问题分析 假设让人脑来解决这个问题，我们屡一下思路： 取出第一个元素 1, 剩下的 [2,3] 中有两种取法 先取 2 再取 3， 得到 [1,2,3] 先取 3 再取 2， 得到 [1,3,2] 1 打头的取完了，考虑先取 2，从剩下的 [1,3] 中，也有两种取法 于是分别得到 [2,1,3]，[2,3,1] 最后先取 3，也能得到两种排列 [3,1,2]，[3,2,1] 最后得到完整的结果为 [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 将上面的步骤抽象到类似伪代码的表示方式，可以方便我们将问题细化，最后得到一个递归的实现思路。 假设我们已经写好这么一个方法 permute 了，它的功能是对于输入数组，输出其所有排列。 于是上面的思路可以描述成： permute([1,2,3]) = 1 + permute([2,3]) + 2 + permute([1,3]) + 3 + permute([1,2]) permute([2,3]) = 2 + permute([3]) + 3 + permute([2]) permute([3]) = 3 从整体数组中取出一个，剩下的数组中进行看成新的输入。如此重复，直到最后的输入变成一个元素，一个元素的排列就是其本身。第一步得到的结果都往下传递，到达到后一个元素时，我们便会得到一条完整的结果，最后所有的结果汇总便是总的结果。 所以，我们应该有一个变量来存放最后的总结果，然后对于每次递归的终点我们有对应的变量存放单个结果。 var permute = function (nums) { var result = []; function process(input/*上一次处理后剩下的元素*/, prevResult/*上一次处理后的结果*/) { var input = input.slice(); if (input.length &gt; 1) { for (var i = 0; i &lt; input.length; i++) { //遍历输入，将其中的每个元素都取出压入一次结果中，对于剩下的元素递归调用进行同样的操作 //... process(nextInput, currentResult); } } else { // 输入为1个元素了，表示我们寻找到了终点 result.push(/*这里我们会得到一条结果，压入总结果中*/) } } process(nums); return result; }; 每次操作，当输入长度不为 1 时，说明没有递归到最终，于是我们将输入中每个元素取出来放入一个临时结果中，将这个临时结果传递给下一次操作。每次操作都会往这个结果里增加一个元素。直到进行到输入还剩下一个元素的时候，我们便会得到一个完整的结果。将所有的结果合并，便得到了全部结果。 /** * @param {number[]} nums * @return {number[][]} */ var permute = function (nums) { var result = []; /** * @param {number[]} input 输入数组 * @param {number[]} prevResult 上一次得到的结果 * @return {number[]} */ function process(input, prevResult) { var input = input.slice(); if (input.length &gt; 1) { for (var i = 0; i &lt; input.length; i++) { var currentResult = prevResult || []; currentResult = currentResult.concat(input[i]); var nextInput = input.slice(); nextInput.splice(i, 1); process(nextInput, currentResult); } } else { var currentResult = prevResult || []; var row = currentResult.concat(input); result.push(row); } } process(nums); return result; }; console.log(permute([1, 2, 3])) 组合/Combination 同样地，来看这个来自 LeetCode 关于组合的题目： Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. For example, If n = 4 and k = 2, a solution is: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 即，对于给定正整数 n，从序列 1~n 中取出 k 个数，找出所有取法。 比如从 [1,2,3,4] 中取 2 个数，通过组合公式我们可以得出可能的取法一共有 C4,2 = 4!/2!(4-2)! = 4!/2!2! = (4x3x2x1)/(2x1)(2x1) = 6 6种取法。 下面我们来实现 combine 函数，找出所有的组合。 思路和排列的类似，也是先将问题进行拆分，直到不能再拆。 假设从 [1,2,3,4] 中取 2 个表示为 combine([1,2,3,4],2)。那么取出 1 后，我们接下来需要在剩下的 [2,3,4] 中 1 个元素，最后达到要求的 2 个元素。而从剩下的 [2,3,4] 取 1 个元素可类似地表示为 combine([2,3,4],1)。到这里又看到了递归的影子。当问题拆分到从数组中取一个元素时，就拆不动了，因为从 n 个元素中取 1 个元素，有 n 种取法，无需再拆分。 combine([1,2,3,4],2) = 1 + combine([2,3,4],1) + 2 + combine([3,4],1) + 3 + combine([4],1) combine([2,3,4],1) = 2 + 3 + 4 稍加调试将上面的思路转成代码我们得到： /** * @param {number} n * @param {number} k * @return {number[][]} */ var combine = function (n, k) { var result = []; /** * @param {*} i 序号 * @param {*} n 总数 * @param {*} k 要取的个数 * @param {*} a 上一次的结果 */ function process(i, n, k, a) { i = i || 1; a = a || []; if (k &gt; 1) { for (var i = i; i &lt; n + 1; i++) { var row = []; row = row.concat(a) row.push(i); process(i + 1, n, k - 1, row); } } else { for (var i = i; i &lt; n + 1; i++) { var row = a.slice(); row.push(i) result.push(row) } } } process(1, n, k); return result; }; console.log(combine(4, 2)) 相关资源 LeetCode Permutations LeetCode Combinations Permutation &amp; Combination - JSFiddle Implement All Permutations of a Set in JavaScript" />
<link rel="canonical" href="http://localhost:4000/2017/12/28/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98.html" />
<meta property="og:url" content="http://localhost:4000/2017/12/28/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-12-28T21:12:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2017/12/28/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2017/12/28/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98.html"},"description":"排列组合问题 排列和组合是两个问题，因为有相似性，所以通常放一起。 所谓排列，是跟顺序有关的，比如从 1,2,3 中取三个数出来，序列 1,2,3 与 1,3,2 是两个不同的序列。这便是排列。 而组合则与顺序无关，比如从 1,2,3 这一序列中取两个数出来， 1,2 与 2,1 只能算一种取法，只关心元素不关心顺序。 先来看排列。 排列/Permutation 考察 LeetCode 上面这个排列题目： Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 转述一下：对于给定非重复序列[1,2,3]，找出其所有可能的排列。相当于从 n 个元素中取出 n 个，看有多少种排列。 这样说来，就和中学数学的公式可以联系起来了。 排列组合公式 通过上面的公式，我们可以算出 A3,3 = 3!/(3-3)! = 3!/1 = 3x2x1 = 6。 即一共有 6 种可能的排列，以此来验证我们后面实现的算法得到的结果是否准确。 接下来的任务是实现一个方法，找出所有排列。 /** * @param {number[]} nums * @return {number[][]} */ var permute = function (nums) { // 实现 }; 问题分析 假设让人脑来解决这个问题，我们屡一下思路： 取出第一个元素 1, 剩下的 [2,3] 中有两种取法 先取 2 再取 3， 得到 [1,2,3] 先取 3 再取 2， 得到 [1,3,2] 1 打头的取完了，考虑先取 2，从剩下的 [1,3] 中，也有两种取法 于是分别得到 [2,1,3]，[2,3,1] 最后先取 3，也能得到两种排列 [3,1,2]，[3,2,1] 最后得到完整的结果为 [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 将上面的步骤抽象到类似伪代码的表示方式，可以方便我们将问题细化，最后得到一个递归的实现思路。 假设我们已经写好这么一个方法 permute 了，它的功能是对于输入数组，输出其所有排列。 于是上面的思路可以描述成： permute([1,2,3]) = 1 + permute([2,3]) + 2 + permute([1,3]) + 3 + permute([1,2]) permute([2,3]) = 2 + permute([3]) + 3 + permute([2]) permute([3]) = 3 从整体数组中取出一个，剩下的数组中进行看成新的输入。如此重复，直到最后的输入变成一个元素，一个元素的排列就是其本身。第一步得到的结果都往下传递，到达到后一个元素时，我们便会得到一条完整的结果，最后所有的结果汇总便是总的结果。 所以，我们应该有一个变量来存放最后的总结果，然后对于每次递归的终点我们有对应的变量存放单个结果。 var permute = function (nums) { var result = []; function process(input/*上一次处理后剩下的元素*/, prevResult/*上一次处理后的结果*/) { var input = input.slice(); if (input.length &gt; 1) { for (var i = 0; i &lt; input.length; i++) { //遍历输入，将其中的每个元素都取出压入一次结果中，对于剩下的元素递归调用进行同样的操作 //... process(nextInput, currentResult); } } else { // 输入为1个元素了，表示我们寻找到了终点 result.push(/*这里我们会得到一条结果，压入总结果中*/) } } process(nums); return result; }; 每次操作，当输入长度不为 1 时，说明没有递归到最终，于是我们将输入中每个元素取出来放入一个临时结果中，将这个临时结果传递给下一次操作。每次操作都会往这个结果里增加一个元素。直到进行到输入还剩下一个元素的时候，我们便会得到一个完整的结果。将所有的结果合并，便得到了全部结果。 /** * @param {number[]} nums * @return {number[][]} */ var permute = function (nums) { var result = []; /** * @param {number[]} input 输入数组 * @param {number[]} prevResult 上一次得到的结果 * @return {number[]} */ function process(input, prevResult) { var input = input.slice(); if (input.length &gt; 1) { for (var i = 0; i &lt; input.length; i++) { var currentResult = prevResult || []; currentResult = currentResult.concat(input[i]); var nextInput = input.slice(); nextInput.splice(i, 1); process(nextInput, currentResult); } } else { var currentResult = prevResult || []; var row = currentResult.concat(input); result.push(row); } } process(nums); return result; }; console.log(permute([1, 2, 3])) 组合/Combination 同样地，来看这个来自 LeetCode 关于组合的题目： Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. For example, If n = 4 and k = 2, a solution is: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 即，对于给定正整数 n，从序列 1~n 中取出 k 个数，找出所有取法。 比如从 [1,2,3,4] 中取 2 个数，通过组合公式我们可以得出可能的取法一共有 C4,2 = 4!/2!(4-2)! = 4!/2!2! = (4x3x2x1)/(2x1)(2x1) = 6 6种取法。 下面我们来实现 combine 函数，找出所有的组合。 思路和排列的类似，也是先将问题进行拆分，直到不能再拆。 假设从 [1,2,3,4] 中取 2 个表示为 combine([1,2,3,4],2)。那么取出 1 后，我们接下来需要在剩下的 [2,3,4] 中 1 个元素，最后达到要求的 2 个元素。而从剩下的 [2,3,4] 取 1 个元素可类似地表示为 combine([2,3,4],1)。到这里又看到了递归的影子。当问题拆分到从数组中取一个元素时，就拆不动了，因为从 n 个元素中取 1 个元素，有 n 种取法，无需再拆分。 combine([1,2,3,4],2) = 1 + combine([2,3,4],1) + 2 + combine([3,4],1) + 3 + combine([4],1) combine([2,3,4],1) = 2 + 3 + 4 稍加调试将上面的思路转成代码我们得到： /** * @param {number} n * @param {number} k * @return {number[][]} */ var combine = function (n, k) { var result = []; /** * @param {*} i 序号 * @param {*} n 总数 * @param {*} k 要取的个数 * @param {*} a 上一次的结果 */ function process(i, n, k, a) { i = i || 1; a = a || []; if (k &gt; 1) { for (var i = i; i &lt; n + 1; i++) { var row = []; row = row.concat(a) row.push(i); process(i + 1, n, k - 1, row); } } else { for (var i = i; i &lt; n + 1; i++) { var row = a.slice(); row.push(i) result.push(row) } } } process(1, n, k); return result; }; console.log(combine(4, 2)) 相关资源 LeetCode Permutations LeetCode Combinations Permutation &amp; Combination - JSFiddle Implement All Permutations of a Set in JavaScript","@type":"BlogPosting","headline":"排列组合问题","dateModified":"2017-12-28T21:12:00+08:00","datePublished":"2017-12-28T21:12:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline"> 排列组合问题</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-12-28T21:12:00+08:00" itemprop="datePublished">Dec 28, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="排列组合问题">排列组合问题</h2>

<p>排列和组合是两个问题，因为有相似性，所以通常放一起。</p>

<p>所谓排列，是跟顺序有关的，比如从 <code class="language-plaintext highlighter-rouge">1,2,3</code> 中取三个数出来，序列 <code class="language-plaintext highlighter-rouge">1,2,3</code> 与 <code class="language-plaintext highlighter-rouge">1,3,2</code> 是两个不同的序列。这便是排列。</p>

<p>而组合则与顺序无关，比如从 <code class="language-plaintext highlighter-rouge">1,2,3</code> 这一序列中取两个数出来， <code class="language-plaintext highlighter-rouge">1,2</code> 与 <code class="language-plaintext highlighter-rouge">2,1</code> 只能算一种取法，只关心元素不关心顺序。</p>

<p>先来看排列。</p>

<h3 id="排列permutation">排列/Permutation</h3>

<p>考察 LeetCode 上面这个排列题目：</p>

<blockquote>
  <p>Given a collection of distinct numbers, return all possible permutations.</p>

  <p>For example,
<code class="language-plaintext highlighter-rouge">[1,2,3]</code> have the following permutations:</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>
</code></pre></div></div>

<p>转述一下：对于给定非重复序列<code class="language-plaintext highlighter-rouge">[1,2,3]</code>，找出其所有可能的排列。相当于从 n 个元素中取出 n 个，看有多少种排列。</p>

<p>这样说来，就和中学数学的公式可以联系起来了。</p>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/js-permutation-and-combination/assets/formula.png" alt="排列组合公式" /></p>

<p><strong>排列组合公式</strong></p>

<p>通过上面的公式，我们可以算出 <code class="language-plaintext highlighter-rouge">A3,3 = 3!/(3-3)! = 3!/1 = 3x2x1 = 6</code>。
即一共有 6 种可能的排列，以此来验证我们后面实现的算法得到的结果是否准确。</p>

<p>接下来的任务是实现一个方法，找出所有排列。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @param {number[]} nums
 * @return {number[][]}
 */</span>
<span class="kd">var</span> <span class="nx">permute</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 实现</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="问题分析">问题分析</h4>

<p>假设让人脑来解决这个问题，我们屡一下思路：</p>

<ul>
  <li>取出第一个元素 <code class="language-plaintext highlighter-rouge">1</code>, 剩下的 <code class="language-plaintext highlighter-rouge">[2,3]</code> 中有两种取法</li>
  <li>先取 <code class="language-plaintext highlighter-rouge">2</code> 再取 <code class="language-plaintext highlighter-rouge">3</code>， 得到 <code class="language-plaintext highlighter-rouge">[1,2,3]</code></li>
  <li>先取 <code class="language-plaintext highlighter-rouge">3</code> 再取 <code class="language-plaintext highlighter-rouge">2</code>， 得到 <code class="language-plaintext highlighter-rouge">[1,3,2]</code></li>
  <li><code class="language-plaintext highlighter-rouge">1</code> 打头的取完了，考虑先取 <code class="language-plaintext highlighter-rouge">2</code>，从剩下的 <code class="language-plaintext highlighter-rouge">[1,3]</code> 中，也有两种取法</li>
  <li>于是分别得到 <code class="language-plaintext highlighter-rouge">[2,1,3]</code>，<code class="language-plaintext highlighter-rouge">[2,3,1]</code></li>
  <li>最后先取 <code class="language-plaintext highlighter-rouge">3</code>，也能得到两种排列 <code class="language-plaintext highlighter-rouge">[3,1,2]</code>，<code class="language-plaintext highlighter-rouge">[3,2,1]</code></li>
  <li>最后得到完整的结果为 <code class="language-plaintext highlighter-rouge">[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></li>
</ul>

<p>将上面的步骤抽象到类似伪代码的表示方式，可以方便我们将问题细化，最后得到一个递归的实现思路。</p>

<p>假设我们已经写好这么一个方法 <code class="language-plaintext highlighter-rouge">permute</code> 了，它的功能是对于输入数组，输出其所有排列。</p>

<p>于是上面的思路可以描述成：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">permute</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">permute</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> 
                 <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="nx">permute</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
                 <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="nx">permute</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>

<span class="nx">permute</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="nx">permute</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
               <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="nx">permute</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>

<span class="nx">permute</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div></div>

<p>从整体数组中取出一个，剩下的数组中进行看成新的输入。如此重复，直到最后的输入变成一个元素，一个元素的排列就是其本身。第一步得到的结果都往下传递，到达到后一个元素时，我们便会得到一条完整的结果，最后所有的结果汇总便是总的结果。</p>

<p>所以，我们应该有一个变量来存放最后的总结果，然后对于每次递归的终点我们有对应的变量存放单个结果。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">var</span> <span class="nx">permute</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">input</span><span class="cm">/*上一次处理后剩下的元素*/</span><span class="p">,</span> <span class="nx">prevResult</span><span class="cm">/*上一次处理后的结果*/</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">input</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//遍历输入，将其中的每个元素都取出压入一次结果中，对于剩下的元素递归调用进行同样的操作</span>
                <span class="c1">//...</span>
                <span class="nx">process</span><span class="p">(</span><span class="nx">nextInput</span><span class="p">,</span> <span class="nx">currentResult</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 输入为1个元素了，表示我们寻找到了终点</span>
            <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="cm">/*这里我们会得到一条结果，压入总结果中*/</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">process</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>每次操作，当输入长度不为 1 时，说明没有递归到最终，于是我们将输入中每个元素取出来放入一个临时结果中，将这个临时结果传递给下一次操作。每次操作都会往这个结果里增加一个元素。直到进行到输入还剩下一个元素的时候，我们便会得到一个完整的结果。将所有的结果合并，便得到了全部结果。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @param {number[]} nums
 * @return {number[][]}
 */</span>
<span class="kd">var</span> <span class="nx">permute</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>

	<span class="cm">/**
	 * @param {number[]} input 输入数组
	 * @param {number[]} prevResult 上一次得到的结果
	 * @return {number[]}
	 */</span>
    <span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">prevResult</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">input</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">currentResult</span> <span class="o">=</span> <span class="nx">prevResult</span> <span class="o">||</span> <span class="p">[];</span>
                <span class="nx">currentResult</span> <span class="o">=</span> <span class="nx">currentResult</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">input</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
                <span class="kd">var</span> <span class="nx">nextInput</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
                <span class="nx">nextInput</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                <span class="nx">process</span><span class="p">(</span><span class="nx">nextInput</span><span class="p">,</span> <span class="nx">currentResult</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">currentResult</span> <span class="o">=</span> <span class="nx">prevResult</span> <span class="o">||</span> <span class="p">[];</span>
            <span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="nx">currentResult</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
            <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">row</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">process</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">permute</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
</code></pre></div></div>

<h3 id="组合combination">组合/Combination</h3>

<p>同样地，来看这个来自 LeetCode 关于组合的题目：</p>

<blockquote>
  <p>Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.</p>

  <p>For example,
If n = 4 and k = 2, a solution is:</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
<span class="p">]</span>
</code></pre></div></div>

<p>即，对于给定正整数 n，从序列 1~n 中取出 k 个数，找出所有取法。</p>

<p>比如从 <code class="language-plaintext highlighter-rouge">[1,2,3,4]</code> 中取 2 个数，通过组合公式我们可以得出可能的取法一共有</p>

<p><code class="language-plaintext highlighter-rouge">C4,2 = 4!/2!(4-2)! = 4!/2!2! = (4x3x2x1)/(2x1)(2x1) = 6</code></p>

<p>6种取法。</p>

<p>下面我们来实现 <code class="language-plaintext highlighter-rouge">combine</code> 函数，找出所有的组合。</p>

<p>思路和排列的类似，也是先将问题进行拆分，直到不能再拆。</p>

<p>假设从 <code class="language-plaintext highlighter-rouge">[1,2,3,4]</code> 中取 2 个表示为 <code class="language-plaintext highlighter-rouge">combine([1,2,3,4],2)</code>。那么取出 <code class="language-plaintext highlighter-rouge">1</code> 后，我们接下来需要在剩下的 <code class="language-plaintext highlighter-rouge">[2,3,4]</code> 中 1 个元素，最后达到要求的 2 个元素。而从剩下的 <code class="language-plaintext highlighter-rouge">[2,3,4]</code> 取 1 个元素可类似地表示为 <code class="language-plaintext highlighter-rouge">combine([2,3,4],1)</code>。到这里又看到了递归的影子。当问题拆分到从数组中取一个元素时，就拆不动了，因为从 n 个元素中取 1 个元素，有 n 种取法，无需再拆分。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">combine</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">combine</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
                 <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="nx">combine</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
                 <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="nx">combine</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>

<span class="nx">combine</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span>
</code></pre></div></div>

<p>稍加调试将上面的思路转成代码我们得到：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */</span>
<span class="kd">var</span> <span class="nx">combine</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="cm">/**
     * @param {*} i 序号
     * @param {*} n 总数
     * @param {*} k 要取的个数
     * @param {*} a 上一次的结果
     */</span>
    <span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">||</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">||</span> <span class="p">[];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="p">[];</span>
                <span class="nx">row</span> <span class="o">=</span> <span class="nx">row</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
                <span class="nx">row</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
                <span class="nx">process</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">row</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
                <span class="nx">row</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
                <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">process</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">k</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">combine</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="相关资源">相关资源</h3>

<ul>
  <li><a href="https://leetcode.com/problems/permutations/description/">LeetCode Permutations</a></li>
  <li><a href="https://leetcode.com/problems/combinations/description/">LeetCode Combinations</a></li>
  <li><a href="http://jsfiddle.net/jinwolf/Ek4N5/29/">Permutation &amp; Combination - JSFiddle</a></li>
  <li><a href="https://initjs.org/all-permutations-of-a-set-f1be174c79f8">Implement All Permutations of a Set in JavaScript</a></li>
</ul>


  </div><a class="u-url" href="/2017/12/28/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
