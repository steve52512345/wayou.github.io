<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>source map 的原理探究 | 牛さんの部落格</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="source map 的原理探究" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="source map 的原理探究 线上产品代码一般是编译过的，前端的编译处理过程包括不限于 转译器/Transpilers (Babel, Traceur) 编译器/Compilers (Closure Compiler, TypeScript, CoffeeScript, Dart) 压缩/Minifiers (UglifyJS) 这里提及的都是可生成source map 的操作。 经过这一系列骚气的操作后，发布到线上的代码已经面目全非，对带宽友好了，但对开发者调试并不友好。于是就有了 source map。顾名思义，他是源码的映射，可以将压缩后的代码再对应回未压缩的源码。使得我们在调试线上产品时，就好像在调试开发环境的代码。 来看一个工作的示例 准备两个测试文件，一个 log.js 里包含一个输出内容到控制台的函数： log.js function sayHello(name) { if (name.length &gt; 2) { name = name.substr(0, 1) + &#39;...&#39; } console.log(&#39;hello,&#39;, name) } 一个main.js 文件里面对这个方法进行了调用： main.js sayHello(&#39;世界&#39;) sayHello(&#39;第三世界的人们&#39;) 我们使用 uglify-js 将两者合并打包并且压缩。 npm install uglify-js -g uglifyjs log.js main.js -o output.js --source-map &quot;url=&#39;/output.js.map&#39;&quot; 安装并执行后，我们得到了一个输出文件 output.js，同时生成了一个 source map 文件 output.js.map。 output.js function sayHello(name){if(name.length&gt;2){name=name.substr(0,1)+&quot;...&quot;}console.log(&quot;hello,&quot;,name)}sayHello(&quot;世界&quot;);sayHello(&quot;第三世界的人们&quot;); //# sourceMappingURL=/output.js.map output.js.map {&quot;version&quot;:3,&quot;sources&quot;:[&quot;log.js&quot;,&quot;main.js&quot;],&quot;names&quot;:[&quot;sayHello&quot;,&quot;name&quot;,&quot;length&quot;,&quot;substr&quot;,&quot;console&quot;,&quot;log&quot;],&quot;mappings&quot;:&quot;AAAA,SAASA,SAASC,MACd,GAAIA,KAAKC,OAAS,EAAG,CACjBD,KAAOA,KAAKE,OAAO,EAAG,GAAK,MAE/BC,QAAQC,IAAI,SAAUJ,MCJ1BD,SAAS,MACTA,SAAS&quot;} 为了能够让 source map 能够被浏览器加载和解析， 再添加一个 index.html 来加载我们生成的这个output.js 文件。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;source map demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; source map demo &lt;script src=&quot;output.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 然后开启一个本地服务器，这里我使用 python 自带的server 工具： python3 -m http.server 在浏览器中开启 source map source map 在浏览器中默认是关闭的，这样就不会影响正常用户。当我们开启后，浏览器就根据压缩代码中指定的 source map 地址去请求 map 资源。 在浏览器中开启 source map 最后，就可以访问 http://localhost:8000/ 来测试我们的代码了。 在压缩过的代码中打断点 从截图中可以看到，开启 source map 后，除了页面中引用的 output.js 文件，浏览器还加载了生成它的两个源文件，以方便我们在调试浏览器会自动映射回未压缩合并的源文件。 为了测试，我们将 output.js 在调试工具中进行格式化，然后在 sayHello 函数中打一个断点，看它是否能将这个断点的位置还原到这段代码真实所在的文件及位置。 刷新页面后，我们发现，断点正确定位到了 log.js 中正确的位置。 代码的还原 会否觉得很赞啊！ 下面我们来了解它的工作原理。 我们所想象的 source map 将现实中的情况简化一下无非是以下的场景： 输入 ⇒ 处理转换（uglify） ⇒ 输出（js） 上面，输出无疑就是需要发布到产品线上的浏览器能运行的代码。这里只讨论 js，所以输出是 js 代码，当然，其实source map 也可以运用于其他资源比如 LESS/SASS 等编译到的 CSS。 而 source map 的功能是帮助我们在拿到输出后还原回输入。如果我们自己来实现，应该怎么做。 最直观的想法恐怕是，将生成的文件中每个字符位置对应的原位置保存起来，一一映射。请看来自这篇文章中给出的示例： “feel the force” ⇒ Yoda ⇒ “the force feel” 一个简单的文本转换输出，其中 Yoda 可以理解为一个转换器。将上面的的输入与输出列成表格可以得出这个转换后输入与输出的对应关系。 输出位置 输入 在输入中的位置 字符 行 1, 列 0 Yoda_input.txt 行 1, 列 5 t 行 1, 列 1 Yoda_input.txt 行 1, 列 6 h 行 1, 列 2 Yoda_input.txt 行 1, 列 7 e 行 1, 列 4 Yoda_input.txt 行 1, 列 9 f 行 1, 列 5 Yoda_input.txt 行 1, 列 10 o 行 1, 列 6 Yoda_input.txt 行 1, 列 11 r 行 1, 列 7 Yoda_input.txt 行 1, 列 12 c 行 1, 列 8 Yoda_input.txt 行 1, 列 13 e 行 1, 列 10 Yoda_input.txt 行 1, 列 0 f 行 1, 列 11 Yoda_input.txt 行 1, 列 1 e 行 1, 列 12 Yoda_input.txt 行 1, 列 2 e 行 1, 列 13 Yoda_input.txt 行 1, 列 3 l 这里之所以将输入文件也作为映射的必需值，它可以告诉我们从哪里去找源文件。并且，在代码合并时，生成输出文件的源文件不止一个，记录下每处代码来自哪个文件，在还原时也很重要。 上面可以直观看出，生成文件中 (1,0) 位置的字符对应源文件中 (1,5)位置的字符,... 将上面的表格整理记录成一个映射编码看起来会是这样的： mappings(283 字符):1|0|Yoda_input.txt|1|5, 1|1|Yoda_input.txt|1|6, 1|2|Yoda_input.txt|1|7, 1|4|Yoda_input.txt|1|9, 1|5|Yoda_input.txt|1|10, 1|6|Yoda_input.txt|1|11, 1|7|Yoda_input.txt|1|12, 1|8|Yoda_input.txt|1|13, 1|10|Yoda_input.txt|1|0, 1|11|Yoda_input.txt|1|1, 1|12|Yoda_input.txt|1|2, 1|13|Yoda_input.txt|1|3 这样确实能够将处理后的文件映射回原来的文件，但随着内容的增多，转换规则更加地复杂，这个记录映射的编码将飞速增长。这里源文件 feel the force 才12个字符，而记录他转换的映射就已经达到了283个字符。所以这个编码的方式还有待改进。 省去输出文件中的行号 大多数情况下处理后的文件行数都会少于源文件，特别是 js，使用 UglifyJS 压缩后的文件通常只有一行。基于此，每必要在每条映射中都带上输出文件的行号，转而在这些映射中插入;来标识换行，可以节省大量空间。 mappings (245 字符): 0|Yoda_input.txt|1|5, 1|Yoda_input.txt|1|6, 2|Yoda_input.txt|1|7, 4|Yoda_input.txt|1|9, 5|Yoda_input.txt|1|10, 6|Yoda_input.txt|1|11, 7|Yoda_input.txt|1|12, 8|Yoda_input.txt|1|13, 10|Yoda_input.txt|1|0, 11|Yoda_input.txt|1|1, 12|Yoda_input.txt|1|2, 13|Yoda_input.txt|1|3; 可符号化字符的提取 这个例子中，一共有三个单词，拿输出文件中 the 来说，当我们通过它的第一个字母t(1,0)确定出对应源文件中的位置(1,5)，后面的he 其实不用再记录映射了，因为the 可以作为一个整体来看，试想 js 源码中一个变量名，函数名这些都不会被拆开的，所以当我们确定的这个单词首字母的映射关系，那整个单词其实就能还原到原来的位置了。 所以，首先我们将文件中可符号化的字符提取出来，将他们作为整体来处理。 序号 符号 0 the 1 force 2 feel 于是得到一个所有包含所有符号的数组： names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] 在记录时，只需要记录一个索引，还原时通过索引来这个names 数组中找即可。所以上面映射规则中最后一列本来记录了每个字符，现在改为记录一个单词，而单词我们只记录其在抽取出来的符号数组中的索引。 所以 the 的映射由原来的 0|Yoda_input.txt|1|5, 1|Yoda_input.txt|1|6, 2|Yoda_input.txt|1|7 可以简化为 0|Yoda_input.txt|1|5|0 同时，考虑到代码经常会有合并打包的情况，即输入文件不止一个，所以可以将输入文件抽取一个数组，记录时，只需要记录一个索引，还原的时候再到这个数组中通过索引取出文件的位置及文件名即可。 sources: [&#39;Yoda_input.txt&#39;] 所以上面the 的映射进一步简化为： 0|0|1|5|0 于是我们得到了完整的映射为： sources: [&#39;Yoda_input.txt&#39;] names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] mappings (31 字符): 0|0|1|5|0, 4|0|1|9|1, 10|0|1|0|2; 记录相对位置 当文件内容巨大时，上面精简后的编码也有可能会因为数字位数的增加而变得很长，同时，处理较大数字总是不如处理较小数字容易和方便。于是考虑将上面记录的这些位置用相对值来记录。比如(1,1001)第一行第999列的符号，如果用相对值，我们就不用每次记录都从0开始数，假如前一个符号位置为 (1,999)，那后面这个符号可记录为（0，2），类似这样的相对值帮我们节省了空间，同时降低了数据的维度。 具体到本例中，看看最初的表格中，记录的输出文件中的位置: 输出位置 输出位置 行 1, 列 0 行 1, 列 0 行 1, 列 4 行 1, 列 (上一值 + 4 = 4) 行 1, 列 10 行 1, 列 (上一值 + 6 = 10) 对应到整个表格则是： 输出位置 输入文件的索引 输入的位置 符号索引 行 1, 列 0 0 行 1, 列 5 0 行 1, 列 +4 +0 行 1, 列 +4 +1 行 1, 列 +6 +0 行 1, 列 -9 +1 然后我们得到的编码为： sources: [&#39;Yoda_input.txt&#39;] names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] mappings (31 字符): 0|0|1|5|0, 4|0|1|4|1, 6|0|1|-9|1; 注意 上面记录相对位置后，我们的数字中出现了负值，所以之后解析 source map 文件看到负值就不会感到奇怪了 另外一点我的思考，对于输出位置来说，因为是递增的，相对位置确实有减小数字的作用，但对于输入位置，效果倒未必是这样了。拿上面映射中最后一组来说，原来的值是 10|0|1|0|2，改成相对值后为 6|0|1|-9|1。第四位的值即使去掉减号，因为它在源文件中的位置其实是不确定的，这个相对值可以变得很大，原来一位数记录的，完全有可能变成两位甚至三位。不过这种情况应该比较少，它增加的长度比起对于输出位置使用相对记法后节约的长度要小得多，所以总体上来说空间是被节约了的。 VLQ （Variable Length Quantities） 进一步的优化则需要引入一个新的概念了，VLQ(Variable-length quantity)。 VLQ 以数字的方式呈现 如果你想顺序记录4个数字，最简单的办法就是将每个数字用特殊的符号隔开： 1|2|3|4 如果如果提前告诉你这些被记录的数字都是一位的，那这个分隔线就没必要了，只需要简单记录成如下样子也能被正确识别出来： 1234 此时这个记录值的长度是原来的1/2，省了不少空间。 但实际上我们不可能只记录个位数的数字，使用 VLQ 方式时，如果一个数字后面还跟有剩余数字，将其标识出来即可。假设我们想记录如下的四个数字： 1|23|456|7 我们使用下划线来标识一个数字后跟有其他数字： 1234567 所以解读规则为： 1没有下划线，那解析出来第一个数字便是1 2有下划线，则继续解析，碰到3，3没有下划线，第二位数的解析到此为止，所以第二位数为23 4有下划线，继续，5也有，继续，6没有下划线，所以第三位数字为456 7没有下划线，第四位数字则为7 VLQ 以二进制方式的方式呈现 上面的示例中，引入了数字系统外的符号来标识一个数字还未结束。在二进制系统中，我们使用6个比特来记录一个数字（可表示至多64个值），用其中一个字节来标识它是否未结束(正文 C 标识)，不需要引入额外的符号，再用一位标识正负（下方 S），剩下还有四位用来表示数值。用这样6个字节组成的一组拼起来就可以表示出我们需要的数字串了。 B5 B4 B3 B2 B1 B0 C Value S 第一个字节组(四位作为值) 这样一个字节组可以表示的数字范围为： Binary group Meaning 000000 0 000001 * -0 000010 1 000011 -1 000100 2 000101 -2 … … 011110 15 011111 -15 100000 未结束的0 100001 未结束的-0 100010 未结束的1 100011 未结束的-1 … … 111110 未结束的15 111111 未结束的-15 * -0 没有实际意义，但技术上它是存在的 任意数字中，第一个字节组中已经标明了该数字的正负，所以后续的字节组中无需再标识，于是可以多出一位来作表示值。 B5 B4 B3 B2 B1 B0 C Value 未结束的字节组(五位作为值) 现在我们使用上面的二进制规则来重新编码之前的这个数字序列 1|23|456|7。 先看每个数字对应的真实二进制是多少： 数值 二进制 1 1 23 10111 456 111001000 7 111 对1进行编码 1需要一位来表示，还好对于首个字节组，我们有四位来表示值，所以是够用的。 B5(C) B4 B3 B2 B1 B0(S) 0 0 0 0 1 0 对23进行编码 23的二进制为10111一共需要5位，第一组字节组只能提供4位来记录值，所以用一组字节组不行，需要使用两组字节组。将 10111拆分为两组，后四位0111放入第一个字节组中，剩下一位1放入第二个字节组中。 B5(C) B4 B3 B2 B1 B0(S)   B5(C) B4 B3 B2 B1 B0 1 0 1 1 1 0   0 0 0 0 0 1 对456进行编码 456的二进制111001000需要占用9个字节，同样，一个字节组放不下，先拆出最后四位（1000）放入一个首位字节组中，剩下的5位（11100）放入跟随的字节组中。 B5(C) B4 B3 B2 B1 B0(S)   B5(C) B4 B3 B2 B1 B0 1 1 0 0 0 0   0 1 1 1 0 0 对7进行编码 3的二进制为111，首位字节组能够存放得下，于是编码为： B5(C) B4 B3 B2 B1 B0(S) 0 0 1 1 1 0 将上面的编码合并得到最终的编码： 000010 101110 000001 110000 011100 001110 base64 编码表 结合上面的 Base64 编码表，上面的结果转成对应的 base64 字符为： CuBwcO 利用 Base64 VLQ 编码生成最终的 srouce map 通过上面讨论的方法，回到开始的示例中，前面我们已经得到的编码为 sources: [&#39;Yoda_input.txt&#39;] names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] mappings (31 字符): 0|0|1|5|0, 4|0|1|4|1, 6|0|1|-9|1; 现在来编码 0|0|1|5|0。先用二进制对每个数字进行表示，再转成 VLQ 表示： 0-&gt; 0 -&gt; 000000 //0 0-&gt; 0 -&gt; 000000 //0 1-&gt; 1 -&gt; 000010 //2 5-&gt; 101 -&gt; 001010 // 10 0-&gt; 0 -&gt; 000000 //0 合并后的编码为： 000000 000000 000001 000101 000000 再转 Base64 后得到字符形式的结果： AACKA 后面两串数通过类似的做法也能得到对应的 Base64编码，所以最终我们得到的 source map 看起来是这样的： sources: [&#39;Yoda_input.txt&#39;] names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] mappings (18 字符): AACKA, IACIC, MACTC; 而真实的 srouce map 如我们文章开头那个示例一样，是一个 json 文件，所以最后我们得到的一分像模像样的 source map 为： { &quot;version&quot;: 3, &quot;file&quot;: &quot;Yoda_output.txt&quot;, &quot;sources&quot;: [&quot;Yoda_input.txt&quot;], &quot;names&quot;: [&quot;the&quot;, &quot;force&quot;, &quot;feel&quot;], &quot;mappings&quot;: &quot;AACKA,IACIC,MACTC;&quot; } 略去不必要的字段 上面的例子中，每一片段的编码由五位组成。真实场景中，有些情况下某些字段其实不必要，这时就可以将其省略。当然，这里给出的这个例子看不出来。 省略其中某些字段后，一个编码片段就不一定是5位了，他的长度有可能为1，4或者5。 5 - 包含全部五个部分：输出文件中的列号，输入文件索引，输入文件中的行号，输入文件中的列号，符号索引 4 - 输出文件中的列号，输入文件索引，输入文件中的行号，输入文件中的列号 1 - 输出文件中的列号 以上，便探究完了 srouce map 生成的全过程，了解了其原理。 如果感兴趣，这个Source map visualizer tool 工具可以在线将 source map 与对应代码可见化展现出来，方便理解。 另外需要介绍的是，尽管 source map 对于线上调试非常有用，各主流浏览器也实现对其的支持，但关于它的规范没有见诸各 Web 工作组或团体的官方文档中，它的规范是写在一个 Google 文档中的！这你敢信，不信去看一看喽~ Source Map Revision 3 Proposal 。 相关资料 Source Map Revision 3 Proposal Variable-length quantity Base64 Map Preprocessed Code to Source Code Source map visualizer tool Source Maps under the hood – VLQ, Base64 and Yoda Introduction to JavaScript Source Maps BASE64 VLQ 编码规则 后续 source map 的保护" />
<meta property="og:description" content="source map 的原理探究 线上产品代码一般是编译过的，前端的编译处理过程包括不限于 转译器/Transpilers (Babel, Traceur) 编译器/Compilers (Closure Compiler, TypeScript, CoffeeScript, Dart) 压缩/Minifiers (UglifyJS) 这里提及的都是可生成source map 的操作。 经过这一系列骚气的操作后，发布到线上的代码已经面目全非，对带宽友好了，但对开发者调试并不友好。于是就有了 source map。顾名思义，他是源码的映射，可以将压缩后的代码再对应回未压缩的源码。使得我们在调试线上产品时，就好像在调试开发环境的代码。 来看一个工作的示例 准备两个测试文件，一个 log.js 里包含一个输出内容到控制台的函数： log.js function sayHello(name) { if (name.length &gt; 2) { name = name.substr(0, 1) + &#39;...&#39; } console.log(&#39;hello,&#39;, name) } 一个main.js 文件里面对这个方法进行了调用： main.js sayHello(&#39;世界&#39;) sayHello(&#39;第三世界的人们&#39;) 我们使用 uglify-js 将两者合并打包并且压缩。 npm install uglify-js -g uglifyjs log.js main.js -o output.js --source-map &quot;url=&#39;/output.js.map&#39;&quot; 安装并执行后，我们得到了一个输出文件 output.js，同时生成了一个 source map 文件 output.js.map。 output.js function sayHello(name){if(name.length&gt;2){name=name.substr(0,1)+&quot;...&quot;}console.log(&quot;hello,&quot;,name)}sayHello(&quot;世界&quot;);sayHello(&quot;第三世界的人们&quot;); //# sourceMappingURL=/output.js.map output.js.map {&quot;version&quot;:3,&quot;sources&quot;:[&quot;log.js&quot;,&quot;main.js&quot;],&quot;names&quot;:[&quot;sayHello&quot;,&quot;name&quot;,&quot;length&quot;,&quot;substr&quot;,&quot;console&quot;,&quot;log&quot;],&quot;mappings&quot;:&quot;AAAA,SAASA,SAASC,MACd,GAAIA,KAAKC,OAAS,EAAG,CACjBD,KAAOA,KAAKE,OAAO,EAAG,GAAK,MAE/BC,QAAQC,IAAI,SAAUJ,MCJ1BD,SAAS,MACTA,SAAS&quot;} 为了能够让 source map 能够被浏览器加载和解析， 再添加一个 index.html 来加载我们生成的这个output.js 文件。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;source map demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; source map demo &lt;script src=&quot;output.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 然后开启一个本地服务器，这里我使用 python 自带的server 工具： python3 -m http.server 在浏览器中开启 source map source map 在浏览器中默认是关闭的，这样就不会影响正常用户。当我们开启后，浏览器就根据压缩代码中指定的 source map 地址去请求 map 资源。 在浏览器中开启 source map 最后，就可以访问 http://localhost:8000/ 来测试我们的代码了。 在压缩过的代码中打断点 从截图中可以看到，开启 source map 后，除了页面中引用的 output.js 文件，浏览器还加载了生成它的两个源文件，以方便我们在调试浏览器会自动映射回未压缩合并的源文件。 为了测试，我们将 output.js 在调试工具中进行格式化，然后在 sayHello 函数中打一个断点，看它是否能将这个断点的位置还原到这段代码真实所在的文件及位置。 刷新页面后，我们发现，断点正确定位到了 log.js 中正确的位置。 代码的还原 会否觉得很赞啊！ 下面我们来了解它的工作原理。 我们所想象的 source map 将现实中的情况简化一下无非是以下的场景： 输入 ⇒ 处理转换（uglify） ⇒ 输出（js） 上面，输出无疑就是需要发布到产品线上的浏览器能运行的代码。这里只讨论 js，所以输出是 js 代码，当然，其实source map 也可以运用于其他资源比如 LESS/SASS 等编译到的 CSS。 而 source map 的功能是帮助我们在拿到输出后还原回输入。如果我们自己来实现，应该怎么做。 最直观的想法恐怕是，将生成的文件中每个字符位置对应的原位置保存起来，一一映射。请看来自这篇文章中给出的示例： “feel the force” ⇒ Yoda ⇒ “the force feel” 一个简单的文本转换输出，其中 Yoda 可以理解为一个转换器。将上面的的输入与输出列成表格可以得出这个转换后输入与输出的对应关系。 输出位置 输入 在输入中的位置 字符 行 1, 列 0 Yoda_input.txt 行 1, 列 5 t 行 1, 列 1 Yoda_input.txt 行 1, 列 6 h 行 1, 列 2 Yoda_input.txt 行 1, 列 7 e 行 1, 列 4 Yoda_input.txt 行 1, 列 9 f 行 1, 列 5 Yoda_input.txt 行 1, 列 10 o 行 1, 列 6 Yoda_input.txt 行 1, 列 11 r 行 1, 列 7 Yoda_input.txt 行 1, 列 12 c 行 1, 列 8 Yoda_input.txt 行 1, 列 13 e 行 1, 列 10 Yoda_input.txt 行 1, 列 0 f 行 1, 列 11 Yoda_input.txt 行 1, 列 1 e 行 1, 列 12 Yoda_input.txt 行 1, 列 2 e 行 1, 列 13 Yoda_input.txt 行 1, 列 3 l 这里之所以将输入文件也作为映射的必需值，它可以告诉我们从哪里去找源文件。并且，在代码合并时，生成输出文件的源文件不止一个，记录下每处代码来自哪个文件，在还原时也很重要。 上面可以直观看出，生成文件中 (1,0) 位置的字符对应源文件中 (1,5)位置的字符,... 将上面的表格整理记录成一个映射编码看起来会是这样的： mappings(283 字符):1|0|Yoda_input.txt|1|5, 1|1|Yoda_input.txt|1|6, 1|2|Yoda_input.txt|1|7, 1|4|Yoda_input.txt|1|9, 1|5|Yoda_input.txt|1|10, 1|6|Yoda_input.txt|1|11, 1|7|Yoda_input.txt|1|12, 1|8|Yoda_input.txt|1|13, 1|10|Yoda_input.txt|1|0, 1|11|Yoda_input.txt|1|1, 1|12|Yoda_input.txt|1|2, 1|13|Yoda_input.txt|1|3 这样确实能够将处理后的文件映射回原来的文件，但随着内容的增多，转换规则更加地复杂，这个记录映射的编码将飞速增长。这里源文件 feel the force 才12个字符，而记录他转换的映射就已经达到了283个字符。所以这个编码的方式还有待改进。 省去输出文件中的行号 大多数情况下处理后的文件行数都会少于源文件，特别是 js，使用 UglifyJS 压缩后的文件通常只有一行。基于此，每必要在每条映射中都带上输出文件的行号，转而在这些映射中插入;来标识换行，可以节省大量空间。 mappings (245 字符): 0|Yoda_input.txt|1|5, 1|Yoda_input.txt|1|6, 2|Yoda_input.txt|1|7, 4|Yoda_input.txt|1|9, 5|Yoda_input.txt|1|10, 6|Yoda_input.txt|1|11, 7|Yoda_input.txt|1|12, 8|Yoda_input.txt|1|13, 10|Yoda_input.txt|1|0, 11|Yoda_input.txt|1|1, 12|Yoda_input.txt|1|2, 13|Yoda_input.txt|1|3; 可符号化字符的提取 这个例子中，一共有三个单词，拿输出文件中 the 来说，当我们通过它的第一个字母t(1,0)确定出对应源文件中的位置(1,5)，后面的he 其实不用再记录映射了，因为the 可以作为一个整体来看，试想 js 源码中一个变量名，函数名这些都不会被拆开的，所以当我们确定的这个单词首字母的映射关系，那整个单词其实就能还原到原来的位置了。 所以，首先我们将文件中可符号化的字符提取出来，将他们作为整体来处理。 序号 符号 0 the 1 force 2 feel 于是得到一个所有包含所有符号的数组： names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] 在记录时，只需要记录一个索引，还原时通过索引来这个names 数组中找即可。所以上面映射规则中最后一列本来记录了每个字符，现在改为记录一个单词，而单词我们只记录其在抽取出来的符号数组中的索引。 所以 the 的映射由原来的 0|Yoda_input.txt|1|5, 1|Yoda_input.txt|1|6, 2|Yoda_input.txt|1|7 可以简化为 0|Yoda_input.txt|1|5|0 同时，考虑到代码经常会有合并打包的情况，即输入文件不止一个，所以可以将输入文件抽取一个数组，记录时，只需要记录一个索引，还原的时候再到这个数组中通过索引取出文件的位置及文件名即可。 sources: [&#39;Yoda_input.txt&#39;] 所以上面the 的映射进一步简化为： 0|0|1|5|0 于是我们得到了完整的映射为： sources: [&#39;Yoda_input.txt&#39;] names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] mappings (31 字符): 0|0|1|5|0, 4|0|1|9|1, 10|0|1|0|2; 记录相对位置 当文件内容巨大时，上面精简后的编码也有可能会因为数字位数的增加而变得很长，同时，处理较大数字总是不如处理较小数字容易和方便。于是考虑将上面记录的这些位置用相对值来记录。比如(1,1001)第一行第999列的符号，如果用相对值，我们就不用每次记录都从0开始数，假如前一个符号位置为 (1,999)，那后面这个符号可记录为（0，2），类似这样的相对值帮我们节省了空间，同时降低了数据的维度。 具体到本例中，看看最初的表格中，记录的输出文件中的位置: 输出位置 输出位置 行 1, 列 0 行 1, 列 0 行 1, 列 4 行 1, 列 (上一值 + 4 = 4) 行 1, 列 10 行 1, 列 (上一值 + 6 = 10) 对应到整个表格则是： 输出位置 输入文件的索引 输入的位置 符号索引 行 1, 列 0 0 行 1, 列 5 0 行 1, 列 +4 +0 行 1, 列 +4 +1 行 1, 列 +6 +0 行 1, 列 -9 +1 然后我们得到的编码为： sources: [&#39;Yoda_input.txt&#39;] names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] mappings (31 字符): 0|0|1|5|0, 4|0|1|4|1, 6|0|1|-9|1; 注意 上面记录相对位置后，我们的数字中出现了负值，所以之后解析 source map 文件看到负值就不会感到奇怪了 另外一点我的思考，对于输出位置来说，因为是递增的，相对位置确实有减小数字的作用，但对于输入位置，效果倒未必是这样了。拿上面映射中最后一组来说，原来的值是 10|0|1|0|2，改成相对值后为 6|0|1|-9|1。第四位的值即使去掉减号，因为它在源文件中的位置其实是不确定的，这个相对值可以变得很大，原来一位数记录的，完全有可能变成两位甚至三位。不过这种情况应该比较少，它增加的长度比起对于输出位置使用相对记法后节约的长度要小得多，所以总体上来说空间是被节约了的。 VLQ （Variable Length Quantities） 进一步的优化则需要引入一个新的概念了，VLQ(Variable-length quantity)。 VLQ 以数字的方式呈现 如果你想顺序记录4个数字，最简单的办法就是将每个数字用特殊的符号隔开： 1|2|3|4 如果如果提前告诉你这些被记录的数字都是一位的，那这个分隔线就没必要了，只需要简单记录成如下样子也能被正确识别出来： 1234 此时这个记录值的长度是原来的1/2，省了不少空间。 但实际上我们不可能只记录个位数的数字，使用 VLQ 方式时，如果一个数字后面还跟有剩余数字，将其标识出来即可。假设我们想记录如下的四个数字： 1|23|456|7 我们使用下划线来标识一个数字后跟有其他数字： 1234567 所以解读规则为： 1没有下划线，那解析出来第一个数字便是1 2有下划线，则继续解析，碰到3，3没有下划线，第二位数的解析到此为止，所以第二位数为23 4有下划线，继续，5也有，继续，6没有下划线，所以第三位数字为456 7没有下划线，第四位数字则为7 VLQ 以二进制方式的方式呈现 上面的示例中，引入了数字系统外的符号来标识一个数字还未结束。在二进制系统中，我们使用6个比特来记录一个数字（可表示至多64个值），用其中一个字节来标识它是否未结束(正文 C 标识)，不需要引入额外的符号，再用一位标识正负（下方 S），剩下还有四位用来表示数值。用这样6个字节组成的一组拼起来就可以表示出我们需要的数字串了。 B5 B4 B3 B2 B1 B0 C Value S 第一个字节组(四位作为值) 这样一个字节组可以表示的数字范围为： Binary group Meaning 000000 0 000001 * -0 000010 1 000011 -1 000100 2 000101 -2 … … 011110 15 011111 -15 100000 未结束的0 100001 未结束的-0 100010 未结束的1 100011 未结束的-1 … … 111110 未结束的15 111111 未结束的-15 * -0 没有实际意义，但技术上它是存在的 任意数字中，第一个字节组中已经标明了该数字的正负，所以后续的字节组中无需再标识，于是可以多出一位来作表示值。 B5 B4 B3 B2 B1 B0 C Value 未结束的字节组(五位作为值) 现在我们使用上面的二进制规则来重新编码之前的这个数字序列 1|23|456|7。 先看每个数字对应的真实二进制是多少： 数值 二进制 1 1 23 10111 456 111001000 7 111 对1进行编码 1需要一位来表示，还好对于首个字节组，我们有四位来表示值，所以是够用的。 B5(C) B4 B3 B2 B1 B0(S) 0 0 0 0 1 0 对23进行编码 23的二进制为10111一共需要5位，第一组字节组只能提供4位来记录值，所以用一组字节组不行，需要使用两组字节组。将 10111拆分为两组，后四位0111放入第一个字节组中，剩下一位1放入第二个字节组中。 B5(C) B4 B3 B2 B1 B0(S)   B5(C) B4 B3 B2 B1 B0 1 0 1 1 1 0   0 0 0 0 0 1 对456进行编码 456的二进制111001000需要占用9个字节，同样，一个字节组放不下，先拆出最后四位（1000）放入一个首位字节组中，剩下的5位（11100）放入跟随的字节组中。 B5(C) B4 B3 B2 B1 B0(S)   B5(C) B4 B3 B2 B1 B0 1 1 0 0 0 0   0 1 1 1 0 0 对7进行编码 3的二进制为111，首位字节组能够存放得下，于是编码为： B5(C) B4 B3 B2 B1 B0(S) 0 0 1 1 1 0 将上面的编码合并得到最终的编码： 000010 101110 000001 110000 011100 001110 base64 编码表 结合上面的 Base64 编码表，上面的结果转成对应的 base64 字符为： CuBwcO 利用 Base64 VLQ 编码生成最终的 srouce map 通过上面讨论的方法，回到开始的示例中，前面我们已经得到的编码为 sources: [&#39;Yoda_input.txt&#39;] names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] mappings (31 字符): 0|0|1|5|0, 4|0|1|4|1, 6|0|1|-9|1; 现在来编码 0|0|1|5|0。先用二进制对每个数字进行表示，再转成 VLQ 表示： 0-&gt; 0 -&gt; 000000 //0 0-&gt; 0 -&gt; 000000 //0 1-&gt; 1 -&gt; 000010 //2 5-&gt; 101 -&gt; 001010 // 10 0-&gt; 0 -&gt; 000000 //0 合并后的编码为： 000000 000000 000001 000101 000000 再转 Base64 后得到字符形式的结果： AACKA 后面两串数通过类似的做法也能得到对应的 Base64编码，所以最终我们得到的 source map 看起来是这样的： sources: [&#39;Yoda_input.txt&#39;] names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] mappings (18 字符): AACKA, IACIC, MACTC; 而真实的 srouce map 如我们文章开头那个示例一样，是一个 json 文件，所以最后我们得到的一分像模像样的 source map 为： { &quot;version&quot;: 3, &quot;file&quot;: &quot;Yoda_output.txt&quot;, &quot;sources&quot;: [&quot;Yoda_input.txt&quot;], &quot;names&quot;: [&quot;the&quot;, &quot;force&quot;, &quot;feel&quot;], &quot;mappings&quot;: &quot;AACKA,IACIC,MACTC;&quot; } 略去不必要的字段 上面的例子中，每一片段的编码由五位组成。真实场景中，有些情况下某些字段其实不必要，这时就可以将其省略。当然，这里给出的这个例子看不出来。 省略其中某些字段后，一个编码片段就不一定是5位了，他的长度有可能为1，4或者5。 5 - 包含全部五个部分：输出文件中的列号，输入文件索引，输入文件中的行号，输入文件中的列号，符号索引 4 - 输出文件中的列号，输入文件索引，输入文件中的行号，输入文件中的列号 1 - 输出文件中的列号 以上，便探究完了 srouce map 生成的全过程，了解了其原理。 如果感兴趣，这个Source map visualizer tool 工具可以在线将 source map 与对应代码可见化展现出来，方便理解。 另外需要介绍的是，尽管 source map 对于线上调试非常有用，各主流浏览器也实现对其的支持，但关于它的规范没有见诸各 Web 工作组或团体的官方文档中，它的规范是写在一个 Google 文档中的！这你敢信，不信去看一看喽~ Source Map Revision 3 Proposal 。 相关资料 Source Map Revision 3 Proposal Variable-length quantity Base64 Map Preprocessed Code to Source Code Source map visualizer tool Source Maps under the hood – VLQ, Base64 and Yoda Introduction to JavaScript Source Maps BASE64 VLQ 编码规则 后续 source map 的保护" />
<link rel="canonical" href="http://localhost:4000/2017/12/05/source-map-%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6.html" />
<meta property="og:url" content="http://localhost:4000/2017/12/05/source-map-%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6.html" />
<meta property="og:site_name" content="牛さんの部落格" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-12-05T23:12:00+08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2017/12/05/source-map-%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2017/12/05/source-map-%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6.html"},"description":"source map 的原理探究 线上产品代码一般是编译过的，前端的编译处理过程包括不限于 转译器/Transpilers (Babel, Traceur) 编译器/Compilers (Closure Compiler, TypeScript, CoffeeScript, Dart) 压缩/Minifiers (UglifyJS) 这里提及的都是可生成source map 的操作。 经过这一系列骚气的操作后，发布到线上的代码已经面目全非，对带宽友好了，但对开发者调试并不友好。于是就有了 source map。顾名思义，他是源码的映射，可以将压缩后的代码再对应回未压缩的源码。使得我们在调试线上产品时，就好像在调试开发环境的代码。 来看一个工作的示例 准备两个测试文件，一个 log.js 里包含一个输出内容到控制台的函数： log.js function sayHello(name) { if (name.length &gt; 2) { name = name.substr(0, 1) + &#39;...&#39; } console.log(&#39;hello,&#39;, name) } 一个main.js 文件里面对这个方法进行了调用： main.js sayHello(&#39;世界&#39;) sayHello(&#39;第三世界的人们&#39;) 我们使用 uglify-js 将两者合并打包并且压缩。 npm install uglify-js -g uglifyjs log.js main.js -o output.js --source-map &quot;url=&#39;/output.js.map&#39;&quot; 安装并执行后，我们得到了一个输出文件 output.js，同时生成了一个 source map 文件 output.js.map。 output.js function sayHello(name){if(name.length&gt;2){name=name.substr(0,1)+&quot;...&quot;}console.log(&quot;hello,&quot;,name)}sayHello(&quot;世界&quot;);sayHello(&quot;第三世界的人们&quot;); //# sourceMappingURL=/output.js.map output.js.map {&quot;version&quot;:3,&quot;sources&quot;:[&quot;log.js&quot;,&quot;main.js&quot;],&quot;names&quot;:[&quot;sayHello&quot;,&quot;name&quot;,&quot;length&quot;,&quot;substr&quot;,&quot;console&quot;,&quot;log&quot;],&quot;mappings&quot;:&quot;AAAA,SAASA,SAASC,MACd,GAAIA,KAAKC,OAAS,EAAG,CACjBD,KAAOA,KAAKE,OAAO,EAAG,GAAK,MAE/BC,QAAQC,IAAI,SAAUJ,MCJ1BD,SAAS,MACTA,SAAS&quot;} 为了能够让 source map 能够被浏览器加载和解析， 再添加一个 index.html 来加载我们生成的这个output.js 文件。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;source map demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; source map demo &lt;script src=&quot;output.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 然后开启一个本地服务器，这里我使用 python 自带的server 工具： python3 -m http.server 在浏览器中开启 source map source map 在浏览器中默认是关闭的，这样就不会影响正常用户。当我们开启后，浏览器就根据压缩代码中指定的 source map 地址去请求 map 资源。 在浏览器中开启 source map 最后，就可以访问 http://localhost:8000/ 来测试我们的代码了。 在压缩过的代码中打断点 从截图中可以看到，开启 source map 后，除了页面中引用的 output.js 文件，浏览器还加载了生成它的两个源文件，以方便我们在调试浏览器会自动映射回未压缩合并的源文件。 为了测试，我们将 output.js 在调试工具中进行格式化，然后在 sayHello 函数中打一个断点，看它是否能将这个断点的位置还原到这段代码真实所在的文件及位置。 刷新页面后，我们发现，断点正确定位到了 log.js 中正确的位置。 代码的还原 会否觉得很赞啊！ 下面我们来了解它的工作原理。 我们所想象的 source map 将现实中的情况简化一下无非是以下的场景： 输入 ⇒ 处理转换（uglify） ⇒ 输出（js） 上面，输出无疑就是需要发布到产品线上的浏览器能运行的代码。这里只讨论 js，所以输出是 js 代码，当然，其实source map 也可以运用于其他资源比如 LESS/SASS 等编译到的 CSS。 而 source map 的功能是帮助我们在拿到输出后还原回输入。如果我们自己来实现，应该怎么做。 最直观的想法恐怕是，将生成的文件中每个字符位置对应的原位置保存起来，一一映射。请看来自这篇文章中给出的示例： “feel the force” ⇒ Yoda ⇒ “the force feel” 一个简单的文本转换输出，其中 Yoda 可以理解为一个转换器。将上面的的输入与输出列成表格可以得出这个转换后输入与输出的对应关系。 输出位置 输入 在输入中的位置 字符 行 1, 列 0 Yoda_input.txt 行 1, 列 5 t 行 1, 列 1 Yoda_input.txt 行 1, 列 6 h 行 1, 列 2 Yoda_input.txt 行 1, 列 7 e 行 1, 列 4 Yoda_input.txt 行 1, 列 9 f 行 1, 列 5 Yoda_input.txt 行 1, 列 10 o 行 1, 列 6 Yoda_input.txt 行 1, 列 11 r 行 1, 列 7 Yoda_input.txt 行 1, 列 12 c 行 1, 列 8 Yoda_input.txt 行 1, 列 13 e 行 1, 列 10 Yoda_input.txt 行 1, 列 0 f 行 1, 列 11 Yoda_input.txt 行 1, 列 1 e 行 1, 列 12 Yoda_input.txt 行 1, 列 2 e 行 1, 列 13 Yoda_input.txt 行 1, 列 3 l 这里之所以将输入文件也作为映射的必需值，它可以告诉我们从哪里去找源文件。并且，在代码合并时，生成输出文件的源文件不止一个，记录下每处代码来自哪个文件，在还原时也很重要。 上面可以直观看出，生成文件中 (1,0) 位置的字符对应源文件中 (1,5)位置的字符,... 将上面的表格整理记录成一个映射编码看起来会是这样的： mappings(283 字符):1|0|Yoda_input.txt|1|5, 1|1|Yoda_input.txt|1|6, 1|2|Yoda_input.txt|1|7, 1|4|Yoda_input.txt|1|9, 1|5|Yoda_input.txt|1|10, 1|6|Yoda_input.txt|1|11, 1|7|Yoda_input.txt|1|12, 1|8|Yoda_input.txt|1|13, 1|10|Yoda_input.txt|1|0, 1|11|Yoda_input.txt|1|1, 1|12|Yoda_input.txt|1|2, 1|13|Yoda_input.txt|1|3 这样确实能够将处理后的文件映射回原来的文件，但随着内容的增多，转换规则更加地复杂，这个记录映射的编码将飞速增长。这里源文件 feel the force 才12个字符，而记录他转换的映射就已经达到了283个字符。所以这个编码的方式还有待改进。 省去输出文件中的行号 大多数情况下处理后的文件行数都会少于源文件，特别是 js，使用 UglifyJS 压缩后的文件通常只有一行。基于此，每必要在每条映射中都带上输出文件的行号，转而在这些映射中插入;来标识换行，可以节省大量空间。 mappings (245 字符): 0|Yoda_input.txt|1|5, 1|Yoda_input.txt|1|6, 2|Yoda_input.txt|1|7, 4|Yoda_input.txt|1|9, 5|Yoda_input.txt|1|10, 6|Yoda_input.txt|1|11, 7|Yoda_input.txt|1|12, 8|Yoda_input.txt|1|13, 10|Yoda_input.txt|1|0, 11|Yoda_input.txt|1|1, 12|Yoda_input.txt|1|2, 13|Yoda_input.txt|1|3; 可符号化字符的提取 这个例子中，一共有三个单词，拿输出文件中 the 来说，当我们通过它的第一个字母t(1,0)确定出对应源文件中的位置(1,5)，后面的he 其实不用再记录映射了，因为the 可以作为一个整体来看，试想 js 源码中一个变量名，函数名这些都不会被拆开的，所以当我们确定的这个单词首字母的映射关系，那整个单词其实就能还原到原来的位置了。 所以，首先我们将文件中可符号化的字符提取出来，将他们作为整体来处理。 序号 符号 0 the 1 force 2 feel 于是得到一个所有包含所有符号的数组： names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] 在记录时，只需要记录一个索引，还原时通过索引来这个names 数组中找即可。所以上面映射规则中最后一列本来记录了每个字符，现在改为记录一个单词，而单词我们只记录其在抽取出来的符号数组中的索引。 所以 the 的映射由原来的 0|Yoda_input.txt|1|5, 1|Yoda_input.txt|1|6, 2|Yoda_input.txt|1|7 可以简化为 0|Yoda_input.txt|1|5|0 同时，考虑到代码经常会有合并打包的情况，即输入文件不止一个，所以可以将输入文件抽取一个数组，记录时，只需要记录一个索引，还原的时候再到这个数组中通过索引取出文件的位置及文件名即可。 sources: [&#39;Yoda_input.txt&#39;] 所以上面the 的映射进一步简化为： 0|0|1|5|0 于是我们得到了完整的映射为： sources: [&#39;Yoda_input.txt&#39;] names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] mappings (31 字符): 0|0|1|5|0, 4|0|1|9|1, 10|0|1|0|2; 记录相对位置 当文件内容巨大时，上面精简后的编码也有可能会因为数字位数的增加而变得很长，同时，处理较大数字总是不如处理较小数字容易和方便。于是考虑将上面记录的这些位置用相对值来记录。比如(1,1001)第一行第999列的符号，如果用相对值，我们就不用每次记录都从0开始数，假如前一个符号位置为 (1,999)，那后面这个符号可记录为（0，2），类似这样的相对值帮我们节省了空间，同时降低了数据的维度。 具体到本例中，看看最初的表格中，记录的输出文件中的位置: 输出位置 输出位置 行 1, 列 0 行 1, 列 0 行 1, 列 4 行 1, 列 (上一值 + 4 = 4) 行 1, 列 10 行 1, 列 (上一值 + 6 = 10) 对应到整个表格则是： 输出位置 输入文件的索引 输入的位置 符号索引 行 1, 列 0 0 行 1, 列 5 0 行 1, 列 +4 +0 行 1, 列 +4 +1 行 1, 列 +6 +0 行 1, 列 -9 +1 然后我们得到的编码为： sources: [&#39;Yoda_input.txt&#39;] names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] mappings (31 字符): 0|0|1|5|0, 4|0|1|4|1, 6|0|1|-9|1; 注意 上面记录相对位置后，我们的数字中出现了负值，所以之后解析 source map 文件看到负值就不会感到奇怪了 另外一点我的思考，对于输出位置来说，因为是递增的，相对位置确实有减小数字的作用，但对于输入位置，效果倒未必是这样了。拿上面映射中最后一组来说，原来的值是 10|0|1|0|2，改成相对值后为 6|0|1|-9|1。第四位的值即使去掉减号，因为它在源文件中的位置其实是不确定的，这个相对值可以变得很大，原来一位数记录的，完全有可能变成两位甚至三位。不过这种情况应该比较少，它增加的长度比起对于输出位置使用相对记法后节约的长度要小得多，所以总体上来说空间是被节约了的。 VLQ （Variable Length Quantities） 进一步的优化则需要引入一个新的概念了，VLQ(Variable-length quantity)。 VLQ 以数字的方式呈现 如果你想顺序记录4个数字，最简单的办法就是将每个数字用特殊的符号隔开： 1|2|3|4 如果如果提前告诉你这些被记录的数字都是一位的，那这个分隔线就没必要了，只需要简单记录成如下样子也能被正确识别出来： 1234 此时这个记录值的长度是原来的1/2，省了不少空间。 但实际上我们不可能只记录个位数的数字，使用 VLQ 方式时，如果一个数字后面还跟有剩余数字，将其标识出来即可。假设我们想记录如下的四个数字： 1|23|456|7 我们使用下划线来标识一个数字后跟有其他数字： 1234567 所以解读规则为： 1没有下划线，那解析出来第一个数字便是1 2有下划线，则继续解析，碰到3，3没有下划线，第二位数的解析到此为止，所以第二位数为23 4有下划线，继续，5也有，继续，6没有下划线，所以第三位数字为456 7没有下划线，第四位数字则为7 VLQ 以二进制方式的方式呈现 上面的示例中，引入了数字系统外的符号来标识一个数字还未结束。在二进制系统中，我们使用6个比特来记录一个数字（可表示至多64个值），用其中一个字节来标识它是否未结束(正文 C 标识)，不需要引入额外的符号，再用一位标识正负（下方 S），剩下还有四位用来表示数值。用这样6个字节组成的一组拼起来就可以表示出我们需要的数字串了。 B5 B4 B3 B2 B1 B0 C Value S 第一个字节组(四位作为值) 这样一个字节组可以表示的数字范围为： Binary group Meaning 000000 0 000001 * -0 000010 1 000011 -1 000100 2 000101 -2 … … 011110 15 011111 -15 100000 未结束的0 100001 未结束的-0 100010 未结束的1 100011 未结束的-1 … … 111110 未结束的15 111111 未结束的-15 * -0 没有实际意义，但技术上它是存在的 任意数字中，第一个字节组中已经标明了该数字的正负，所以后续的字节组中无需再标识，于是可以多出一位来作表示值。 B5 B4 B3 B2 B1 B0 C Value 未结束的字节组(五位作为值) 现在我们使用上面的二进制规则来重新编码之前的这个数字序列 1|23|456|7。 先看每个数字对应的真实二进制是多少： 数值 二进制 1 1 23 10111 456 111001000 7 111 对1进行编码 1需要一位来表示，还好对于首个字节组，我们有四位来表示值，所以是够用的。 B5(C) B4 B3 B2 B1 B0(S) 0 0 0 0 1 0 对23进行编码 23的二进制为10111一共需要5位，第一组字节组只能提供4位来记录值，所以用一组字节组不行，需要使用两组字节组。将 10111拆分为两组，后四位0111放入第一个字节组中，剩下一位1放入第二个字节组中。 B5(C) B4 B3 B2 B1 B0(S)   B5(C) B4 B3 B2 B1 B0 1 0 1 1 1 0   0 0 0 0 0 1 对456进行编码 456的二进制111001000需要占用9个字节，同样，一个字节组放不下，先拆出最后四位（1000）放入一个首位字节组中，剩下的5位（11100）放入跟随的字节组中。 B5(C) B4 B3 B2 B1 B0(S)   B5(C) B4 B3 B2 B1 B0 1 1 0 0 0 0   0 1 1 1 0 0 对7进行编码 3的二进制为111，首位字节组能够存放得下，于是编码为： B5(C) B4 B3 B2 B1 B0(S) 0 0 1 1 1 0 将上面的编码合并得到最终的编码： 000010 101110 000001 110000 011100 001110 base64 编码表 结合上面的 Base64 编码表，上面的结果转成对应的 base64 字符为： CuBwcO 利用 Base64 VLQ 编码生成最终的 srouce map 通过上面讨论的方法，回到开始的示例中，前面我们已经得到的编码为 sources: [&#39;Yoda_input.txt&#39;] names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] mappings (31 字符): 0|0|1|5|0, 4|0|1|4|1, 6|0|1|-9|1; 现在来编码 0|0|1|5|0。先用二进制对每个数字进行表示，再转成 VLQ 表示： 0-&gt; 0 -&gt; 000000 //0 0-&gt; 0 -&gt; 000000 //0 1-&gt; 1 -&gt; 000010 //2 5-&gt; 101 -&gt; 001010 // 10 0-&gt; 0 -&gt; 000000 //0 合并后的编码为： 000000 000000 000001 000101 000000 再转 Base64 后得到字符形式的结果： AACKA 后面两串数通过类似的做法也能得到对应的 Base64编码，所以最终我们得到的 source map 看起来是这样的： sources: [&#39;Yoda_input.txt&#39;] names: [&#39;the&#39;,&#39;force&#39;,&#39;feel&#39;] mappings (18 字符): AACKA, IACIC, MACTC; 而真实的 srouce map 如我们文章开头那个示例一样，是一个 json 文件，所以最后我们得到的一分像模像样的 source map 为： { &quot;version&quot;: 3, &quot;file&quot;: &quot;Yoda_output.txt&quot;, &quot;sources&quot;: [&quot;Yoda_input.txt&quot;], &quot;names&quot;: [&quot;the&quot;, &quot;force&quot;, &quot;feel&quot;], &quot;mappings&quot;: &quot;AACKA,IACIC,MACTC;&quot; } 略去不必要的字段 上面的例子中，每一片段的编码由五位组成。真实场景中，有些情况下某些字段其实不必要，这时就可以将其省略。当然，这里给出的这个例子看不出来。 省略其中某些字段后，一个编码片段就不一定是5位了，他的长度有可能为1，4或者5。 5 - 包含全部五个部分：输出文件中的列号，输入文件索引，输入文件中的行号，输入文件中的列号，符号索引 4 - 输出文件中的列号，输入文件索引，输入文件中的行号，输入文件中的列号 1 - 输出文件中的列号 以上，便探究完了 srouce map 生成的全过程，了解了其原理。 如果感兴趣，这个Source map visualizer tool 工具可以在线将 source map 与对应代码可见化展现出来，方便理解。 另外需要介绍的是，尽管 source map 对于线上调试非常有用，各主流浏览器也实现对其的支持，但关于它的规范没有见诸各 Web 工作组或团体的官方文档中，它的规范是写在一个 Google 文档中的！这你敢信，不信去看一看喽~ Source Map Revision 3 Proposal 。 相关资料 Source Map Revision 3 Proposal Variable-length quantity Base64 Map Preprocessed Code to Source Code Source map visualizer tool Source Maps under the hood – VLQ, Base64 and Yoda Introduction to JavaScript Source Maps BASE64 VLQ 编码规则 后续 source map 的保护","@type":"BlogPosting","headline":"source map 的原理探究","dateModified":"2017-12-05T23:12:00+08:00","datePublished":"2017-12-05T23:12:00+08:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="牛さんの部落格" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">牛さんの部落格</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">source map 的原理探究</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-12-05T23:12:00+08:00" itemprop="datePublished">Dec 5, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="source-map-的原理探究">source map 的原理探究</h2>

<p>线上产品代码一般是编译过的，前端的编译处理过程包括不限于</p>

<ul>
  <li>转译器/Transpilers (Babel, Traceur)</li>
  <li>编译器/Compilers (Closure Compiler, TypeScript, CoffeeScript, Dart)</li>
  <li>压缩/Minifiers (UglifyJS)</li>
</ul>

<p>这里提及的都是可生成source map 的操作。</p>

<p>经过这一系列骚气的操作后，发布到线上的代码已经面目全非，对带宽友好了，但对开发者调试并不友好。于是就有了 source map。顾名思义，他是源码的映射，可以将压缩后的代码再对应回未压缩的源码。使得我们在调试线上产品时，就好像在调试开发环境的代码。</p>

<h3 id="来看一个工作的示例">来看一个工作的示例</h3>

<p>准备两个测试文件，一个 <code class="language-plaintext highlighter-rouge">log.js</code> 里包含一个输出内容到控制台的函数：</p>

<p>log.js</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sayHello</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">name</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">...</span><span class="dl">'</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello,</span><span class="dl">'</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>一个<code class="language-plaintext highlighter-rouge">main.js</code> 文件里面对这个方法进行了调用：
main.js</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">sayHello</span><span class="p">(</span><span class="dl">'</span><span class="s1">世界</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">sayHello</span><span class="p">(</span><span class="dl">'</span><span class="s1">第三世界的人们</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div></div>

<p>我们使用 <code class="language-plaintext highlighter-rouge">uglify-js</code> 将两者合并打包并且压缩。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>uglify-js <span class="nt">-g</span>
uglifyjs log.js main.js <span class="nt">-o</span> output.js <span class="nt">--source-map</span> <span class="s2">"url='/output.js.map'"</span>
</code></pre></div></div>

<p>安装并执行后，我们得到了一个输出文件 <code class="language-plaintext highlighter-rouge">output.js</code>，同时生成了一个 source map 文件 <code class="language-plaintext highlighter-rouge">output.js.map</code>。</p>

<p>output.js</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sayHello</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span><span class="k">if</span><span class="p">(</span><span class="nx">name</span><span class="p">.</span><span class="nx">length</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">){</span><span class="nx">name</span><span class="o">=</span><span class="nx">name</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="dl">"</span><span class="s2">...</span><span class="dl">"</span><span class="p">}</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello,</span><span class="dl">"</span><span class="p">,</span><span class="nx">name</span><span class="p">)}</span><span class="nx">sayHello</span><span class="p">(</span><span class="dl">"</span><span class="s2">世界</span><span class="dl">"</span><span class="p">);</span><span class="nx">sayHello</span><span class="p">(</span><span class="dl">"</span><span class="s2">第三世界的人们</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">//# sourceMappingURL=/output.js.map</span>
</code></pre></div></div>

<p>output.js.map</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"version"</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="nl">"sources"</span><span class="p">:[</span><span class="s2">"log.js"</span><span class="p">,</span><span class="s2">"main.js"</span><span class="p">],</span><span class="nl">"names"</span><span class="p">:[</span><span class="s2">"sayHello"</span><span class="p">,</span><span class="s2">"name"</span><span class="p">,</span><span class="s2">"length"</span><span class="p">,</span><span class="s2">"substr"</span><span class="p">,</span><span class="s2">"console"</span><span class="p">,</span><span class="s2">"log"</span><span class="p">],</span><span class="nl">"mappings"</span><span class="p">:</span><span class="s2">"AAAA,SAASA,SAASC,MACd,GAAIA,KAAKC,OAAS,EAAG,CACjBD,KAAOA,KAAKE,OAAO,EAAG,GAAK,MAE/BC,QAAQC,IAAI,SAAUJ,MCJ1BD,SAAS,MACTA,SAAS"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>为了能够让 source map 能够被浏览器加载和解析，</p>

<ul>
  <li>再添加一个 <code class="language-plaintext highlighter-rouge">index.html</code> 来加载我们生成的这个<code class="language-plaintext highlighter-rouge">output.js</code> 文件。</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1.0"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"X-UA-Compatible"</span> <span class="na">content=</span><span class="s">"ie=edge"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>source map demo<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    source map demo
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"output.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<ul>
  <li>然后开启一个本地服务器，这里我使用 python 自带的server 工具：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 <span class="nt">-m</span> http.server
</code></pre></div></div>

<ul>
  <li>在浏览器中开启 source map 
<code class="language-plaintext highlighter-rouge">source map</code> 在浏览器中默认是关闭的，这样就不会影响正常用户。当我们开启后，浏览器就根据压缩代码中指定的 source map 地址去请求 map 资源。</li>
</ul>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/how-source-map-works/assets/enable-source-map-in-chrome-devtool.png" alt="在浏览器中开启 source map" /></p>

<p><em>在浏览器中开启 source map</em></p>

<p>最后，就可以访问 <code class="language-plaintext highlighter-rouge">http://localhost:8000/</code> 来测试我们的代码了。</p>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/how-source-map-works/assets/debugger-in-output.png" alt="在压缩过的代码中打断点" /></p>

<p><em>在压缩过的代码中打断点</em></p>

<p>从截图中可以看到，开启 source map 后，除了页面中引用的 <code class="language-plaintext highlighter-rouge">output.js</code> 文件，浏览器还加载了生成它的两个源文件，以方便我们在调试浏览器会自动映射回未压缩合并的源文件。</p>

<p>为了测试，我们将 output.js 在调试工具中进行格式化，然后在 <code class="language-plaintext highlighter-rouge">sayHello</code> 函数中打一个断点，看它是否能将这个断点的位置还原到这段代码真实所在的文件及位置。</p>

<p>刷新页面后，我们发现，断点正确定位到了 <code class="language-plaintext highlighter-rouge">log.js</code> 中正确的位置。</p>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/how-source-map-works/assets/source-retrive.png" alt="代码的还原" /></p>

<p><em>代码的还原</em></p>

<p>会否觉得很赞啊！</p>

<p>下面我们来了解它的工作原理。</p>

<h3 id="我们所想象的-source-map">我们所想象的 source map</h3>

<p>将现实中的情况简化一下无非是以下的场景：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入 ⇒ 处理转换（uglify） ⇒ 输出（js）
</code></pre></div></div>
<p>上面，输出无疑就是需要发布到产品线上的浏览器能运行的代码。这里只讨论 js，所以输出是 js 代码，当然，其实source map 也可以运用于其他资源比如 LESS/SASS 等编译到的 CSS。</p>

<p>而 source map 的功能是帮助我们在拿到输出后还原回输入。如果我们自己来实现，应该怎么做。</p>

<p>最直观的想法恐怕是，将生成的文件中每个字符位置对应的原位置保存起来，一一映射。请看来自<a href="https://blogs.msdn.microsoft.com/davidni/2016/03/14/source-maps-under-the-hood-vlq-base64-and-yoda/#comment-626">这篇文章</a>中给出的示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>“feel the force” ⇒ Yoda ⇒ “the force feel”
</code></pre></div></div>
<p>一个简单的文本转换输出，其中 <code class="language-plaintext highlighter-rouge">Yoda</code> 可以理解为一个转换器。将上面的的输入与输出列成表格可以得出这个转换后输入与输出的对应关系。</p>

<table>
  <thead>
    <tr>
      <th>输出位置</th>
      <th>输入</th>
      <th>在输入中的位置</th>
      <th>字符</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>行 1, 列 0</td>
      <td>Yoda_input.txt</td>
      <td>行 1, 列 5</td>
      <td>t</td>
    </tr>
    <tr>
      <td>行 1, 列 1</td>
      <td>Yoda_input.txt</td>
      <td>行 1, 列 6</td>
      <td>h</td>
    </tr>
    <tr>
      <td>行 1, 列 2</td>
      <td>Yoda_input.txt</td>
      <td>行 1, 列 7</td>
      <td>e</td>
    </tr>
    <tr>
      <td>行 1, 列 4</td>
      <td>Yoda_input.txt</td>
      <td>行 1, 列 9</td>
      <td>f</td>
    </tr>
    <tr>
      <td>行 1, 列 5</td>
      <td>Yoda_input.txt</td>
      <td>行 1, 列 10</td>
      <td>o</td>
    </tr>
    <tr>
      <td>行 1, 列 6</td>
      <td>Yoda_input.txt</td>
      <td>行 1, 列 11</td>
      <td>r</td>
    </tr>
    <tr>
      <td>行 1, 列 7</td>
      <td>Yoda_input.txt</td>
      <td>行 1, 列 12</td>
      <td>c</td>
    </tr>
    <tr>
      <td>行 1, 列 8</td>
      <td>Yoda_input.txt</td>
      <td>行 1, 列 13</td>
      <td>e</td>
    </tr>
    <tr>
      <td>行 1, 列 10</td>
      <td>Yoda_input.txt</td>
      <td>行 1, 列 0</td>
      <td>f</td>
    </tr>
    <tr>
      <td>行 1, 列 11</td>
      <td>Yoda_input.txt</td>
      <td>行 1, 列 1</td>
      <td>e</td>
    </tr>
    <tr>
      <td>行 1, 列 12</td>
      <td>Yoda_input.txt</td>
      <td>行 1, 列 2</td>
      <td>e</td>
    </tr>
    <tr>
      <td>行 1, 列 13</td>
      <td>Yoda_input.txt</td>
      <td>行 1, 列 3</td>
      <td>l</td>
    </tr>
  </tbody>
</table>

<p>这里之所以将输入文件也作为映射的必需值，它可以告诉我们从哪里去找源文件。并且，在代码合并时，生成输出文件的源文件不止一个，记录下每处代码来自哪个文件，在还原时也很重要。</p>

<p>上面可以直观看出，生成文件中 (1,0) 位置的字符对应源文件中 (1,5)位置的字符,...
将上面的表格整理记录成一个映射编码看起来会是这样的：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mappings(283 字符):1|0|Yoda_input.txt|1|5, 1|1|Yoda_input.txt|1|6, 1|2|Yoda_input.txt|1|7, 1|4|Yoda_input.txt|1|9, 1|5|Yoda_input.txt|1|10, 1|6|Yoda_input.txt|1|11, 1|7|Yoda_input.txt|1|12, 1|8|Yoda_input.txt|1|13, 1|10|Yoda_input.txt|1|0, 1|11|Yoda_input.txt|1|1, 1|12|Yoda_input.txt|1|2, 1|13|Yoda_input.txt|1|3
</code></pre></div></div>

<p>这样确实能够将处理后的文件映射回原来的文件，但随着内容的增多，转换规则更加地复杂，这个记录映射的编码将飞速增长。这里源文件 <code class="language-plaintext highlighter-rouge">feel the force</code> 才12个字符，而记录他转换的映射就已经达到了283个字符。所以这个编码的方式还有待改进。</p>

<h3 id="省去输出文件中的行号">省去输出文件中的行号</h3>

<p>大多数情况下处理后的文件行数都会少于源文件，特别是 js，使用 UglifyJS 压缩后的文件通常只有一行。基于此，每必要在每条映射中都带上输出文件的行号，转而在这些映射中插入<code class="language-plaintext highlighter-rouge">;</code>来标识换行，可以节省大量空间。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mappings (245 字符): 0|Yoda_input.txt|1|5, 1|Yoda_input.txt|1|6, 2|Yoda_input.txt|1|7, 4|Yoda_input.txt|1|9, 5|Yoda_input.txt|1|10, 6|Yoda_input.txt|1|11, 7|Yoda_input.txt|1|12, 8|Yoda_input.txt|1|13, 10|Yoda_input.txt|1|0, 11|Yoda_input.txt|1|1, 12|Yoda_input.txt|1|2, 13|Yoda_input.txt|1|3;
</code></pre></div></div>

<h3 id="可符号化字符的提取">可符号化字符的提取</h3>

<p>这个例子中，一共有三个单词，拿输出文件中 <code class="language-plaintext highlighter-rouge">the</code> 来说，当我们通过它的第一个字母<code class="language-plaintext highlighter-rouge">t</code>(1,0)确定出对应源文件中的位置(1,5)，后面的<code class="language-plaintext highlighter-rouge">he</code> 其实不用再记录映射了，因为<code class="language-plaintext highlighter-rouge">the</code> 可以作为一个整体来看，试想 js 源码中一个变量名，函数名这些都不会被拆开的，所以当我们确定的这个单词首字母的映射关系，那整个单词其实就能还原到原来的位置了。</p>

<p>所以，首先我们将文件中可符号化的字符提取出来，将他们作为整体来处理。</p>

<table>
  <thead>
    <tr>
      <th>序号</th>
      <th>符号</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>the</td>
    </tr>
    <tr>
      <td>1</td>
      <td>force</td>
    </tr>
    <tr>
      <td>2</td>
      <td>feel</td>
    </tr>
  </tbody>
</table>

<p>于是得到一个所有包含所有符号的数组：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>names: ['the','force','feel']
</code></pre></div></div>

<p>在记录时，只需要记录一个索引，还原时通过索引来这个<code class="language-plaintext highlighter-rouge">names</code> 数组中找即可。所以上面映射规则中最后一列本来记录了每个字符，现在改为记录一个单词，而单词我们只记录其在抽取出来的符号数组中的索引。</p>

<p>所以 <code class="language-plaintext highlighter-rouge">the</code> 的映射由原来的</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0|Yoda_input.txt|1|5, 1|Yoda_input.txt|1|6, 2|Yoda_input.txt|1|7
</code></pre></div></div>

<p>可以简化为</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0|Yoda_input.txt|1|5|0
</code></pre></div></div>

<p>同时，考虑到代码经常会有合并打包的情况，即输入文件不止一个，所以可以将输入文件抽取一个数组，记录时，只需要记录一个索引，还原的时候再到这个数组中通过索引取出文件的位置及文件名即可。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sources: ['Yoda_input.txt']
</code></pre></div></div>

<p>所以上面<code class="language-plaintext highlighter-rouge">the</code> 的映射进一步简化为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0|0|1|5|0
</code></pre></div></div>

<p>于是我们得到了完整的映射为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sources: ['Yoda_input.txt']
names: ['the','force','feel']
mappings (31 字符): 0|0|1|5|0, 4|0|1|9|1, 10|0|1|0|2;
</code></pre></div></div>

<h3 id="记录相对位置">记录相对位置</h3>

<p>当文件内容巨大时，上面精简后的编码也有可能会因为数字位数的增加而变得很长，同时，处理较大数字总是不如处理较小数字容易和方便。于是考虑将上面记录的这些位置用相对值来记录。比如(1,1001)第一行第999列的符号，如果用相对值，我们就不用每次记录都从0开始数，假如前一个符号位置为 (1,999)，那后面这个符号可记录为（0，2），类似这样的相对值帮我们节省了空间，同时降低了数据的维度。</p>

<p>具体到本例中，看看最初的表格中，记录的输出文件中的位置:</p>

<table>
  <thead>
    <tr>
      <th>输出位置</th>
      <th>输出位置</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>行 1, 列 0</td>
      <td>行 1, 列 0</td>
    </tr>
    <tr>
      <td>行 1, 列 4</td>
      <td>行 1, 列 (上一值 + 4 = 4)</td>
    </tr>
    <tr>
      <td>行 1, 列 10</td>
      <td>行 1, 列 (上一值 + 6 = 10)</td>
    </tr>
  </tbody>
</table>

<p>对应到整个表格则是：</p>

<table>
  <thead>
    <tr>
      <th>输出位置</th>
      <th>输入文件的索引</th>
      <th>输入的位置</th>
      <th>符号索引</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>行 1, 列 0</td>
      <td>0</td>
      <td>行 1, 列 5</td>
      <td>0</td>
    </tr>
    <tr>
      <td>行 1, 列 +4</td>
      <td>+0</td>
      <td>行 1, 列 +4</td>
      <td>+1</td>
    </tr>
    <tr>
      <td>行 1, 列 +6</td>
      <td>+0</td>
      <td>行 1, 列 -9</td>
      <td>+1</td>
    </tr>
  </tbody>
</table>

<p>然后我们得到的编码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sources: ['Yoda_input.txt']
names: ['the','force','feel']
mappings (31 字符): 0|0|1|5|0, 4|0|1|4|1, 6|0|1|-9|1;
</code></pre></div></div>

<p><strong>注意</strong></p>
<ul>
  <li>上面记录相对位置后，我们的数字中出现了负值，所以之后解析 source map 文件看到负值就不会感到奇怪了</li>
  <li>另外一点我的思考，对于输出位置来说，因为是递增的，相对位置确实有减小数字的作用，但对于输入位置，效果倒未必是这样了。拿上面映射中最后一组来说，原来的值是 <code class="language-plaintext highlighter-rouge">10|0|1|0|2</code>，改成相对值后为 <code class="language-plaintext highlighter-rouge">6|0|1|-9|1</code>。第四位的值即使去掉减号，因为它在源文件中的位置其实是不确定的，这个相对值可以变得很大，原来一位数记录的，完全有可能变成两位甚至三位。不过这种情况应该比较少，它增加的长度比起对于输出位置使用相对记法后节约的长度要小得多，所以总体上来说空间是被节约了的。</li>
</ul>

<h3 id="vlq-variable-length-quantities">VLQ （Variable Length Quantities）</h3>

<p>进一步的优化则需要引入一个新的概念了，<a href="https://en.wikipedia.org/wiki/Variable-length_quantity">VLQ(Variable-length quantity)</a>。</p>

<h4 id="vlq-以数字的方式呈现">VLQ 以数字的方式呈现</h4>

<p>如果你想顺序记录4个数字，最简单的办法就是将每个数字用特殊的符号隔开：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1|2|3|4
</code></pre></div></div>
<p>如果如果提前告诉你这些被记录的数字都是一位的，那这个分隔线就没必要了，只需要简单记录成如下样子也能被正确识别出来：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1234
</code></pre></div></div>
<p>此时这个记录值的长度是原来的1/2，省了不少空间。</p>

<p>但实际上我们不可能只记录个位数的数字，使用 VLQ 方式时，如果一个数字后面还跟有剩余数字，将其标识出来即可。假设我们想记录如下的四个数字：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1|23|456|7
</code></pre></div></div>

<p>我们使用下划线来标识一个数字后跟有其他数字：</p>

<p>1<ins>2</ins>3<ins>45</ins>67</p>

<p>所以解读规则为：</p>

<ul>
  <li>1没有下划线，那解析出来第一个数字便是1</li>
  <li>2有下划线，则继续解析，碰到3，3没有下划线，第二位数的解析到此为止，所以第二位数为23</li>
  <li>4有下划线，继续，5也有，继续，6没有下划线，所以第三位数字为456</li>
  <li>7没有下划线，第四位数字则为7</li>
</ul>

<h4 id="vlq-以二进制方式的方式呈现">VLQ 以二进制方式的方式呈现</h4>

<p>上面的示例中，引入了数字系统外的符号来标识一个数字还未结束。在二进制系统中，我们使用6个比特来记录一个数字（可表示至多64个值），用其中一个字节来标识它是否未结束(正文 C 标识)，不需要引入额外的符号，再用一位标识正负（下方 S），剩下还有四位用来表示数值。用这样6个字节组成的一组拼起来就可以表示出我们需要的数字串了。</p>

<table>
    <tr>
        <td>B5</td>
        <td>B4</td>
        <td>B3</td>
        <td>B2</td>
        <td>B1</td>
        <td>B0</td>
    </tr>
    <tr>
        <td>C</td>
        <td colspan="4">Value</td>
        <td>S</td>
    </tr>
</table>

<p><em>第一个字节组(四位作为值)</em></p>

<p>这样一个字节组可以表示的数字范围为：</p>

<table>
  <thead>
    <tr>
      <th>Binary group</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>000000</td>
      <td>0</td>
    </tr>
    <tr>
      <td>000001 *</td>
      <td>-0</td>
    </tr>
    <tr>
      <td>000010</td>
      <td>1</td>
    </tr>
    <tr>
      <td>000011</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>000100</td>
      <td>2</td>
    </tr>
    <tr>
      <td>000101</td>
      <td>-2</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>011110</td>
      <td>15</td>
    </tr>
    <tr>
      <td>011111</td>
      <td>-15</td>
    </tr>
    <tr>
      <td>100000</td>
      <td>未结束的0</td>
    </tr>
    <tr>
      <td>100001</td>
      <td>未结束的-0</td>
    </tr>
    <tr>
      <td>100010</td>
      <td>未结束的1</td>
    </tr>
    <tr>
      <td>100011</td>
      <td>未结束的-1</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>111110</td>
      <td>未结束的15</td>
    </tr>
    <tr>
      <td>111111</td>
      <td>未结束的-15</td>
    </tr>
  </tbody>
</table>

<p>* -0 没有实际意义，但技术上它是存在的</p>

<p>任意数字中，第一个字节组中已经标明了该数字的正负，所以后续的字节组中无需再标识，于是可以多出一位来作表示值。</p>

<table>
    <tr>
        <td>B5</td>
        <td>B4</td>
        <td>B3</td>
        <td>B2</td>
        <td>B1</td>
        <td>B0</td>
    </tr>
    <tr>
        <td>C</td>
        <td colspan="5">Value</td>
    </tr>
</table>

<p><em>未结束的字节组(五位作为值)</em></p>

<p>现在我们使用上面的二进制规则来重新编码之前的这个数字序列 <code class="language-plaintext highlighter-rouge">1|23|456|7</code>。</p>

<p>先看每个数字对应的真实二进制是多少：</p>

<table>
  <thead>
    <tr>
      <th>数值</th>
      <th>二进制</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>23</td>
      <td>10111</td>
    </tr>
    <tr>
      <td>456</td>
      <td>111001000</td>
    </tr>
    <tr>
      <td>7</td>
      <td>111</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>对1进行编码</li>
</ul>

<p>1需要一位来表示，还好对于首个字节组，我们有四位来表示值，所以是够用的。</p>

<table>
  <thead>
    <tr>
      <th>B5(C)</th>
      <th>B4</th>
      <th>B3</th>
      <th>B2</th>
      <th>B1</th>
      <th>B0(S)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>对23进行编码</li>
</ul>

<p>23的二进制为10111一共需要5位，第一组字节组只能提供4位来记录值，所以用一组字节组不行，需要使用两组字节组。将 10111拆分为两组，后四位0111放入第一个字节组中，剩下一位1放入第二个字节组中。</p>

<table>
  <thead>
    <tr>
      <th>B5(C)</th>
      <th>B4</th>
      <th>B3</th>
      <th>B2</th>
      <th>B1</th>
      <th>B0(S)</th>
      <th> </th>
      <th>B5(C)</th>
      <th>B4</th>
      <th>B3</th>
      <th>B2</th>
      <th>B1</th>
      <th>B0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td> </td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>对456进行编码</li>
</ul>

<p>456的二进制111001000需要占用9个字节，同样，一个字节组放不下，先拆出最后四位（1000）放入一个首位字节组中，剩下的5位（11100）放入跟随的字节组中。</p>

<table>
  <thead>
    <tr>
      <th>B5(C)</th>
      <th>B4</th>
      <th>B3</th>
      <th>B2</th>
      <th>B1</th>
      <th>B0(S)</th>
      <th> </th>
      <th>B5(C)</th>
      <th>B4</th>
      <th>B3</th>
      <th>B2</th>
      <th>B1</th>
      <th>B0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td> </td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>对7进行编码</li>
</ul>

<p>3的二进制为111，首位字节组能够存放得下，于是编码为：</p>

<table>
  <thead>
    <tr>
      <th>B5(C)</th>
      <th>B4</th>
      <th>B3</th>
      <th>B2</th>
      <th>B1</th>
      <th>B0(S)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>将上面的编码合并得到最终的编码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>000010 101110 000001 110000 011100 001110
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/how-source-map-works/assets/base64-map.png" alt="Base64 编码表" /></p>

<p><em>base64 编码表</em></p>

<p>结合上面的 Base64 编码表，上面的结果转成对应的 base64 字符为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CuBwcO
</code></pre></div></div>

<h4 id="利用-base64-vlq-编码生成最终的-srouce-map">利用 Base64 VLQ 编码生成最终的 srouce map</h4>

<p>通过上面讨论的方法，回到开始的示例中，前面我们已经得到的编码为</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">sources</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Yoda_input.txt</span><span class="dl">'</span><span class="p">]</span>
<span class="nx">names</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">the</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">force</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">feel</span><span class="dl">'</span><span class="p">]</span>
<span class="nx">mappings</span> <span class="p">(</span><span class="mi">31</span> <span class="nx">字符</span><span class="p">):</span> <span class="mi">0</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">1</span><span class="o">|</span><span class="mi">5</span><span class="o">|</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">1</span><span class="o">|</span><span class="mi">4</span><span class="o">|</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">1</span><span class="o">|-</span><span class="mi">9</span><span class="o">|</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>现在来编码 <code class="language-plaintext highlighter-rouge">0|0|1|5|0</code>。先用二进制对每个数字进行表示，再转成 VLQ 表示：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0-&gt; 0 -&gt; 000000 //0
0-&gt; 0 -&gt; 000000 //0
1-&gt; 1 -&gt; 000010 //2
5-&gt; 101 -&gt; 001010 // 10
0-&gt; 0 -&gt; 000000 //0
</code></pre></div></div>

<p>合并后的编码为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>000000 000000 000001 000101 000000
</code></pre></div></div>

<p>再转 Base64 后得到字符形式的结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AACKA
</code></pre></div></div>

<p>后面两串数通过类似的做法也能得到对应的 Base64编码，所以最终我们得到的 source map 看起来是这样的：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sources: ['Yoda_input.txt']
names: ['the','force','feel']
mappings (18 字符): AACKA, IACIC, MACTC;
</code></pre></div></div>

<p>而真实的 srouce map 如我们文章开头那个示例一样，是一个 json 文件，所以最后我们得到的一分像模像样的 source map 为：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">version</span><span class="dl">"</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">file</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Yoda_output.txt</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">sources</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Yoda_input.txt</span><span class="dl">"</span><span class="p">],</span>
    <span class="dl">"</span><span class="s2">names</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">the</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">force</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">feel</span><span class="dl">"</span><span class="p">],</span>
    <span class="dl">"</span><span class="s2">mappings</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">AACKA,IACIC,MACTC;</span><span class="dl">"</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="略去不必要的字段">略去不必要的字段</h4>

<p>上面的例子中，每一片段的编码由五位组成。真实场景中，有些情况下某些字段其实不必要，这时就可以将其省略。当然，这里给出的这个例子看不出来。</p>

<p>省略其中某些字段后，一个编码片段就不一定是5位了，他的长度有可能为1，4或者5。</p>

<ul>
  <li>5 - 包含全部五个部分：输出文件中的列号，输入文件索引，输入文件中的行号，输入文件中的列号，符号索引</li>
  <li>4 - 输出文件中的列号，输入文件索引，输入文件中的行号，输入文件中的列号</li>
  <li>1 - 输出文件中的列号</li>
</ul>

<p>以上，便探究完了 srouce map 生成的全过程，了解了其原理。</p>

<p>如果感兴趣，这个<a href="http://sourcemapper.qfox.nl/">Source map visualizer tool 工具</a>可以在线将 source map 与对应代码可见化展现出来，方便理解。</p>

<p>另外需要介绍的是，尽管 source map 对于线上调试非常有用，各主流浏览器也实现对其的支持，但关于它的规范没有见诸各 Web 工作组或团体的官方文档中，它的规范是写在一个 Google 文档中的！这你敢信，不信去看一看喽~ <a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?hl=en_US&amp;pli=1&amp;pli=1">Source Map Revision 3 Proposal
</a>。</p>

<h3 id="相关资料">相关资料</h3>

<ul>
  <li><a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?hl=en_US&amp;pli=1&amp;pli=1">Source Map Revision 3 Proposal</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Variable-length_quantity">Variable-length quantity</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Base64">Base64</a></li>
  <li><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/source-maps">Map Preprocessed Code to Source Code</a></li>
  <li><a href="http://sourcemapper.qfox.nl/">Source map visualizer tool</a></li>
  <li><a href="https://blogs.msdn.microsoft.com/davidni/2016/03/14/source-maps-under-the-hood-vlq-base64-and-yoda/">Source Maps under the hood – VLQ, Base64 and Yoda</a></li>
  <li><a href="https://www.thecssninja.com/javascript/source-mapping">Introduction to JavaScript Source Maps</a></li>
  <li><a href="http://blog.allenm.me/2012/12/base64-vlq-encoding/">BASE64 VLQ 编码规则</a></li>
</ul>

<h3 id="后续">后续</h3>

<ul>
  <li>source map 的保护</li>
</ul>


  </div><a class="u-url" href="/2017/12/05/source-map-%E7%9A%84%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">牛さんの部落格</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">牛さんの部落格</li><li><a class="u-email" href="mailto:liuwayong@gmail.com">liuwayong@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>notes about the coding life</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
